<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>¢hange.machine</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap");

    :root {
      --bg: #0a0f0c;
      --bg-2: #0f2a1e;
      --bg-3: #050806;
      --grid-rgb: 82, 255, 171;
      --grid: rgba(var(--grid-rgb), 0.12);
      --text: #c9ffe7;
      --muted: #7fe6c1;
      --muted-rgb: 127, 230, 193;
      --glow: #43ffb4;
      --glow-rgb: 67, 255, 180;
      --accent: #ffb84a;
      --accent-rgb: 255, 184, 74;
      --border-rgb: 110, 255, 198;
      --panel-border-rgb: 103, 255, 190;
      --danger: #ff4d6d;
      --danger-rgb: 255, 77, 109;
      --panel: rgba(7, 18, 14, 0.85);
      --panel-border: rgba(var(--panel-border-rgb), 0.3);
      --scanline: rgba(10, 26, 20, 0.35);
      --input-bg: #040b08;
      --timeline-bg: rgba(4, 10, 8, 0.65);
      --button-bg: linear-gradient(120deg, rgba(7, 32, 20, 0.9), rgba(8, 64, 40, 0.9));
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 20%, var(--bg-2) 0%, var(--bg) 45%, var(--bg-3) 100%);
      color: var(--text);
      font-family: "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.02em;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        repeating-linear-gradient(180deg, transparent 0px, transparent 2px, var(--scanline) 3px),
        radial-gradient(800px 600px at 70% 10%, rgba(var(--glow-rgb), 0.15), transparent 60%),
        radial-gradient(700px 500px at 10% 80%, rgba(var(--accent-rgb), 0.15), transparent 60%);
      mix-blend-mode: screen;
      opacity: 0.6;
      pointer-events: none;
      animation: scan 7s linear infinite;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.12'/%3E%3C/svg%3E");
      opacity: 0.2;
      pointer-events: none;
      mix-blend-mode: soft-light;
    }

    @keyframes scan {
      0% { transform: translateY(-2%); }
      100% { transform: translateY(2%); }
    }

    .frame {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px 20px;
    }

    .console {
      width: min(1200px, 100%);
      border: 2px solid var(--panel-border);
      background: var(--panel);
      box-shadow: 0 0 30px rgba(var(--glow-rgb), 0.2), 0 0 90px rgba(var(--glow-rgb), 0.15);
      padding: 28px;
      position: relative;
      overflow: visible;
    }

    .progression-panel {
      position: relative;
      overflow: visible;
    }

    .progression-panel::before {
      content: "";
      position: absolute;
      inset: -10px;
      border: 1px dashed rgba(var(--glow-rgb), 0.2);
      pointer-events: none;
      z-index: 0;
    }

    .song-mode #chordPanel.progression-panel::before {
      opacity: 0;
    }

    .progression-panel > * {
      position: relative;
      z-index: 1;
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 24px;
    }

    .title {
      font-family: "Press Start 2P", system-ui, sans-serif;
      font-size: clamp(18px, 2vw, 26px);
      text-transform: uppercase;
      text-shadow: 0 0 10px var(--glow), 0 0 20px rgba(var(--glow-rgb), 0.4);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent);
      animation: pulse 1.8s ease-in-out infinite;
    }

    .title-dot {
      flex: none;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.4); opacity: 1; }
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(210px, 0.9fr) 2.1fr;
      gap: 16px;
    }

    .song-mode .grid {
      grid-template-columns: minmax(220px, 0.9fr) 2.1fr;
      align-items: start;
    }

    .song-mode #chordPanel {
      grid-column: 1;
      grid-row: 1;
    }

    .song-mode #bassPanel {
      grid-column: 1;
      grid-row: 2;
    }

    .song-mode #timelinePanel {
      grid-column: 2;
      grid-row: 1 / span 2;
    }

    .panel {
      border: 1px solid var(--panel-border);
      padding: 12px;
      background: var(--panel);
      box-shadow: inset 0 0 20px rgba(var(--glow-rgb), 0.15);
      min-width: 0;
    }

    .reset-button {
      position: fixed;
      top: 10px;
      right: 14px;
      z-index: 20;
    }

    .panel h2 {
      margin: 0 0 10px;
      font-size: 11px;
      color: var(--muted);
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    .panel .button-row + h2 {
      margin-top: 6px;
    }

    .panel-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .panel-top h2 {
      margin: 0;
    }

    .panel-top-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .header-button {
      padding: 4px 8px;
      font-size: 11px;
      letter-spacing: 0.2em;
    }

    .icon-toggle {
      padding: 4px 6px;
      font-size: 12px;
      line-height: 1;
      letter-spacing: 0;
      text-transform: none;
    }

    .icon-toggle[aria-pressed="true"] {
      border-color: rgba(var(--danger-rgb, 255, 77, 109), 0.8);
      color: rgba(var(--danger-rgb, 255, 77, 109), 1);
    }

    .panel-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .panel-actions:empty {
      display: none;
      margin-bottom: 0;
    }

    .song-only {
      display: none;
    }

    .song-mode .song-only {
      display: grid;
    }

    .panel.collapsed .controls {
      display: none;
    }

    .panel.collapsed .panel-actions {
      margin-bottom: 0;
    }

    .help-button {
      position: fixed;
      right: 22px;
      bottom: 22px;
      z-index: 10;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--panel);
      color: var(--text);
      padding: 10px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 0 14px rgba(var(--glow-rgb), 0.2);
    }

    .help-button:hover {
      box-shadow: 0 0 18px rgba(var(--glow-rgb), 0.35);
    }

    .song-toggle {
      position: fixed;
      left: 22px;
      bottom: 22px;
      z-index: 10;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--panel);
      color: var(--text);
      padding: 10px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 0 14px rgba(var(--glow-rgb), 0.2);
    }

    .song-toggle:hover {
      box-shadow: 0 0 18px rgba(var(--glow-rgb), 0.35);
    }

    .theme-control {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 9;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--panel);
      border: 1px solid rgba(var(--border-rgb), 0.45);
      border-radius: 6px;
      color: var(--muted);
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.25);
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .theme-control input[type="range"] {
      width: 180px;
    }

    .theme-control .theme-readout {
      display: none;
    }

    @media (max-width: 700px) {
      .theme-control {
        width: calc(100% - 120px);
        justify-content: space-between;
      }

      .theme-control input[type="range"] {
        flex: 1;
        width: auto;
      }

      .theme-control .theme-readout {
        display: none;
      }
    }

    .help-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 5, 0.85);
      z-index: 20;
      padding: 24px;
    }

    .help-modal.active {
      display: flex;
    }

    .help-terminal {
      width: min(720px, 100%);
      background: var(--bg-3);
      border: 1px solid rgba(var(--border-rgb), 0.4);
      box-shadow: 0 0 24px rgba(var(--glow-rgb), 0.3);
      padding: 20px;
      font-size: 12px;
      line-height: 1.6;
    }

    .help-terminal h3 {
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .help-terminal pre {
      margin: 0;
      white-space: pre-wrap;
      color: var(--text);
    }

    .route-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 5, 0.8);
      z-index: 18;
      padding: 24px;
    }

    .route-modal.active {
      display: flex;
    }

    .route-panel {
      width: min(420px, 100%);
      background: var(--panel);
      border: 1px solid rgba(var(--border-rgb), 0.4);
      box-shadow: 0 0 20px rgba(var(--glow-rgb), 0.25);
      padding: 16px;
      font-size: 12px;
    }

    .route-panel h3 {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .route-panel label {
      margin-bottom: 10px;
    }

    .route-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .help-cursor {
      display: inline-block;
      width: 10px;
      height: 1em;
      margin-left: 2px;
      border-left: 2px solid var(--text);
      background: transparent;
      vertical-align: -2px;
      animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .help-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
    }

    .controls {
      display: grid;
      gap: 6px;
      min-width: 0;
    }

    label {
      display: grid;
      gap: 3px;
      font-size: 9px;
      color: var(--muted);
      min-width: 0;
    }

    .label-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .genre-row {
      display: flex;
      gap: 6px;
      min-width: 0;
    }

    .genre-row select {
      flex: 1;
      min-width: 0;
      max-width: 100%;
    }

    input, select, button {
      font-family: inherit;
      font-size: 12px;
    }

    input[type="range"], input[type="number"], input[type="text"], select {
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid rgba(var(--border-rgb), 0.3);
      padding: 3px 5px;
      border-radius: 4px;
      outline: none;
      max-width: 100%;
    }

    select {
      width: 100%;
    }

    input[type="range"] {
      accent-color: var(--glow);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 1px;
    }

    .midi-velocity {
      display: none;
      align-items: center;
      gap: 6px;
      font-size: 9px;
      color: var(--muted);
      padding: 2px 4px;
      border: 1px solid rgba(var(--border-rgb), 0.2);
      border-radius: 4px;
    }

    .midi-on .midi-velocity {
      display: flex;
    }

    .midi-route {
      display: none;
    }

    .midi-on .midi-route {
      display: inline-flex;
      align-items: center;
    }

    .bass-panel {
      display: none;
    }

    .song-mode .bass-panel {
      display: block;
    }

    .midi-velocity input[type="range"] {
      width: 110px;
    }

    .midi-velocity-value {
      color: var(--text);
      font-size: 10px;
      min-width: 22px;
      text-align: right;
    }

    button {
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--button-bg);
      color: var(--text);
      padding: 5px 8px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.35);
    }

    button.secondary {
      border-color: rgba(var(--accent-rgb), 0.6);
      color: var(--accent);
    }


    .readout {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .readout.inline {
      margin-top: 0;
      font-size: 10px;
      color: var(--text);
    }

    .timeline-view {
      --beat-px: 34px;
      --bar-px: calc(var(--beat-px) * 4);
      border: 1px solid rgba(var(--border-rgb), 0.3);
      background: var(--timeline-bg);
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
      overflow-y: hidden;
      padding-bottom: 6px;
      scrollbar-gutter: stable;
    }

    .ruler {
      position: relative;
      height: 32px;
      border-bottom: 1px solid rgba(var(--border-rgb), 0.25);
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.35) 0, rgba(var(--glow-rgb), 0.35) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.12) 0, rgba(var(--glow-rgb), 0.12) 1px, transparent 1px, transparent var(--beat-px));
    }

    .bar-label {
      position: absolute;
      top: 7px;
      font-size: 10px;
      color: var(--muted);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .track {
      position: relative;
      height: 140px;
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.3) 0, rgba(var(--glow-rgb), 0.3) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.08) 0, rgba(var(--glow-rgb), 0.08) 1px, transparent 1px, transparent var(--beat-px));
    }

    .clip {
      position: absolute;
      top: 32px;
      height: 64px;
      border: 1px solid rgba(var(--border-rgb), 0.55);
      border-left-width: 2px;
      border-left-color: rgba(var(--accent-rgb), 0.8);
      background: linear-gradient(135deg, rgba(var(--glow-rgb), 0.2), rgba(4, 10, 8, 0.75));
      color: var(--text);
      padding: 8px 10px;
      text-shadow: 0 0 6px rgba(var(--glow-rgb), 0.5);
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.2);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .clip.active {
      border-color: rgba(var(--accent-rgb), 0.95);
      box-shadow: 0 0 18px rgba(var(--accent-rgb), 0.35);
    }

    .clip-title {
      font-size: 12px;
      margin-bottom: 0;
    }

    .bass-track {
      display: none;
      height: 64px;
      margin-top: 8px;
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.22) 0, rgba(var(--glow-rgb), 0.22) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.06) 0, rgba(var(--glow-rgb), 0.06) 1px, transparent 1px, transparent var(--beat-px));
    }

    .song-mode .bass-track {
      display: block;
    }

    .bass-clip {
      position: absolute;
      top: 0;
      height: 18px;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      border-left-width: 2px;
      border-left-color: rgba(var(--accent-rgb), 0.7);
      background: linear-gradient(135deg, rgba(var(--accent-rgb), 0.18), rgba(0, 0, 0, 0));
      color: var(--text);
      padding: 2px 5px;
      font-size: 9px;
      line-height: 1.1;
      text-shadow: 0 0 4px rgba(var(--glow-rgb), 0.4);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .bass-clip.active {
      border-color: rgba(var(--muted-rgb), 0.95);
      box-shadow: 0 0 12px rgba(var(--muted-rgb), 0.35);
      background: linear-gradient(135deg, rgba(var(--muted-rgb), 0.35), rgba(0, 0, 0, 0));
    }

    .timeline-scroll {
      margin-top: 10px;
    }

    .timeline-scroll input[type="range"] {
      width: 100%;
    }

    .text-export {
      margin-top: 12px;
      display: grid;
      gap: 10px;
    }

    .text-export textarea {
      width: 100%;
      min-height: 80px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid rgba(var(--border-rgb), 0.3);
      padding: 8px 10px;
      border-radius: 4px;
      resize: vertical;
    }

    .progression-highlight {
      display: block;
      border: 1px solid rgba(var(--border-rgb), 0.3);
      background: var(--input-bg);
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text);
      white-space: pre-wrap;
    }

    .progression-highlight mark {
      background: rgba(var(--accent-rgb), 0.25);
      color: var(--text);
      padding: 0 2px;
      border-radius: 3px;
      box-shadow: 0 0 8px rgba(var(--accent-rgb), 0.3);
    }

    .oscilloscope {
      width: 100%;
      height: 120px;
      border: 1px solid rgba(var(--border-rgb), 0.3);
      background: radial-gradient(circle at 20% 20%, rgba(var(--glow-rgb), 0.1), transparent 60%), var(--bg-3);
      box-shadow: inset 0 0 20px rgba(var(--glow-rgb), 0.18);
    }

    .footer {
      margin-top: 18px;
      font-size: 11px;
      color: rgba(var(--muted-rgb), 0.7);
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .song-mode .grid {
        grid-template-columns: minmax(180px, 0.9fr) 2fr;
      }

      .track {
        height: 160px;
      }

      .clip {
        height: 70px;
      }

      .bass-track {
        height: 56px;
      }

      .bass-clip {
        height: 26px;
        top: 12px;
      }
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="console">
      <div class="header">
        <div class="title">
          <span id="titleLeft">¢hange</span>
          <span class="dot title-dot" aria-hidden="true"></span>
          <span id="titleRight">machine</span>
        </div>
      </div>
      <button id="resetAll" class="secondary reset-button">Reset</button>

      <div class="grid">
        <section class="panel progression-panel" id="chordPanel">
          <div class="panel-top">
            <button id="generate" class="header-button">¢hords</button>
            <div class="panel-top-actions">
              <button id="chordMute" class="secondary icon-toggle" aria-pressed="false" title="Mute chords">M</button>
              <button id="chordCollapse" class="secondary">▾</button>
            </div>
          </div>
          <div class="controls">
            <label>
              Key center
              <select id="keySelect"></select>
            </label>
            <label>
              Genre
              <div class="genre-row">
                <select id="genreMain"></select>
                <select id="genreSub"></select>
              </div>
            </label>
            <label>
              Tempo (BPM)
              <input id="tempo" type="range" min="60" max="200" value="110" />
              <span class="readout" id="tempoReadout">110 BPM</span>
            </label>
            <label>
              Bars
              <input id="bars" type="range" min="4" max="32" value="4" />
              <span class="readout" id="barsReadout">4 bars</span>
            </label>
            <label>
              <div class="label-row">
                <span>Harmonic density</span>
                <span class="readout inline" id="densityReadout">50%</span>
              </div>
              <input id="density" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Color</span>
                <span class="readout inline" id="colorReadout">50%</span>
              </div>
              <input id="color" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Modulation amount</span>
                <span class="readout inline" id="modulationReadout">15%</span>
              </div>
              <input id="modulation" type="range" min="0" max="100" value="15" />
            </label>
            <label>
              <div class="label-row">
                <span>Subdivision density</span>
                <span class="readout inline" id="subdivisionDensityReadout">50%</span>
              </div>
              <input id="subdivisionDensity" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              Subdivision mode
              <select id="subdivision">
                <option value="even">Even only</option>
                <option value="mixed">Even + triplet</option>
              </select>
            </label>
            <label class="song-only">
              ch
              <select id="chordChannel"></select>
            </label>
            <label>
              $eed
              <input id="seed" type="text" placeholder="blank $eed" />
            </label>
            <div class="button-row">
              <button id="importSeed" class="secondary">Import $eed</button>
              <button id="copySeed" class="secondary">Copy $eed</button>
              <button id="randomSeed" class="secondary">Random $eed</button>
            </div>
          </div>
        </section>

        <section class="panel bass-panel" id="bassPanel">
          <div class="panel-top">
            <button id="bassGenerate" class="header-button">฿ass</button>
            <div class="panel-top-actions">
              <button id="bassMute" class="secondary icon-toggle" aria-pressed="false" title="Mute bass">M</button>
              <button id="bassCollapse" class="secondary">▾</button>
            </div>
          </div>
          <div class="controls bass-controls">
            <label>
              <div class="label-row">
                <span>Bass density</span>
                <span class="readout inline" id="bassDensityReadout">55%</span>
              </div>
              <input id="bassDensity" type="range" min="0" max="100" value="55" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass movement</span>
                <span class="readout inline" id="bassMovementReadout">40%</span>
              </div>
              <input id="bassMovement" type="range" min="0" max="100" value="40" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass color</span>
                <span class="readout inline" id="bassColorReadout">50%</span>
              </div>
              <input id="bassColor" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass fills</span>
                <span class="readout inline" id="bassFillsReadout">50%</span>
              </div>
              <input id="bassFills" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass subdivision density</span>
                <span class="readout inline" id="bassSubdivisionDensityReadout">45%</span>
              </div>
              <input id="bassSubdivisionDensity" type="range" min="0" max="100" value="45" />
            </label>
            <label>
              Bass subdivision mode
              <select id="bassSubdivision">
                <option value="even">Even only</option>
                <option value="mixed">Even + triplet</option>
              </select>
            </label>
            <label>
              ch
              <select id="bassChannel"></select>
            </label>
            <label>
              Bass style
              <select id="bassStyle">
                <option value="auto">Auto (genre)</option>
                <option value="root">Root</option>
                <option value="octave">Root + octave</option>
                <option value="walk">Walking</option>
                <option value="arp">Arp</option>
              </select>
            </label>
            <label>
              Bass register
              <input id="bassRegister" type="range" min="28" max="52" value="36" />
              <span class="readout" id="bassRegisterReadout">C2</span>
            </label>
            <div class="button-row">
              <button id="bassRandom" class="secondary">Random bass</button>
            </div>
          </div>
        </section>

        <section class="panel" id="timelinePanel">
          <div class="button-row" id="mainActions">
            <button id="play">Play</button>
            <button id="download" class="secondary">Download .mid</button>
            <button id="midiToggle" class="secondary">MIDI Out</button>
            <button id="midiRoute" class="secondary midi-route">Route</button>
            <div class="midi-velocity">
              <span>Vel</span>
              <input id="midiVelocity" type="range" min="1" max="127" value="60" />
              <span id="midiVelocityValue" class="midi-velocity-value">60</span>
            </div>
          </div>
          <h2>Progression</h2>
          <div id="timelineView" class="timeline-view">
            <div id="ruler" class="ruler"></div>
            <div id="track" class="track chord-track"></div>
            <div id="bassTrack" class="track bass-track"></div>
          </div>
          <div class="timeline-scroll">
            <input id="timelineScroll" type="range" min="0" max="0" value="0" />
          </div>
          <div class="text-export">
            <label for="progressionHighlight">Chord text</label>
            <div id="progressionHighlight" class="progression-highlight" role="textbox" aria-readonly="true"></div>
            <textarea id="progressionText" readonly hidden></textarea>
            <button id="copyProgression" class="secondary">Copy progression</button>
          </div>
          <canvas id="oscilloscope" class="oscilloscope"></canvas>
          <div class="footer" id="footer"></div>
        </section>
      </div>
    </div>
  </div>

  <button id="songToggle" class="song-toggle">$ong</button>
  <div class="theme-control">
    <span>Theme</span>
    <input id="themeSlider" type="range" min="0" max="400" value="0" step="1" />
  </div>
  <button id="helpButton" class="help-button">?</button>
  <div id="routeModal" class="route-modal" aria-hidden="true">
    <div class="route-panel" role="dialog" aria-modal="true" aria-labelledby="routeTitle">
      <h3 id="routeTitle">MIDI Routing</h3>
      <label>
        MIDI Out
        <select id="midiOutSelect"></select>
      </label>
      <label>
        MIDI In (clock)
        <select id="midiInSelect"></select>
      </label>
      <div class="route-actions">
        <button id="routeClose" class="secondary">X</button>
      </div>
    </div>
  </div>
  <div id="helpModal" class="help-modal" aria-hidden="true">
    <div class="help-terminal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <h3 id="helpTitle">¢hange.machine // operator manual</h3>
      <pre><span id="helpText"></span><span class="help-cursor" aria-hidden="true"></span></pre>
      <div class="help-actions">
        <button id="helpClose" class="secondary">X</button>
      </div>
    </div>
  </div>

  <script>
    const noteNames = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

    const degreeOffsets = {
      "I": 0,
      "i": 0,
      "ii": 2,
      "iii": 4,
      "IV": 5,
      "iv": 5,
      "V": 7,
      "v": 7,
      "vi": 9,
      "vii": 11,
      "bII": 1,
      "bIII": 3,
      "bVI": 8,
      "bVII": 10,
      "VI": 9,
      "#IV": 6
    };

    const qualities = {
      "maj": [0, 4, 7],
      "m": [0, 3, 7],
      "dim": [0, 3, 6],
      "dim7": [0, 3, 6, 9],
      "m7b5": [0, 3, 6, 10],
      "5": [0, 7, 12],
      "sus2": [0, 2, 7],
      "sus4": [0, 5, 7],
      "add9": [0, 4, 7, 14],
      "6": [0, 4, 7, 9],
      "m6": [0, 3, 7, 9],
      "6/9": [0, 4, 7, 9, 14],
      "7": [0, 4, 7, 10],
      "7sus4": [0, 5, 7, 10],
      "11": [0, 4, 7, 10, 14, 17],
      "9": [0, 4, 7, 10, 14],
      "m7": [0, 3, 7, 10],
      "m9": [0, 3, 7, 10, 14],
      "m11": [0, 3, 7, 10, 14, 17],
      "maj7": [0, 4, 7, 11],
      "maj9#11": [0, 4, 11, 14, 18],
      "maj9": [0, 4, 7, 11, 14],
      "maj13": [0, 4, 7, 11, 14, 21],
      "13b9": [0, 4, 10, 13, 21],
      "13": [0, 4, 10, 14, 21],
      "7alt": [0, 4, 10, 13, 18]
    };
    const qualityLabels = {
      "maj": "maj",
      "m": "m",
      "dim": "dim",
      "dim7": "dim7",
      "m7b5": "m7b5",
      "5": "5",
      "sus2": "sus2",
      "sus4": "sus4",
      "add9": "add9",
      "6": "6",
      "m6": "m6",
      "6/9": "6/9",
      "7": "7",
      "7sus4": "7sus4",
      "11": "11",
      "9": "9",
      "m7": "m7",
      "m9": "m9",
      "m11": "m11",
      "maj7": "maj7",
      "maj9#11": "maj9#11",
      "maj9": "maj9",
      "maj13": "maj13",
      "13b9": "13b9",
      "13": "13",
      "7alt": "7alt"
    };

    const colorQualityPools = {
      maj: {
        low: ["maj", "add9", "6"],
        lowmid: ["maj", "add9", "6/9", "maj7"],
        mid: ["maj7", "6/9", "maj9"],
        high: ["maj9", "maj9#11", "maj13"],
        ultra: ["maj9#11", "maj13"]
      },
      min: {
        low: ["m", "m6"],
        lowmid: ["m", "m6", "m7"],
        mid: ["m7", "m9"],
        high: ["m9", "m11"],
        ultra: ["m11", "m9"]
      },
      dom: {
        low: ["7", "7sus4"],
        lowmid: ["7", "9", "7sus4"],
        mid: ["9", "13", "11"],
        high: ["7alt", "13b9", "13", "11"],
        ultra: ["7alt", "13b9", "13", "11"]
      },
      dim: {
        low: ["dim"],
        lowmid: ["dim"],
        mid: ["dim7"],
        high: ["dim7"],
        ultra: ["dim7"]
      },
      halfdim: {
        low: ["m7b5"],
        lowmid: ["m7b5"],
        mid: ["m7b5"],
        high: ["m7b5"],
        ultra: ["m7b5"]
      },
      sus: {
        low: ["sus2", "sus4"],
        lowmid: ["sus4"],
        mid: ["sus4", "7sus4"],
        high: ["7sus4"],
        ultra: ["7sus4"]
      },
      power: {
        low: ["5"],
        lowmid: ["5"],
        mid: ["5"],
        high: ["5"],
        ultra: ["5"]
      }
    };

    function getQualityFamily(quality) {
      if (["maj", "maj7", "maj9", "maj9#11", "maj13", "6", "6/9", "add9"].includes(quality)) return "maj";
      if (["m", "m7", "m9", "m11", "m6"].includes(quality)) return "min";
      if (["7", "9", "11", "13", "13b9", "7alt", "7sus4"].includes(quality)) return "dom";
      if (["dim", "dim7"].includes(quality)) return "dim";
      if (["m7b5"].includes(quality)) return "halfdim";
      if (["sus2", "sus4"].includes(quality)) return "sus";
      if (["5"].includes(quality)) return "power";
      return "maj";
    }

    function applyColorToQuality(quality, colorPercent, colorSeed) {
      if (!qualities[quality]) return quality;
      const family = getQualityFamily(quality);
      const pools = colorQualityPools[family] || colorQualityPools.maj;
      const tiers = ["low", "lowmid", "mid", "high", "ultra"];
      const rng = makeRng(`${colorSeed}|${quality}`);
      const base = (Math.max(0, Math.min(100, colorPercent)) / 100) * (tiers.length - 1);
      const jitter = (rng() - 0.5) * 0.9;
      const tierIndex = Math.max(0, Math.min(tiers.length - 1, Math.round(base + jitter)));
      const tier = tiers[tierIndex];
      const options = pools[tier] && pools[tier].length ? pools[tier] : [quality];
      return options[Math.floor(rng() * options.length)];
    }

    const genreProfiles = {
      base: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 0,
        subdivisionBias: 0,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9#11" },
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m9" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "iv", quality: "m9" },
            { degree: "iii", quality: "m9" }
          ],
          dominant: [
            { degree: "V", quality: "13b9" },
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "bVII", quality: "13" },
            { degree: "VI", quality: "7alt" }
          ]
        }
      },
      jazz: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "iv", quality: "m7" },
            { degree: "iii", quality: "m7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" },
            { degree: "bII", quality: "7alt" }
          ]
        }
      },
      baroque: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -25,
        subdivisionBias: -0.25,
        functions: {
          tonic: [
            { degree: "I", quality: "maj" },
            { degree: "vi", quality: "m" },
            { degree: "iii", quality: "m" }
          ],
          predom: [
            { degree: "ii", quality: "m" },
            { degree: "IV", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "maj" },
            { degree: "vii", quality: "dim" }
          ]
        }
      },
      classical: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "maj" },
            { degree: "vi", quality: "m" },
            { degree: "iii", quality: "m" }
          ],
          predom: [
            { degree: "ii", quality: "m" },
            { degree: "IV", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "vii", quality: "dim" },
            { degree: "V", quality: "maj" }
          ]
        }
      },
      neoclassical: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m9" },
            { degree: "bVI", quality: "maj" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj7" },
            { degree: "bII", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13b9" }
          ]
        }
      },
      rock: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "V", "IV"],
          ["I", "bVII", "IV", "I"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["5", "maj"],
          "IV": ["5", "maj"],
          "V": ["5", "7"],
          "vi": ["m", "m7"],
          "bVII": ["5", "maj"]
        }
      },
      metal: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: -0.05,
        templates: [
          ["i", "bVI", "bVII", "i"],
          ["i", "bII", "i", "bVII"],
          ["i", "bVI", "i", "bVII"],
          ["i", "bII", "bIII", "bII"]
        ],
        degreeQualities: {
          "i": ["5", "m"],
          "bII": ["5", "maj"],
          "bIII": ["5", "maj"],
          "bVI": ["5", "maj"],
          "bVII": ["5", "maj"]
        }
      },
      punk: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -30,
        subdivisionBias: -0.35,
        templates: [
          ["I", "IV", "V", "IV"],
          ["I", "bVII", "IV", "V"],
          ["I", "V", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["5"],
          "IV": ["5"],
          "V": ["5"],
          "bVII": ["5"]
        }
      },
      pop: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 0,
        subdivisionBias: -0.05,
        templates: [
          ["I", "V", "vi", "IV"],
          ["vi", "IV", "I", "V"],
          ["I", "vi", "IV", "V"],
          ["IV", "V", "iii", "vi"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"],
          "iii": ["m"],
          "ii": ["m"]
        }
      },
      "synth-pop": {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: -0.05,
        templates: [
          ["I", "V", "vi", "IV"],
          ["vi", "IV", "I", "V"],
          ["I", "V", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9", "sus2"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"]
        }
      },
      "indie-pop": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.1,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "vi", "V"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9", "maj7"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9", "maj7"]
        }
      },
      "dream-pop": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        templates: [
          ["I", "vi", "IV", "I"],
          ["I", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"],
          "V": ["sus4", "maj"]
        }
      },
      blues: {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: 0.05,
        bluesBars: [
          { base: "I", passing: ["VI", "ii"] },
          { base: "IV", passing: ["I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["#IV", "IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["IV", "ii"] },
          { base: "IV", passing: ["I", "ii"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["I", "bII"] }
        ],
        bluesQualityMap: {
          "I": ["7", "9"],
          "IV": ["7", "9"],
          "V": ["7", "9", "13"],
          "VI": ["7"],
          "ii": ["m7"],
          "#IV": ["dim7"],
          "bII": ["7alt"]
        }
      },
      "chicago-blues": {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        bluesBars: [
          { base: "I", passing: ["IV", "VI"] },
          { base: "IV", passing: ["I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["#IV", "IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "IV", passing: ["IV", "I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["IV", "ii"] },
          { base: "IV", passing: ["I", "ii"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["I", "bII"] }
        ],
        bluesQualityMap: {
          "I": ["9", "13"],
          "IV": ["9"],
          "V": ["9", "13"],
          "VI": ["7"],
          "ii": ["m7"],
          "#IV": ["dim7"],
          "bII": ["7alt"]
        }
      },
      "delta-blues": {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 0,
        subdivisionBias: 0,
        bluesBars: [
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["IV"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["#IV", "IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "IV", passing: ["I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["VI"] },
          { base: "V", passing: ["bVII"] },
          { base: "bVII", passing: ["IV"] },
          { base: "I", passing: ["VI"] },
          { base: "V", passing: ["I"] }
        ],
        bluesQualityMap: {
          "I": ["7"],
          "IV": ["7"],
          "V": ["7", "9"],
          "VI": ["7"],
          "bVII": ["7"],
          "#IV": ["dim7"]
        }
      },
      "minor-blues": {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: 0.05,
        bluesBars: [
          { base: "i", passing: ["bVI"] },
          { base: "iv", passing: ["i"] },
          { base: "i", passing: ["bVI"] },
          { base: "i", passing: ["#IV", "iv"] },
          { base: "iv", passing: ["iv"] },
          { base: "iv", passing: ["i"] },
          { base: "i", passing: ["bVI"] },
          { base: "i", passing: ["bVI"] },
          { base: "V", passing: ["iv"] },
          { base: "iv", passing: ["i"] },
          { base: "i", passing: ["bVI"] },
          { base: "V", passing: ["i"] }
        ],
        bluesQualityMap: {
          "i": ["m7", "m9"],
          "iv": ["m7"],
          "V": ["7", "9"],
          "bVI": ["maj7"],
          "#IV": ["dim7"]
        }
      },
      rnb: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" },
            { degree: "iii", quality: "m7" }
          ],
          dominant: [
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      soul: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "6/9" },
            { degree: "I", quality: "maj7" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" },
            { degree: "IV", quality: "6/9" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "bVII", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "7sus4" }
          ]
        }
      },
      "neo-soul": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 20,
        subdivisionBias: 0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "I", quality: "6/9" },
            { degree: "vi", quality: "m9" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj9" },
            { degree: "iii", quality: "m9" },
            { degree: "iv", quality: "m9" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13b9" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      funk: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "7" },
            { degree: "I", quality: "9" },
            { degree: "I", quality: "13" }
          ],
          predom: [
            { degree: "IV", quality: "7" },
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "9" }
          ],
          dominant: [
            { degree: "V", quality: "9" },
            { degree: "bVII", quality: "9" },
            { degree: "V", quality: "7sus4" }
          ]
        }
      },
      reggae: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -20,
        subdivisionBias: -0.25,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "bVII", "IV", "V"],
          ["I", "V", "IV", "I"]
        ],
        degreeQualities: {
          "I": ["maj", "sus2"],
          "V": ["maj", "sus4"],
          "vi": ["m"],
          "IV": ["maj", "sus2"],
          "bVII": ["maj"]
        }
      },
      calypso: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: 0.05,
        templates: [
          ["I", "V", "I", "V"],
          ["I", "bVII", "IV", "V"],
          ["I", "vi", "ii", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "6"],
          "V": ["7", "maj"],
          "vi": ["m"],
          "ii": ["m"],
          "IV": ["maj"],
          "bVII": ["maj"]
        }
      },
      ska: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        templates: [
          ["I", "IV", "V", "IV"],
          ["I", "bVII", "IV", "V"],
          ["I", "V", "IV", "I"]
        ],
        degreeQualities: {
          "I": ["maj", "6"],
          "IV": ["maj", "6"],
          "V": ["7", "maj"],
          "bVII": ["maj"]
        }
      },
      dancehall: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.15,
        templates: [
          ["i", "bVII", "bVI", "bVII"],
          ["i", "bVI", "bVII", "i"]
        ],
        degreeQualities: {
          "i": ["m", "m7"],
          "bVI": ["maj"],
          "bVII": ["maj"]
        }
      },
      prog: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 20,
        subdivisionBias: 0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m9" },
            { degree: "bVI", quality: "maj7" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj9" },
            { degree: "bII", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13" }
          ]
        }
      },
      americana: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -25,
        subdivisionBias: -0.3,
        templates: [
          ["I", "IV", "I", "V"],
          ["I", "V", "IV", "I"],
          ["I", "vi", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "IV": ["maj"],
          "V": ["maj", "sus4"],
          "vi": ["m"]
        }
      },
      bebop: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 20,
        subdivisionBias: 0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "ii", quality: "m7b5" },
            { degree: "iv", quality: "m7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" },
            { degree: "bII", quality: "7alt" },
            { degree: "VI", quality: "7" }
          ]
        }
      },
      "hard-bop": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "6/9" },
            { degree: "I", quality: "maj7" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "iv", quality: "m7" },
            { degree: "IV", quality: "7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "bVII", quality: "7" },
            { degree: "#IV", quality: "dim7" }
          ]
        }
      },
      "cool-jazz": {
        type: "functional",
        allowTriplets: true,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      "modal-jazz": {
        type: "template",
        allowTriplets: true,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: 0.1,
        templates: [
          ["i", "bVII", "IV", "i"],
          ["i", "IV", "bVII", "i"],
          ["i", "bVII", "i", "IV"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "bVII": ["7", "9"],
          "IV": ["7", "9"]
        }
      },
      fusion: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 25,
        subdivisionBias: 0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "I", quality: "maj9#11" },
            { degree: "vi", quality: "m9" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj9" },
            { degree: "iii", quality: "m9" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13b9" }
          ]
        }
      },
      lofi: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "6/9" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      gospel: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: 0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "6/9" },
            { degree: "I", quality: "maj7" }
          ],
          predom: [
            { degree: "IV", quality: "maj7" },
            { degree: "ii", quality: "m7" },
            { degree: "bVII", quality: "7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "7sus4" }
          ]
        }
      },
      bossa: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.05,
        templates: [
          ["ii", "V", "I", "VI"],
          ["ii", "V", "I", "I"]
        ],
        degreeQualities: {
          "ii": ["m7"],
          "V": ["7", "9"],
          "I": ["maj7", "6/9"],
          "VI": ["7"]
        }
      },
      "latin-jazz": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "6/9" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" }
          ]
        }
      },
      samba: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: 0.05,
        templates: [
          ["I", "vi", "ii", "V"],
          ["ii", "V", "I", "I"]
        ],
        degreeQualities: {
          "I": ["maj7", "6/9"],
          "vi": ["m7"],
          "ii": ["m7"],
          "V": ["7", "9"]
        }
      },
      swing: {
        type: "functional",
        allowTriplets: true,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      impressionist: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "add9" },
            { degree: "I", quality: "maj7" },
            { degree: "bVI", quality: "maj7" }
          ],
          predom: [
            { degree: "IV", quality: "add9" },
            { degree: "ii", quality: "m7" },
            { degree: "bII", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      romantic: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "maj" },
            { degree: "vi", quality: "m" },
            { degree: "bIII", quality: "maj" }
          ],
          predom: [
            { degree: "ii", quality: "m" },
            { degree: "IV", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "vii", quality: "dim7" }
          ]
        }
      },
      "modern-classical": {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: 5,
        subdivisionBias: -0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "add9" },
            { degree: "I", quality: "sus2" }
          ],
          predom: [
            { degree: "IV", quality: "sus2" },
            { degree: "ii", quality: "m7" },
            { degree: "bII", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      folk: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -25,
        subdivisionBias: -0.35,
        templates: [
          ["I", "IV", "V", "I"],
          ["I", "V", "vi", "IV"],
          ["I", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj"],
          "IV": ["maj"],
          "V": ["maj"],
          "vi": ["m"]
        }
      },
      country: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -30,
        subdivisionBias: -0.35,
        templates: [
          ["I", "IV", "V", "I"],
          ["I", "V", "IV", "I"],
          ["I", "vi", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["maj"],
          "IV": ["maj"],
          "V": ["maj"],
          "vi": ["m"]
        }
      },
      "gypsy-jazz": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "6" },
            { degree: "I", quality: "maj7" },
            { degree: "vi", quality: "m6" }
          ],
          predom: [
            { degree: "ii", quality: "m7b5" },
            { degree: "iv", quality: "m6" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "#IV", quality: "dim7" }
          ]
        }
      },
      "hip-hop": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.2,
        templates: [
          ["i", "bVII", "bVI", "bVII"],
          ["i", "bIII", "bVII", "bVI"],
          ["i", "bVI", "bVII", "i"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "bIII": ["maj7"],
          "bVI": ["maj7"],
          "bVII": ["7"]
        }
      },
      "boom-bap": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.15,
        templates: [
          ["i", "bVII", "bVI", "bVII"],
          ["i", "iv", "bVII", "i"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "iv": ["m7"],
          "bVI": ["maj7"],
          "bVII": ["7"]
        }
      },
      trap: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.1,
        templates: [
          ["i", "bVI", "bVII", "i"],
          ["i", "bVII", "bVI", "i"]
        ],
        degreeQualities: {
          "i": ["m9", "m7"],
          "bVI": ["maj7"],
          "bVII": ["7"]
        }
      },
      "lofi-hiphop": {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.2,
        functions: {
          tonic: [
            { degree: "i", quality: "m7" },
            { degree: "i", quality: "m9" }
          ],
          predom: [
            { degree: "iv", quality: "m7" },
            { degree: "bVI", quality: "maj7" }
          ],
          dominant: [
            { degree: "bVII", quality: "7" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      edm: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: -0.05,
        templates: [
          ["I", "vi", "IV", "V"],
          ["vi", "IV", "I", "V"],
          ["I", "V", "vi", "IV"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"],
          "V": ["maj", "sus4"]
        }
      },
      house: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.05,
        templates: [
          ["I", "vi", "IV", "V"],
          ["ii", "V", "I", "I"]
        ],
        degreeQualities: {
          "I": ["maj7", "6/9"],
          "vi": ["m7"],
          "IV": ["maj7"],
          "V": ["7", "9"],
          "ii": ["m7"]
        }
      },
      downtempo: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.25,
        templates: [
          ["I", "vi", "IV", "I"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"],
          "V": ["sus4", "maj"]
        }
      },
      trance: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        templates: [
          ["I", "V", "vi", "IV"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"]
        }
      },
      dubstep: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: -0.05,
        templates: [
          ["i", "bVI", "bVII", "i"],
          ["i", "bVII", "bVI", "i"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "bVI": ["maj"],
          "bVII": ["maj"]
        }
      },
      indie: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.1,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "vi", "V"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"]
        }
      },
      "post-rock": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -20,
        subdivisionBias: -0.25,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"]
        }
      },
      minimalism: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -35,
        subdivisionBias: -0.45,
        templates: [
          ["I", "I", "IV", "I"],
          ["I", "V", "I", "I"]
        ],
        degreeQualities: {
          "I": ["add9", "sus2"],
          "IV": ["add9", "sus2"],
          "V": ["sus4", "maj"]
        }
      },
      ambient: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -35,
        subdivisionBias: -0.4,
        templates: [
          ["I", "vi", "IV", "I"],
          ["I", "IV", "I", "I"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"]
        }
      }
    };

    const patternsEvenByDensity = {
      1: [[2, 2], [3, 1], [2, 1, 1]],
      2: [[2, 2], [1.5, 1.5, 1], [2, 1, 1], [1, 1, 2]],
      3: [[1, 1, 2], [1.5, 1.5, 1], [2, 1, 1], [1, 1, 1, 1]],
      4: [[1, 1, 1, 1], [1, 1, 2], [1.5, 1, 1.5], [1, 1.5, 1.5]],
      5: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2], [1.5, 1.5, 1]]
    };

    const patternsTripletByDensity = {
      1: [[4 / 3, 4 / 3, 4 / 3], [2, 4 / 3, 2 / 3]],
      2: [[2 / 3, 2 / 3, 2 / 3, 2], [4 / 3, 2 / 3, 2], [2, 2 / 3, 4 / 3]],
      3: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 4 / 3], [4 / 3, 4 / 3, 2 / 3, 2 / 3]],
      4: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3], [4 / 3, 2 / 3, 4 / 3, 2 / 3]],
      5: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3], [2 / 3, 4 / 3, 2 / 3, 4 / 3]]
    };

    const simplePatterns = [[4], [2, 2], [3, 1], [1, 3]];
    const densePatterns = [
      [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
      [0.5, 0.5, 1, 0.5, 0.5, 1],
      [0.5, 0.5, 0.5, 1, 0.5, 0.5]
    ];

    function pickDensityIndex(densityPercent, rng) {
      const clamped = Math.max(0, Math.min(100, densityPercent));
      const scaled = (clamped / 100) * 4;
      const base = Math.floor(scaled);
      const frac = scaled - base;
      const index = rng() < frac ? base + 1 : base;
      return Math.max(1, Math.min(5, index + 1));
    }

    function chooseSubdivisionPattern({
      densityAdjusted,
      subdivisionAdjusted,
      allowTriplets,
      allowDense,
      subdivisionMode,
      rng
    }) {
      const densityIndex = pickDensityIndex(densityAdjusted, rng);
      const evenPatterns = patternsEvenByDensity[densityIndex];
      const tripletPatterns = patternsTripletByDensity[densityIndex];
      let pattern = [4];
      if (subdivisionAdjusted > 0) {
        if (allowDense && densityAdjusted >= 90 && rng() < 0.7) {
          pattern = pick(densePatterns, rng);
        } else if (rng() < subdivisionAdjusted) {
          pattern = pick(evenPatterns, rng);
          if (allowTriplets && subdivisionMode === "mixed" && rng() < 0.35) {
            pattern = pick(tripletPatterns, rng);
          }
        } else {
          pattern = pick(simplePatterns, rng);
        }
      }
      return pattern;
    }

    function xmur3(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function() {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        h ^= h >>> 16;
        return h >>> 0;
      };
    }

    function sfc32(a, b, c, d) {
      return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        let t = (a + b) | 0;
        a = b ^ (b >>> 9);
        b = (c + (c << 3)) | 0;
        c = (c << 21) | (c >>> 11);
        d = (d + 1) | 0;
        t = (t + d) | 0;
        c = (c + t) | 0;
        return (t >>> 0) / 4294967296;
      };
    }

    function makeRng(seedText) {
      const seed = xmur3(seedText)();
      return sfc32(seed, seed ^ 0xa5a5a5a5, seed ^ 0x5a5a5a5a, seed ^ 0x12345678);
    }

    function pick(list, rng) {
      return list[Math.floor(rng() * list.length)];
    }

    function buildChord(rootIndex, quality, rng) {
      const baseRoot = 48 + rootIndex + (rootIndex > 7 ? -12 : 0);
      let notes = qualities[quality].map(interval => baseRoot + interval);

      notes.sort((a, b) => a - b);
      if (notes.length >= 4 && quality !== "5") {
        const dropIndex = notes.length - 2;
        notes[dropIndex] += 12;
        if (notes.length >= 5 && rng() < 0.55) {
          notes[1] += 12;
        }
        notes = notes.sort((a, b) => a - b);
      }

      while (notes[notes.length - 1] > 84) {
        notes[notes.length - 1] -= 12;
        notes = notes.sort((a, b) => a - b);
      }
      return notes;
    }

    function chordName(rootIndex, quality) {
      const label = qualityLabels[quality] ?? quality;
      return `${noteNames[rootIndex]}${label}`;
    }

    function noteLabelFromMidi(note) {
      const safe = Math.max(0, Math.round(note));
      const name = noteNames[safe % 12] || "C";
      const octave = Math.floor(safe / 12) - 1;
      return `${name}${octave}`;
    }

    function clampToRange(note, min, max) {
      let value = note;
      while (value > max) value -= 12;
      while (value < min) value += 12;
      return value;
    }

    function maybeModulateKey(currentKeyIndex, baseKeyIndex, rng, modulationPercent) {
      const chance = Math.max(0, Math.min(100, modulationPercent)) / 100;
      if (chance <= 0) return currentKeyIndex;
      const forceChange = chance >= 1;
      if (forceChange || rng() < chance) {
        if (!forceChange && rng() < 0.25) return baseKeyIndex;
        const steps = [2, 5, 7, 10];
        let nextIndex = currentKeyIndex;
        for (let i = 0; i < 6 && nextIndex === currentKeyIndex; i++) {
          const step = pick(steps, rng) * (rng() < 0.5 ? -1 : 1);
          nextIndex = (currentKeyIndex + step + 12) % 12;
        }
        return nextIndex === currentKeyIndex ? (currentKeyIndex + 7) % 12 : nextIndex;
      }
      return currentKeyIndex;
    }

    function pickBluesQuality(degree, profile, rng) {
      if (profile && profile.bluesQualityMap && profile.bluesQualityMap[degree]) {
        return pick(profile.bluesQualityMap[degree], rng);
      }
      return profile && profile.bluesQuality ? profile.bluesQuality : "7";
    }

    function generateBluesProgression({
      bars,
      key,
      seed,
      rng,
      modulationPercent,
      densityAdjusted,
      subdivisionAdjusted,
      allowTriplets,
      allowDense,
      subdivisionMode,
      profile,
      colorPercent
    }) {
      const totalBars = Math.max(4, bars);
      const keyIndex = noteNames.indexOf(key);
      const bluesBars = profile && profile.bluesBars ? profile.bluesBars : [
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "IV", passing: [] },
        { base: "IV", passing: [] },
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "V", passing: [] },
        { base: "IV", passing: [] },
        { base: "I", passing: [] },
        { base: "V", passing: [] }
      ];
      const chords = [];
      let chordIndex = 0;
      let currentKeyIndex = keyIndex;
      for (let bar = 0; bar < totalBars; bar++) {
        currentKeyIndex = maybeModulateKey(currentKeyIndex, keyIndex, rng, modulationPercent);
        const barDef = bluesBars[bar % bluesBars.length];
        const baseDegree = typeof barDef === "string" ? barDef : barDef.base;
        const passing = typeof barDef === "string" ? [] : (barDef.passing || []);
        const pattern = chooseSubdivisionPattern({
          densityAdjusted,
          subdivisionAdjusted,
          allowTriplets,
          allowDense,
          subdivisionMode,
          rng
        });

        for (let i = 0; i < pattern.length; i++) {
          let degree = baseDegree;
          if (i > 0 && passing.length) {
            degree = pick(passing, rng);
          }
          const offset = degreeOffsets[degree] ?? 0;
          const rootIndex = (currentKeyIndex + offset + 12) % 12;
          const qualityBase = pickBluesQuality(degree, profile, rng);
          const colorSeed = `${seed}|color|${chordIndex}`;
          const quality = applyColorToQuality(qualityBase, colorPercent, colorSeed);
          const voicingSeed = `${seed}|voice|${chordIndex}`;
          chords.push({
            name: chordName(rootIndex, quality),
            quality,
            duration: pattern[i],
            notes: buildChord(rootIndex, quality, makeRng(voicingSeed))
          });
          chordIndex += 1;
        }
      }
      return chords;
    }

    function generateProgression({ bars, key, densityPercent, seed, subdivision, subdivisionDensity, genre, modulationPercent, colorPercent }) {
      const rng = makeRng(seed);
      const totalBars = Math.max(4, bars);
      const totalBeats = totalBars * 4;
      const keyIndex = noteNames.indexOf(key);
      const profile = genreProfiles[genre] || genreProfiles.base;

      if (profile.type === "blues") {
        return generateBluesProgression({
          bars: totalBars,
          key,
          seed,
          rng,
          modulationPercent,
          densityAdjusted: Math.max(0, Math.min(100, densityPercent + (profile.densityBias || 0))),
          subdivisionAdjusted: Math.max(0, Math.min(1, subdivisionDensity + (profile.subdivisionBias || 0))),
          allowTriplets: profile.allowTriplets !== false,
          allowDense: profile.allowDense !== false,
          subdivisionMode: subdivision,
          profile,
          colorPercent
        });
      }

      const densityAdjusted = Math.max(0, Math.min(100, densityPercent + (profile.densityBias || 0)));
      const subdivisionAdjusted = Math.max(0, Math.min(1, subdivisionDensity + (profile.subdivisionBias || 0)));
      const allowTriplets = profile.allowTriplets !== false;
      const allowDense = profile.allowDense !== false;

      let beatsRemaining = totalBeats;
      let functionState = "predom";
      const chords = [];
      let chordIndex = 0;
      const template = profile.type === "template" ? pick(profile.templates, rng) : null;
      let templateIndex = 0;
      let currentKeyIndex = keyIndex;

      for (let bar = 0; bar < totalBars; bar++) {
        currentKeyIndex = maybeModulateKey(currentKeyIndex, keyIndex, rng, modulationPercent);
        const pattern = chooseSubdivisionPattern({
          densityAdjusted,
          subdivisionAdjusted,
          allowTriplets,
          allowDense,
          subdivisionMode: subdivision,
          rng
        });

        for (let i = 0; i < pattern.length; i++) {
          let degree = "I";
          let quality = "maj";

          if (profile.type === "template") {
            degree = template[templateIndex % template.length];
            templateIndex += 1;
            const qualityPool = profile.degreeQualities[degree];
            if (qualityPool && qualityPool.length) {
              quality = pick(qualityPool, rng);
            } else if (degree === degree.toLowerCase()) {
              quality = "m";
            } else {
              quality = "maj";
            }
          } else {
            const isPhraseEnd = (bar % 4 === 3) && (i === pattern.length - 1);
            const isPhrasePrep = (bar % 4 === 3) && (i === pattern.length - 2);

            if (isPhraseEnd) {
              functionState = "tonic";
            } else if (isPhrasePrep) {
              functionState = "dominant";
            } else {
              if (functionState === "tonic") {
                functionState = rng() < 0.7 ? "predom" : "dominant";
              } else if (functionState === "predom") {
                functionState = rng() < 0.75 ? "dominant" : "predom";
              } else {
                functionState = rng() < 0.7 ? "tonic" : "predom";
              }
            }

            const choice = pick(profile.functions[functionState], rng);
            degree = choice.degree;
            quality = choice.quality;
          }

          const offset = degreeOffsets[degree] ?? 0;
          const rootIndex = (currentKeyIndex + offset + 12) % 12;
          const colorSeed = `${seed}|color|${chordIndex}`;
          const coloredQuality = applyColorToQuality(quality, colorPercent, colorSeed);
          const voicingSeed = `${seed}|voice|${chordIndex}`;
          const notes = buildChord(rootIndex, coloredQuality, makeRng(voicingSeed));
          const duration = pattern[i];

          chords.push({
            name: chordName(rootIndex, coloredQuality),
            quality: coloredQuality,
            duration,
            notes
          });
          chordIndex += 1;
          beatsRemaining -= duration;
        }
      }

      if (beatsRemaining > 0.01) {
        const last = chords[chords.length - 1];
        last.duration += beatsRemaining;
      }

      return chords;
    }

    function clampValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function getBassProfile(genreKey, mainKey) {
      const tag = `${mainKey || ""} ${genreKey || ""}`.toLowerCase();
      const profile = {
        style: "root",
        densityBias: 0,
        movementBias: 0,
        subdivisionBias: 0,
        registerBias: 0,
        fillBias: 0
      };

      const setProfile = (overrides) => {
        Object.assign(profile, overrides);
      };

      if (/(bebop|hard-bop|swing|gypsy|manouche)/.test(tag)) {
        setProfile({ style: "walk", densityBias: 20, movementBias: 30, subdivisionBias: 10, registerBias: 2, fillBias: 20 });
      } else if (/(jazz|fusion)/.test(tag)) {
        setProfile({ style: "walk", densityBias: 15, movementBias: 25, subdivisionBias: 8, registerBias: 2, fillBias: 15 });
      } else if (/(blues)/.test(tag)) {
        setProfile({ style: "walk", densityBias: 10, movementBias: 20, subdivisionBias: 6, registerBias: 1, fillBias: 10 });
      } else if (/(funk)/.test(tag)) {
        setProfile({ style: "octave", densityBias: 15, movementBias: 18, subdivisionBias: 15, registerBias: 0, fillBias: 18 });
      } else if (/(neo-soul|soul|rnb|gospel)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 8, movementBias: 16, subdivisionBias: 6, registerBias: 0, fillBias: 12 });
      } else if (/(hip-hop|boom-bap|trap)/.test(tag)) {
        setProfile({ style: "root", densityBias: -5, movementBias: -15, subdivisionBias: -5, registerBias: -4, fillBias: -15 });
      } else if (/(edm|house|trance|dubstep)/.test(tag)) {
        setProfile({ style: "octave", densityBias: 8, movementBias: 6, subdivisionBias: 10, registerBias: -2, fillBias: 8 });
      } else if (/(rock|alt|indie|post-rock)/.test(tag)) {
        setProfile({ style: "octave", densityBias: 5, movementBias: -5, subdivisionBias: 0, registerBias: -1, fillBias: 0 });
      } else if (/(metal)/.test(tag)) {
        setProfile({ style: "root", densityBias: 12, movementBias: -20, subdivisionBias: 2, registerBias: -3, fillBias: -5 });
      } else if (/(punk)/.test(tag)) {
        setProfile({ style: "root", densityBias: 6, movementBias: -15, subdivisionBias: 0, registerBias: -2, fillBias: -5 });
      } else if (/(pop|synth-pop|dream-pop)/.test(tag)) {
        setProfile({ style: "root", densityBias: -2, movementBias: -10, subdivisionBias: 0, registerBias: -1, fillBias: -5 });
      } else if (/(reggae|ska)/.test(tag)) {
        setProfile({ style: "root", densityBias: -10, movementBias: -12, subdivisionBias: -5, registerBias: 0, fillBias: -8 });
      } else if (/(calypso)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 6, movementBias: 10, subdivisionBias: 8, registerBias: 0, fillBias: 8 });
      } else if (/(americana|country|folk)/.test(tag)) {
        setProfile({ style: "root", densityBias: -5, movementBias: -12, subdivisionBias: -5, registerBias: -1, fillBias: -8 });
      } else if (/(classical|baroque|romantic|impression|neoclassical|modern-classical|minimalism)/.test(tag)) {
        setProfile({ style: "arp", densityBias: -5, movementBias: 8, subdivisionBias: -5, registerBias: 1, fillBias: -5 });
      } else if (/(ambient|lofi)/.test(tag)) {
        setProfile({ style: "root", densityBias: -18, movementBias: -18, subdivisionBias: -12, registerBias: -1, fillBias: -20 });
      } else if (/(prog)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 12, movementBias: 22, subdivisionBias: 10, registerBias: 0, fillBias: 12 });
      }

      return profile;
    }

    function chooseBassDurations(duration, densityPercent, subdivisionDensity, allowTriplets, rng) {
      const density = Math.max(0, Math.min(100, densityPercent)) / 100;
      const subdiv = Math.max(0, Math.min(100, subdivisionDensity)) / 100;
      let hits = 1;
      if (density > 0.35 && rng() < density) hits += 1;
      if (density > 0.6 && rng() < density) hits += 1;
      if (density > 0.85 && rng() < density) hits += 1;
      if (allowTriplets && subdiv > 0.65 && rng() < subdiv) {
        hits = Math.max(hits, 3);
      }
      hits = Math.max(1, Math.min(hits, Math.round(duration * 4)));
      const slice = duration / hits;
      return Array.from({ length: hits }, () => slice);
    }

    function getScaleOffsetsForQuality(quality) {
      const family = getQualityFamily(quality);
      if (family === "min") return [0, 2, 3, 5, 7, 8, 10];
      if (family === "dom") return [0, 2, 4, 5, 7, 9, 10];
      if (family === "dim") return [0, 2, 3, 5, 6, 8, 9, 11];
      if (family === "halfdim") return [0, 1, 3, 5, 6, 8, 10];
      if (family === "sus") return [0, 2, 5, 7, 9, 10];
      if (family === "power") return [0, 2, 4, 5, 7, 9, 11];
      return [0, 2, 4, 5, 7, 9, 11];
    }

    function buildScalePitches(rootPc, rangeMin, rangeMax, offsets) {
      const pcs = offsets.map(offset => (rootPc + offset) % 12);
      const pitches = [];
      for (let note = rangeMin; note <= rangeMax; note++) {
        if (pcs.includes(((note % 12) + 12) % 12)) {
          pitches.push(note);
        }
      }
      return pitches;
    }

    function pickNearestScaleNote(target, scalePitches) {
      if (!scalePitches.length) return null;
      let best = scalePitches[0];
      let bestDist = Math.abs(best - target);
      for (let i = 1; i < scalePitches.length; i++) {
        const dist = Math.abs(scalePitches[i] - target);
        if (dist < bestDist) {
          best = scalePitches[i];
          bestDist = dist;
        }
      }
      return best;
    }

    function pickScaleNoteNear(current, scalePitches, rng, movementPercent) {
      if (!scalePitches.length) return null;
      const baseWindow = 2 + Math.round((movementPercent / 100) * 6);
      const window = baseWindow + (rng() < 0.35 ? 1 : 0);
      const candidates = scalePitches.filter(note => Math.abs(note - current) <= window);
      return pick(candidates.length ? candidates : scalePitches, rng);
    }

    function pickChordToneNear(current, chordTones, rng, movementPercent) {
      if (!chordTones.length) return null;
      const baseWindow = 2 + Math.round((movementPercent / 100) * 5);
      const window = baseWindow + (rng() < 0.35 ? 1 : 0);
      const candidates = chordTones.filter(note => Math.abs(note - current) <= window);
      return pick(candidates.length ? candidates : chordTones, rng);
    }

    function pickBassPalette(colorPercent, rng) {
      const t = clampValue(colorPercent, 0, 100) / 100;
      if (t <= 0.5) {
        const mix = t / 0.5;
        return rng() < mix ? "chord" : "root";
      }
      const mix = (t - 0.5) / 0.5;
      return rng() < mix ? "scale" : "chord";
    }

    function filterAvoidMaj7(notes, rootPc) {
      return notes.filter(note => (((note % 12) + 12) % 12) !== ((rootPc + 11) % 12));
    }

    function applyBassFills(durations, fillChance, allowTriplets, rng) {
      const segments = durations.map(dur => ({ dur, fill: false }));
      if (!segments.length || fillChance <= 0) return segments;
      if (rng() >= fillChance) return segments;
      const intensity = Math.max(0, Math.min(1, fillChance));
      const maxSplits = intensity > 0.85 ? 2 : 1;
      let didSplit = false;
      for (let splitIndex = 0; splitIndex < maxSplits; splitIndex++) {
        const idx = segments.length - 1 - splitIndex;
        if (idx < 0) break;
        const segment = segments[idx];
        let splits = allowTriplets && rng() < 0.4 ? 3 : 2;
        if (intensity > 0.7 && rng() < intensity) {
          splits = allowTriplets && rng() < 0.5 ? 3 : 4;
        }
        const slice = segment.dur / splits;
        if (slice < 0.25) continue;
        const replacement = Array.from({ length: splits }, () => ({ dur: slice, fill: true }));
        segments.splice(idx, 1, ...replacement);
        didSplit = true;
      }
      if (!didSplit && segments.length) {
        segments[segments.length - 1].fill = true;
      }
      return segments;
    }

    function generateBassLine({
      chords,
      seed,
      densityPercent,
      movementPercent,
      fillPercent,
      colorPercent,
      subdivisionDensity,
      subdivisionMode,
      style,
      register,
      genre,
      mainGenre
    }) {
      if (!chords || !chords.length) return [];
      const profile = getBassProfile(genre, mainGenre);
      const resolvedStyle = style === "auto" ? profile.style : style;
      const densityAdjusted = clampValue(densityPercent + profile.densityBias, 0, 100);
      const movementAdjusted = clampValue(movementPercent + profile.movementBias, 0, 100);
      const subdivisionAdjusted = clampValue(subdivisionDensity + profile.subdivisionBias, 0, 100);
      const registerAdjusted = clampValue(register + profile.registerBias, 24, 60);
      const fillAdjusted = clampValue((fillPercent || 0) + profile.fillBias, 0, 100);
      const colorAdjusted = clampValue(colorPercent ?? 50, 0, 100);
      const fillChance = fillAdjusted / 100;
      const rng = makeRng(`${seed}|bass|${genre || "base"}`);
      const bassNotes = [];
      const rangeMin = Math.max(20, Math.min(60, registerAdjusted));
      const rangeMax = rangeMin + 12;
      let beatCursor = 0;

      chords.forEach((chord, index) => {
        const duration = chord.duration;
        const allowTriplets = subdivisionMode !== "even";
        const durations = chooseBassDurations(duration, densityAdjusted, subdivisionAdjusted, allowTriplets, rng);
        const segments = applyBassFills(durations, fillChance, allowTriplets, rng);
        const baseRoot = chord.notes[0] ?? 36;
        const quality = chord.quality || "maj";
        const rootPc = ((baseRoot % 12) + 12) % 12;
        const scaleOffsets = getScaleOffsetsForQuality(quality);
        const scalePitches = buildScalePitches(rootPc, rangeMin, rangeMax, scaleOffsets);
        const scaleNoMaj7 = filterAvoidMaj7(scalePitches, rootPc);
        const root = clampToRange(baseRoot - 12, rangeMin, rangeMax);
        const nextChord = chords[(index + 1) % chords.length];
        const nextRootRaw = nextChord && nextChord.notes ? nextChord.notes[0] : baseRoot;
        const targetRoot = clampToRange((nextRootRaw ?? baseRoot) - 12, rangeMin, rangeMax);
        const chordTones = Array.from(new Set(chord.notes.map(note => clampToRange(note - 12, rangeMin, rangeMax))));
        chordTones.sort((a, b) => a - b);
        const chordTonesNoMaj7 = filterAvoidMaj7(chordTones, rootPc);

        let current = root;
        segments.forEach((segment, hitIndex) => {
          const isLastHit = hitIndex === segments.length - 1;
          const isFill = segment.fill;
          let note = root;
          if (hitIndex === 0) {
            const palette = pickBassPalette(colorAdjusted, rng);
            if (palette === "root") {
              note = root;
            } else if (palette === "chord") {
              note = chordTonesNoMaj7.length ? pick(chordTonesNoMaj7, rng) : root;
            } else {
              if (chordTonesNoMaj7.length && rng() < 0.4) {
                note = pick(chordTonesNoMaj7, rng);
              } else if (scaleNoMaj7.length) {
                note = pick(scaleNoMaj7, rng);
              } else {
                note = root;
              }
            }
            note = clampToRange(note, rangeMin, rangeMax);
          } else if (isFill) {
            const approachTarget = isLastHit ? targetRoot : current;
            const approach = pickNearestScaleNote(approachTarget, scalePitches);
            if (approach !== null && (isLastHit || rng() < 0.45)) {
              note = approach;
            } else if (chordTones.length && rng() < 0.35) {
              note = pick(chordTones, rng);
            } else {
              const near = pickScaleNoteNear(current, scalePitches, rng, movementAdjusted);
              note = near !== null ? near : root;
            }
            note = clampToRange(note, rangeMin, rangeMax);
          } else if (resolvedStyle === "octave") {
            const octave = clampToRange(root + 12, rangeMin, rangeMax);
            if (hitIndex % 2 === 0) {
              note = root;
            } else {
              const palette = pickBassPalette(colorAdjusted, rng);
              if (palette === "chord") {
                const nonRoot = chordTones.filter(tone => tone !== root);
                note = nonRoot.length ? pick(nonRoot, rng) : octave;
              } else if (palette === "scale") {
                const near = pickScaleNoteNear(root, scalePitches, rng, movementAdjusted);
                note = near !== null ? near : octave;
              } else {
                note = octave;
              }
            }
          } else if (resolvedStyle === "walk") {
            if (hitIndex === 0) {
              note = root;
            } else if (rng() < movementAdjusted / 100) {
              const palette = pickBassPalette(colorAdjusted, rng);
              if (palette === "root") {
                note = root;
              } else if (palette === "chord") {
                const chordNote = pickChordToneNear(current, chordTones, rng, movementAdjusted);
                note = chordNote !== null ? chordNote : current;
              } else {
                const direction = targetRoot > current ? 1 : -1;
                const step = rng() < 0.6 ? 2 : 1;
                let candidate = current + direction * step;
                if (rng() < movementAdjusted / 100 * 0.25) {
                  candidate = targetRoot + (rng() < 0.5 ? -1 : 1);
                }
                note = clampToRange(candidate, rangeMin, rangeMax);
              }
            } else {
              note = current;
            }
          } else if (resolvedStyle === "arp") {
            const palette = pickBassPalette(colorAdjusted, rng);
            if (palette === "scale" && scalePitches.length) {
              note = scalePitches[hitIndex % scalePitches.length];
            } else if (chordTones.length) {
              note = chordTones[hitIndex % chordTones.length];
            } else {
              note = root;
            }
          } else {
            const palette = pickBassPalette(colorAdjusted, rng);
            if (palette === "root") {
              note = root;
            } else if (palette === "chord") {
              const chordNote = pickChordToneNear(current, chordTones, rng, movementAdjusted);
              note = chordNote !== null ? chordNote : root;
            } else {
              const near = pickScaleNoteNear(current, scalePitches, rng, movementAdjusted);
              note = near !== null ? near : root;
            }
          }

          bassNotes.push({
            note,
            startBeat: beatCursor,
            duration: segment.dur
          });
          current = note;
          beatCursor += segment.dur;
        });
      });

      return bassNotes;
    }

    function writeVarInt(value) {
      let buffer = value & 0x7f;
      const bytes = [];
      while ((value >>= 7)) {
        buffer <<= 8;
        buffer |= ((value & 0x7f) | 0x80);
      }
      while (true) {
        bytes.push(buffer & 0xff);
        if (buffer & 0x80) buffer >>= 8; else break;
      }
      return bytes;
    }

    function buildMidi(chords, bpm, bassNotes = [], chordChannel = getChordChannel(), bassChannel = getBassChannel()) {
      const ticksPerBeat = 480;
      const track = [];
      const events = [];

      function push(...bytes) { track.push(...bytes); }

      const tempo = Math.round(60000000 / bpm);
      events.push({ tick: 0, order: -3, bytes: [0xff, 0x58, 0x04, 0x04, 0x02, 0x18, 0x08] });
      events.push({ tick: 0, order: -2, bytes: [0xff, 0x51, 0x03, (tempo >> 16) & 0xff, (tempo >> 8) & 0xff, tempo & 0xff] });
      events.push({ tick: 0, order: -1, bytes: [0xc0 + chordChannel, 0x04] });
      events.push({ tick: 0, order: -1, bytes: [0xc0 + bassChannel, 0x32] });

      let tickCursor = 0;
      chords.forEach(chord => {
        chord.notes.forEach(note => {
          events.push({ tick: tickCursor, order: 1, bytes: [0x90 + chordChannel, note, 92] });
        });
        const durationTicks = Math.max(1, Math.round(chord.duration * ticksPerBeat));
        chord.notes.forEach(note => {
          events.push({ tick: tickCursor + durationTicks, order: 0, bytes: [0x80 + chordChannel, note, 0] });
        });
        tickCursor += durationTicks;
      });

      bassNotes.forEach(note => {
        const startTick = Math.max(0, Math.round(note.startBeat * ticksPerBeat));
        const durationTicks = Math.max(1, Math.round(note.duration * ticksPerBeat));
        events.push({ tick: startTick, order: 1, bytes: [0x90 + bassChannel, note.note, 84] });
        events.push({ tick: startTick + durationTicks, order: 0, bytes: [0x80 + bassChannel, note.note, 0] });
      });

      events.sort((a, b) => (a.tick - b.tick) || (a.order - b.order));
      let lastTick = 0;
      events.forEach(event => {
        const delta = event.tick - lastTick;
        lastTick = event.tick;
        push(...writeVarInt(delta), ...event.bytes);
      });

      push(...writeVarInt(0), 0xff, 0x2f, 0x00);

      const trackLength = track.length;
      const header = [
        0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x01, (ticksPerBeat >> 8) & 0xff, ticksPerBeat & 0xff
      ];
      const trackHeader = [
        0x4d, 0x54, 0x72, 0x6b,
        (trackLength >> 24) & 0xff,
        (trackLength >> 16) & 0xff,
        (trackLength >> 8) & 0xff,
        trackLength & 0xff
      ];

      return new Uint8Array([...header, ...trackHeader, ...track]);
    }

    function buildProgressionTokens(chords) {
      const tokens = [];
      let beatInBar = 0;
      const eps = 1e-6;

      chords.forEach((chord, index) => {
        tokens.push({ type: "chord", text: chord.name, index });
        beatInBar += chord.duration;
        if (beatInBar >= 4 - eps) {
          tokens.push({ type: "bar", text: " | " });
          beatInBar -= 4;
          if (beatInBar < eps) beatInBar = 0;
        } else {
          tokens.push({ type: "space", text: " " });
        }
      });

      if (tokens.length && tokens[tokens.length - 1].type !== "bar") {
        tokens.push({ type: "bar", text: " | " });
      }

      return tokens;
    }

    function formatProgressionTextFromTokens(tokens) {
      return tokens.map(token => token.text).join("").replace(/\s\|\s$/, "");
    }

    function renderProgressionHighlight(activeIndex) {
      if (!progressionHighlight) return;
      const html = chordTextTokens.map(token => {
        if (token.type === "chord") {
          if (token.index === activeIndex) {
            return `<mark>${token.text}</mark>`;
          }
          return token.text;
        }
        return token.text;
      }).join("");
      progressionHighlight.innerHTML = html.replace(/\s\|\s$/, "");
    }

    function renderBassTrack() {
      if (!bassTrack) return;
      bassTrack.innerHTML = "";
      bassClips = [];
      activeBassClips.clear();
      if (!currentBass || !currentBass.length) {
        bassTrack.style.height = "64px";
        return;
      }
      const notes = currentBass.map(note => note.note);
      const minNote = Math.min(...notes);
      const maxNote = Math.max(...notes);
      const laneCount = Math.max(3, Math.min(7, Math.round((maxNote - minNote) / 2) || 3));
      const laneHeight = 18;
      const padY = 6;
      const trackHeight = padY * 2 + laneHeight * laneCount;
      bassTrack.style.height = `${trackHeight}px`;
      currentBass.forEach((note, index) => {
        const clip = document.createElement("div");
        clip.className = "bass-clip";
        clip.style.left = `${note.startBeat * currentBeatPx}px`;
        clip.style.width = `${Math.max(currentBeatPx * 0.5, note.duration * currentBeatPx)}px`;
        let laneIndex = 0;
        if (maxNote > minNote) {
          const normalized = (maxNote - note.note) / (maxNote - minNote);
          laneIndex = Math.max(0, Math.min(laneCount - 1, Math.round(normalized * (laneCount - 1))));
        }
        clip.style.top = `${padY + laneIndex * laneHeight}px`;
        clip.textContent = noteLabelFromMidi(note.note);
        clip.addEventListener("click", (event) => {
          event.preventDefault();
          auditionBassNote(note.note, note.duration, note.startBeat, index);
        });
        bassTrack.appendChild(clip);
        bassClips.push({ el: clip, startBeat: note.startBeat, duration: note.duration, note: note.note });
      });
    }

    function rebuildMidi() {
      if (!currentChords.length) return;
      currentMidi = buildMidi(currentChords, currentBpm, currentBass);
      if (midiBlobUrl) {
        URL.revokeObjectURL(midiBlobUrl);
      }
      const midiBlob = new Blob([currentMidi], { type: "audio/midi" });
      midiBlobUrl = URL.createObjectURL(midiBlob);
    }

    function getBassSeedLabel(baseSeed, forceNew = false) {
      if (forceNew) {
        bassSeedCounter += 1;
        const rand = Math.random().toString(36).slice(2, 6);
        return `${baseSeed}|bass-${bassSeedCounter}-${rand}`;
      }
      return `${baseSeed}|bass-${bassSeedCounter}`;
    }

    function regenerateBass(forceNew = false) {
      if (!currentChords.length) return;
      const seedLabel = currentSeed || seedInput?.value || "$eed-bass";
      const bassSeed = getBassSeedLabel(seedLabel, forceNew);
      currentBass = generateBassLine({
        chords: currentChords,
        seed: bassSeed,
        densityPercent: parseInt(bassDensityInput?.value, 10) || 0,
        movementPercent: parseInt(bassMovementInput?.value, 10) || 0,
        fillPercent: parseInt(bassFillsInput?.value, 10) || 0,
        colorPercent: parseInt(bassColorInput?.value, 10) || 0,
        subdivisionDensity: parseInt(bassSubdivisionDensityInput?.value, 10) || 0,
        subdivisionMode: bassSubdivisionInput?.value || "even",
        style: bassStyleInput?.value || "auto",
        register: parseInt(bassRegisterInput?.value, 10) || 36,
        genre: genreSub?.value || "base",
        mainGenre: genreMain?.value || ""
      });
      bassAutoRegenerate = true;
      renderBassTrack();
      rebuildMidi();
    }

    function sanitizeFileName(name) {
      const cleaned = name
        .toString()
        .trim()
        .replace(/\s+/g, "_")
        .replace(/[^a-zA-Z0-9_$-]/g, "");
      return cleaned.length ? cleaned : "change.machine";
    }

    function resetToDefaults() {
      stopPlayback();
      seedIsRandom = false;
      seedDrivesSettings = false;
      seedManual = false;
      bassAutoRegenerate = false;
      bassSeedCounter = 0;
      chordMuted = false;
      bassMuted = false;
      updateMuteButton(chordMute, chordMuted);
      updateMuteButton(bassMute, bassMuted);
      if (keySelect) keySelect.value = "random";
      if (genreMain && genreSub) populateGenreSelects("core", "base");
      if (tempoInput) tempoInput.value = "110";
      if (barsInput) barsInput.value = "4";
      if (densityInput) densityInput.value = "50";
      if (colorInput) colorInput.value = "50";
      if (modulationInput) modulationInput.value = "15";
      if (subdivisionDensityInput) subdivisionDensityInput.value = "50";
      if (subdivisionInput) subdivisionInput.value = "even";
      if (seedInput) seedInput.value = "";
      if (chordChannelSelect) chordChannelSelect.value = "1";
      if (bassChannelSelect) bassChannelSelect.value = "2";
      if (bassDensityInput) bassDensityInput.value = "55";
      if (bassMovementInput) bassMovementInput.value = "40";
      if (bassColorInput) bassColorInput.value = "50";
      if (bassFillsInput) bassFillsInput.value = "50";
      if (bassSubdivisionDensityInput) bassSubdivisionDensityInput.value = "45";
      if (bassSubdivisionInput) bassSubdivisionInput.value = "even";
      if (bassStyleInput) bassStyleInput.value = "auto";
      if (bassRegisterInput) bassRegisterInput.value = "36";
      if (midiEnabled) {
        midiEnabled = false;
        sendAllNotesOff();
        midiOutput = null;
        if (midiInput) {
          midiInput.onmidimessage = null;
          midiInput = null;
        }
        externalBpm = null;
        lastClockTime = null;
        clockSmoothing = null;
        tempoInput.disabled = false;
        if (midiVelocity) {
          midiVelocity.disabled = true;
          midiVelocity.value = "60";
          midiVelocityValue.textContent = "60";
        }
        midiToggle.textContent = "MIDI Out";
        document.body.classList.remove("midi-on");
        closeRouteModal();
      } else if (midiVelocity) {
        midiVelocity.value = "60";
        midiVelocityValue.textContent = "60";
      }
      if (themeSlider) {
        themeSlider.value = "0";
        applyThemeMix(0);
      }
      if (songMode) {
        setSongMode(false);
      }
      updateReadouts();
      render();
    }

    const keySelect = document.getElementById("keySelect");
    const genreMain = document.getElementById("genreMain");
    const genreSub = document.getElementById("genreSub");
    const tempoInput = document.getElementById("tempo");
    const tempoReadout = document.getElementById("tempoReadout");
    const barsInput = document.getElementById("bars");
    const densityInput = document.getElementById("density");
    const colorInput = document.getElementById("color");
    const modulationInput = document.getElementById("modulation");
    const subdivisionDensityInput = document.getElementById("subdivisionDensity");
    const subdivisionInput = document.getElementById("subdivision");
    const seedInput = document.getElementById("seed");
    const themeSlider = document.getElementById("themeSlider");
    const midiToggle = document.getElementById("midiToggle");
    const midiRoute = document.getElementById("midiRoute");
    const routeModal = document.getElementById("routeModal");
    const routeClose = document.getElementById("routeClose");
    const midiOutSelect = document.getElementById("midiOutSelect");
    const midiInSelect = document.getElementById("midiInSelect");
    const midiVelocity = document.getElementById("midiVelocity");
    const midiVelocityValue = document.getElementById("midiVelocityValue");
    const importSeed = document.getElementById("importSeed");
    const copySeed = document.getElementById("copySeed");
    const randomSeed = document.getElementById("randomSeed");
    const helpButton = document.getElementById("helpButton");
    const helpModal = document.getElementById("helpModal");
    const helpClose = document.getElementById("helpClose");
    const helpText = document.getElementById("helpText");
    const resetAll = document.getElementById("resetAll");
    const barsReadout = document.getElementById("barsReadout");
    const densityReadout = document.getElementById("densityReadout");
    const colorReadout = document.getElementById("colorReadout");
    const modulationReadout = document.getElementById("modulationReadout");
    const subdivisionDensityReadout = document.getElementById("subdivisionDensityReadout");
    const chordPanel = document.getElementById("chordPanel");
    const chordCollapse = document.getElementById("chordCollapse");
    const chordMute = document.getElementById("chordMute");
    const bassPanel = document.getElementById("bassPanel");
    const bassGenerate = document.getElementById("bassGenerate");
    const bassCollapse = document.getElementById("bassCollapse");
    const bassMute = document.getElementById("bassMute");
    const bassDensityInput = document.getElementById("bassDensity");
    const bassDensityReadout = document.getElementById("bassDensityReadout");
    const bassMovementInput = document.getElementById("bassMovement");
    const bassMovementReadout = document.getElementById("bassMovementReadout");
    const bassColorInput = document.getElementById("bassColor");
    const bassColorReadout = document.getElementById("bassColorReadout");
    const bassFillsInput = document.getElementById("bassFills");
    const bassFillsReadout = document.getElementById("bassFillsReadout");
    const bassSubdivisionDensityInput = document.getElementById("bassSubdivisionDensity");
    const bassSubdivisionDensityReadout = document.getElementById("bassSubdivisionDensityReadout");
    const bassSubdivisionInput = document.getElementById("bassSubdivision");
    const chordChannelSelect = document.getElementById("chordChannel");
    const bassChannelSelect = document.getElementById("bassChannel");
    const bassStyleInput = document.getElementById("bassStyle");
    const bassRegisterInput = document.getElementById("bassRegister");
    const bassRegisterReadout = document.getElementById("bassRegisterReadout");
    const bassRandom = document.getElementById("bassRandom");
    const timelineView = document.getElementById("timelineView");
    const ruler = document.getElementById("ruler");
    const track = document.getElementById("track");
    const bassTrack = document.getElementById("bassTrack");
    const timelineScroll = document.getElementById("timelineScroll");
    const progressionText = document.getElementById("progressionText");
    const progressionHighlight = document.getElementById("progressionHighlight");
    const copyProgression = document.getElementById("copyProgression");
    const playButton = document.getElementById("play");
    const generateButton = document.getElementById("generate");
    const mainActions = document.getElementById("mainActions");
    const oscilloscope = document.getElementById("oscilloscope");
    const footer = document.getElementById("footer");
    const songToggle = document.getElementById("songToggle");
    const titleLeft = document.getElementById("titleLeft");
    const titleRight = document.getElementById("titleRight");

    const randomOption = document.createElement("option");
    randomOption.value = "random";
    randomOption.textContent = "Random";
    keySelect.appendChild(randomOption);

    noteNames.forEach(name => {
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      keySelect.appendChild(option);
    });
    keySelect.value = "random";

    function populateChannelSelect(select, defaultValue) {
      if (!select) return;
      select.innerHTML = "";
      for (let i = 1; i <= 16; i++) {
        const option = document.createElement("option");
        option.value = String(i);
        option.textContent = String(i);
        select.appendChild(option);
      }
      select.value = String(defaultValue);
    }

    populateChannelSelect(chordChannelSelect, 1);
    populateChannelSelect(bassChannelSelect, 2);

    const genreCatalog = {
      core: {
        label: "Core",
        sub: {
          base: "Base",
          jazz: "Jazz",
          lofi: "Lo-fi",
          ambient: "Ambient"
        }
      },
      jazz: {
        label: "Jazz",
        sub: {
          jazz: "Jazz",
          bebop: "Bebop",
          "hard-bop": "Hard-bop",
          "cool-jazz": "Cool jazz",
          "modal-jazz": "Modal jazz",
          fusion: "Fusion",
          swing: "Swing",
          lofi: "Lo-fi",
          bossa: "Bossa nova",
          "latin-jazz": "Latin jazz",
          samba: "Samba",
          "gypsy-jazz": "Gypsy (manouche)"
        }
      },
      classical: {
        label: "Classical",
        sub: {
          baroque: "Baroque",
          classical: "Classical",
          romantic: "Romantic",
          impressionist: "Impressionist",
          "modern-classical": "Modern classical",
          neoclassical: "Neoclassical",
          minimalism: "Minimalism"
        }
      },
      rock: {
        label: "Rock",
        sub: {
          rock: "Rock",
          metal: "Metal",
          punk: "Punk",
          prog: "Prog",
          "post-rock": "Post-rock",
          indie: "Indie"
        }
      },
      soul: {
        label: "Soul / R&B",
        sub: {
          rnb: "R&B",
          soul: "Soul",
          "neo-soul": "Neo-soul",
          funk: "Funk",
          gospel: "Gospel"
        }
      },
      pop: {
        label: "Pop",
        sub: {
          pop: "Pop",
          "synth-pop": "Synth-pop",
          "indie-pop": "Indie pop",
          "dream-pop": "Dream pop"
        }
      },
      blues: {
        label: "Blues",
        sub: {
          blues: "Blues",
          "chicago-blues": "Chicago blues",
          "delta-blues": "Delta blues",
          "minor-blues": "Minor blues"
        }
      },
      caribbean: {
        label: "Caribbean",
        sub: {
          reggae: "Reggae",
          calypso: "Calypso",
          ska: "Ska",
          dancehall: "Dancehall"
        }
      },
      folk: {
        label: "Folk / Americana",
        sub: {
          folk: "Folk",
          americana: "Americana",
          country: "Country"
        }
      },
      electronic: {
        label: "Electronic",
        sub: {
          edm: "EDM",
          house: "House",
          downtempo: "Downtempo",
          trance: "Trance",
          dubstep: "Dubstep"
        }
      },
      hiphop: {
        label: "Hip-hop",
        sub: {
          "hip-hop": "Hip-hop",
          "boom-bap": "Boom bap",
          trap: "Trap",
          "lofi-hiphop": "Lo-fi hip-hop"
        }
      }
    };

    function populateGenreSelects(preferredMain, preferredSub) {
      if (!genreMain || !genreSub) return;
      genreMain.innerHTML = "";
      Object.keys(genreCatalog).forEach(key => {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = genreCatalog[key].label;
        genreMain.appendChild(option);
      });
      const mainValue = preferredMain && genreCatalog[preferredMain] ? preferredMain : "core";
      genreMain.value = mainValue;
      populateSubgenres(mainValue, preferredSub || "base");
    }

    function populateSubgenres(mainKey, preferredSub) {
      if (!genreSub) return;
      const group = genreCatalog[mainKey] || genreCatalog.core;
      genreSub.innerHTML = "";
      const keys = Object.keys(group.sub);
      keys.forEach(key => {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = group.sub[key];
        genreSub.appendChild(option);
      });
      if (preferredSub && group.sub[preferredSub]) {
        genreSub.value = preferredSub;
      } else {
        genreSub.value = keys[0];
      }
    }

    populateGenreSelects("core", "base");

    function buildGenreLookup() {
      const subToMain = {};
      const labelToSub = {};
      Object.keys(genreCatalog).forEach(mainKey => {
        const sub = genreCatalog[mainKey].sub;
        Object.keys(sub).forEach(subKey => {
          subToMain[subKey] = mainKey;
          labelToSub[sub[subKey].toLowerCase()] = subKey;
        });
      });
      return { subToMain, labelToSub };
    }

    const genreLookup = buildGenreLookup();

    function applyGenreFromSeed(seedText) {
      if (!genreMain || !genreSub || !seedText) return false;
      const raw = seedText.toLowerCase().replace(/^\$eed[-\s]*/i, "");
      if (!raw) return false;
      let mainKey = null;
      let subKey = null;
      const match = raw.match(/([a-z0-9-]+)\s*[:/]\s*([a-z0-9-]+)/i);
      if (match) {
        const candidateMain = match[1].toLowerCase();
        const candidateSub = match[2].toLowerCase();
        if (genreCatalog[candidateMain] && genreCatalog[candidateMain].sub[candidateSub]) {
          mainKey = candidateMain;
          subKey = candidateSub;
        } else if (genreLookup.subToMain[candidateSub]) {
          mainKey = genreLookup.subToMain[candidateSub];
          subKey = candidateSub;
        }
      }
      if (!subKey) {
        Object.keys(genreLookup.subToMain).some(key => {
          if (raw.includes(key)) {
            subKey = key;
            mainKey = genreLookup.subToMain[key];
            return true;
          }
          return false;
        });
      }
      if (!subKey) {
        Object.keys(genreLookup.labelToSub).some(label => {
          if (raw.includes(label)) {
            subKey = genreLookup.labelToSub[label];
            mainKey = genreLookup.subToMain[subKey];
            return true;
          }
          return false;
        });
      }
      if (mainKey && subKey) {
        genreMain.value = mainKey;
        populateSubgenres(mainKey, subKey);
        return true;
      }
      return false;
    }

    function applySeedSettings(seedText) {
      if (!seedText) return;
      const usedExplicit = applyGenreFromSeed(seedText);
      const rng = makeRng(`${seedText}|settings`);
      if (!usedExplicit && genreMain && genreSub) {
        const mainKeys = Object.keys(genreCatalog);
        const mainPick = mainKeys[Math.floor(rng() * mainKeys.length)];
        genreMain.value = mainPick;
        populateSubgenres(mainPick);
        const subKeys = Object.keys(genreCatalog[mainPick].sub);
        genreSub.value = subKeys[Math.floor(rng() * subKeys.length)];
      }
      if (densityInput) densityInput.value = String(Math.floor(rng() * 101));
      if (colorInput) colorInput.value = String(Math.floor(rng() * 101));
      if (subdivisionDensityInput) subdivisionDensityInput.value = String(Math.floor(rng() * 101));
      if (modulationInput) modulationInput.value = String(Math.floor(rng() * 101));
      if (barsInput) barsInput.value = String(4 + Math.floor(rng() * 29));
      if (tempoInput) tempoInput.value = String(60 + Math.floor(rng() * 141));
      if (subdivisionInput) subdivisionInput.value = rng() < 0.5 ? "even" : "mixed";
      updateReadouts();
    }

    let oscStrokeColor = "rgba(67, 255, 180, 1)";
    let oscShadowColor = "rgba(67, 255, 180, 0.5)";
    let oscMidColor = "rgba(67, 255, 180, 0.2)";
    let oscFillColor = "rgba(2, 7, 5, 0.9)";

    function updateThemeColors() {
      const root = getComputedStyle(document.documentElement);
      const glowRgb = root.getPropertyValue("--glow-rgb").trim() || "67, 255, 180";
      const bg3 = root.getPropertyValue("--bg-3").trim() || "#020705";
      oscStrokeColor = `rgba(${glowRgb}, 1)`;
      oscShadowColor = `rgba(${glowRgb}, 0.5)`;
      oscMidColor = `rgba(${glowRgb}, 0.2)`;
      oscFillColor = bg3;
    }

    const themes = [
      {
        name: "Neo Green",
        vars: {
          "--bg": "#0a0f0c",
          "--bg-2": "#0f2a1e",
          "--bg-3": "#050806",
          "--grid-rgb": "82, 255, 171",
          "--text": "#c9ffe7",
          "--muted": "#7fe6c1",
          "--muted-rgb": "127, 230, 193",
          "--glow": "#43ffb4",
          "--glow-rgb": "67, 255, 180",
          "--accent": "#ffb84a",
          "--accent-rgb": "255, 184, 74",
          "--border-rgb": "110, 255, 198",
          "--panel-border-rgb": "103, 255, 190",
          "--panel": "rgba(7, 18, 14, 0.85)",
          "--scanline": "rgba(10, 26, 20, 0.35)",
          "--input-bg": "#040b08",
          "--timeline-bg": "rgba(4, 10, 8, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(7, 32, 20, 0.9), rgba(8, 64, 40, 0.9))"
        }
      },
      {
        name: "Amber CRT",
        vars: {
          "--bg": "#1a1208",
          "--bg-2": "#2a1b0f",
          "--bg-3": "#0b0704",
          "--grid-rgb": "255, 196, 120",
          "--text": "#ffe8c6",
          "--muted": "#f0c998",
          "--muted-rgb": "240, 201, 152",
          "--glow": "#ffb347",
          "--glow-rgb": "255, 179, 71",
          "--accent": "#4ad1ff",
          "--accent-rgb": "74, 209, 255",
          "--border-rgb": "255, 199, 128",
          "--panel-border-rgb": "255, 190, 120",
          "--panel": "rgba(24, 14, 8, 0.88)",
          "--scanline": "rgba(30, 18, 10, 0.4)",
          "--input-bg": "#140c06",
          "--timeline-bg": "rgba(18, 11, 6, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(60, 32, 12, 0.9), rgba(90, 45, 16, 0.9))"
        }
      },
      {
        name: "Ice Blue",
        vars: {
          "--bg": "#07131c",
          "--bg-2": "#0b2433",
          "--bg-3": "#04070c",
          "--grid-rgb": "120, 200, 255",
          "--text": "#d8f4ff",
          "--muted": "#9ad5e8",
          "--muted-rgb": "154, 213, 232",
          "--glow": "#78d8ff",
          "--glow-rgb": "120, 216, 255",
          "--accent": "#ffb4d6",
          "--accent-rgb": "255, 180, 214",
          "--border-rgb": "130, 214, 255",
          "--panel-border-rgb": "120, 200, 240",
          "--panel": "rgba(8, 18, 26, 0.88)",
          "--scanline": "rgba(7, 20, 30, 0.35)",
          "--input-bg": "#061019",
          "--timeline-bg": "rgba(6, 14, 22, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(10, 40, 60, 0.9), rgba(12, 70, 96, 0.9))"
        }
      },
      {
        name: "Violet Flux",
        vars: {
          "--bg": "#11081e",
          "--bg-2": "#2a1240",
          "--bg-3": "#07050c",
          "--grid-rgb": "190, 140, 255",
          "--text": "#f1ddff",
          "--muted": "#c9a8e8",
          "--muted-rgb": "201, 168, 232",
          "--glow": "#d08bff",
          "--glow-rgb": "208, 139, 255",
          "--accent": "#5cffc8",
          "--accent-rgb": "92, 255, 200",
          "--border-rgb": "190, 150, 255",
          "--panel-border-rgb": "180, 140, 240",
          "--panel": "rgba(20, 10, 30, 0.88)",
          "--scanline": "rgba(20, 10, 30, 0.35)",
          "--input-bg": "#0d0614",
          "--timeline-bg": "rgba(12, 7, 18, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(38, 16, 70, 0.9), rgba(68, 28, 110, 0.9))"
        }
      },
      {
        name: "Crimson Night",
        vars: {
          "--bg": "#1a0a0c",
          "--bg-2": "#3a1216",
          "--bg-3": "#070304",
          "--grid-rgb": "255, 120, 120",
          "--text": "#ffe6e1",
          "--muted": "#f0b2a8",
          "--muted-rgb": "240, 178, 168",
          "--glow": "#ff6b6b",
          "--glow-rgb": "255, 107, 107",
          "--accent": "#ffd166",
          "--accent-rgb": "255, 209, 102",
          "--border-rgb": "255, 140, 140",
          "--panel-border-rgb": "255, 120, 120",
          "--panel": "rgba(24, 8, 10, 0.88)",
          "--scanline": "rgba(30, 10, 12, 0.4)",
          "--input-bg": "#140608",
          "--timeline-bg": "rgba(16, 7, 9, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(60, 16, 22, 0.9), rgba(96, 24, 32, 0.9))"
        }
      }
    ];

    function parseRgb(value, fallback) {
      if (!value) return fallback;
      if (value.trim().startsWith("rgba")) {
        const match = value.match(/rgba\\(([^)]+)\\)/i);
        if (match) value = match[1];
      }
      if (value.includes(",")) {
        const parts = value.split(",").map(part => parseFloat(part.trim()));
        if (parts.length >= 3 && parts.every(num => Number.isFinite(num))) {
          return [parts[0], parts[1], parts[2]];
        }
      }
      return fallback;
    }

    function parseHex(value, fallback) {
      if (!value) return fallback;
      const hex = value.trim().replace("#", "");
      if (hex.length === 6) {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        if ([r, g, b].every(num => Number.isFinite(num))) {
          return [r, g, b];
        }
      }
      return fallback;
    }

    function mixValue(a, b, t) {
      return a + (b - a) * t;
    }

    function mixRgb(a, b, t) {
      return [
        Math.round(mixValue(a[0], b[0], t)),
        Math.round(mixValue(a[1], b[1], t)),
        Math.round(mixValue(a[2], b[2], t))
      ];
    }

    function toRgbString(rgb) {
      return `${rgb[0]}, ${rgb[1]}, ${rgb[2]}`;
    }

    function toHex(rgb) {
      return `#${rgb.map(channel => Math.max(0, Math.min(255, channel)).toString(16).padStart(2, "0")).join("")}`;
    }

    function parseRgba(value, fallback) {
      const match = value.match(/rgba\\(([^)]+)\\)/i);
      if (!match) return fallback;
      const parts = match[1].split(",").map(part => part.trim());
      if (parts.length < 4) return fallback;
      const rgb = parseRgb(parts.slice(0, 3).join(","), fallback.rgb);
      const alpha = Number.parseFloat(parts[3]);
      return { rgb, alpha: Number.isFinite(alpha) ? alpha : fallback.alpha };
    }

    function mixRgba(a, b, t) {
      const rgb = mixRgb(a.rgb, b.rgb, t);
      const alpha = mixValue(a.alpha, b.alpha, t);
      return { rgb, alpha };
    }

    function toRgbaString(value) {
      return `rgba(${value.rgb[0]}, ${value.rgb[1]}, ${value.rgb[2]}, ${value.alpha.toFixed(2)})`;
    }

    function parseLinearGradient(value, fallback) {
      const match = value.match(/linear-gradient\\([^,]+,\\s*(rgba\\([^\\)]+\\))\\s*,\\s*(rgba\\([^\\)]+\\))\\s*\\)/i);
      if (!match) return fallback;
      return {
        start: parseRgba(match[1], fallback.start),
        end: parseRgba(match[2], fallback.end)
      };
    }

    function mixLinearGradient(a, b, t, angle) {
      const start = mixRgba(a.start, b.start, t);
      const end = mixRgba(a.end, b.end, t);
      return `linear-gradient(${angle}, ${toRgbaString(start)}, ${toRgbaString(end)})`;
    }

    function applyThemeMix(value) {
      if (!themes.length) return;
      const maxIndex = themes.length - 1;
      const clamped = Math.max(0, Math.min(maxIndex, value));
      const baseIndex = Math.floor(clamped);
      const nextIndex = Math.min(maxIndex, baseIndex + 1);
      const t = clamped - baseIndex;
      const base = themes[baseIndex].vars;
      const next = themes[nextIndex].vars;
      const root = document.documentElement;

      const bg = toHex(mixRgb(parseHex(base["--bg"], [10, 15, 12]), parseHex(next["--bg"], [10, 15, 12]), t));
      const bg2 = toHex(mixRgb(parseHex(base["--bg-2"], [15, 42, 30]), parseHex(next["--bg-2"], [15, 42, 30]), t));
      const bg3 = toHex(mixRgb(parseHex(base["--bg-3"], [5, 8, 6]), parseHex(next["--bg-3"], [5, 8, 6]), t));
      const text = toHex(mixRgb(parseHex(base["--text"], [201, 255, 231]), parseHex(next["--text"], [201, 255, 231]), t));
      const muted = toHex(mixRgb(parseHex(base["--muted"], [127, 230, 193]), parseHex(next["--muted"], [127, 230, 193]), t));
      const glow = toHex(mixRgb(parseHex(base["--glow"], [67, 255, 180]), parseHex(next["--glow"], [67, 255, 180]), t));
      const accent = toHex(mixRgb(parseHex(base["--accent"], [255, 184, 74]), parseHex(next["--accent"], [255, 184, 74]), t));
      const gridRgb = mixRgb(parseRgb(base["--grid-rgb"], [82, 255, 171]), parseRgb(next["--grid-rgb"], [82, 255, 171]), t);
      const mutedRgb = mixRgb(parseRgb(base["--muted-rgb"], [127, 230, 193]), parseRgb(next["--muted-rgb"], [127, 230, 193]), t);
      const glowRgb = mixRgb(parseRgb(base["--glow-rgb"], [67, 255, 180]), parseRgb(next["--glow-rgb"], [67, 255, 180]), t);
      const accentRgb = mixRgb(parseRgb(base["--accent-rgb"], [255, 184, 74]), parseRgb(next["--accent-rgb"], [255, 184, 74]), t);
      const borderRgb = mixRgb(parseRgb(base["--border-rgb"], [110, 255, 198]), parseRgb(next["--border-rgb"], [110, 255, 198]), t);
      const panelBorderRgb = mixRgb(parseRgb(base["--panel-border-rgb"], [103, 255, 190]), parseRgb(next["--panel-border-rgb"], [103, 255, 190]), t);

      const panel = toRgbaString(mixRgba(
        parseRgba(base["--panel"], { rgb: [7, 18, 14], alpha: 0.85 }),
        parseRgba(next["--panel"], { rgb: [7, 18, 14], alpha: 0.85 }),
        t
      ));
      const scanline = toRgbaString(mixRgba(
        parseRgba(base["--scanline"], { rgb: [10, 26, 20], alpha: 0.35 }),
        parseRgba(next["--scanline"], { rgb: [10, 26, 20], alpha: 0.35 }),
        t
      ));

      const inputBg = toHex(mixRgb(parseHex(base["--input-bg"], [4, 11, 8]), parseHex(next["--input-bg"], [4, 11, 8]), t));
      const timelineBg = toRgbaString(mixRgba(
        parseRgba(base["--timeline-bg"], { rgb: [4, 10, 8], alpha: 0.65 }),
        parseRgba(next["--timeline-bg"], { rgb: [4, 10, 8], alpha: 0.65 }),
        t
      ));
      const buttonBg = mixLinearGradient(
        parseLinearGradient(base["--button-bg"], {
          start: { rgb: [7, 32, 20], alpha: 0.9 },
          end: { rgb: [8, 64, 40], alpha: 0.9 }
        }),
        parseLinearGradient(next["--button-bg"], {
          start: { rgb: [7, 32, 20], alpha: 0.9 },
          end: { rgb: [8, 64, 40], alpha: 0.9 }
        }),
        t,
        "120deg"
      );

      root.style.setProperty("--bg", bg);
      root.style.setProperty("--bg-2", bg2);
      root.style.setProperty("--bg-3", bg3);
      root.style.setProperty("--text", text);
      root.style.setProperty("--muted", muted);
      root.style.setProperty("--glow", glow);
      root.style.setProperty("--accent", accent);
      root.style.setProperty("--grid-rgb", toRgbString(gridRgb));
      root.style.setProperty("--muted-rgb", toRgbString(mutedRgb));
      root.style.setProperty("--glow-rgb", toRgbString(glowRgb));
      root.style.setProperty("--accent-rgb", toRgbString(accentRgb));
      root.style.setProperty("--border-rgb", toRgbString(borderRgb));
      root.style.setProperty("--panel-border-rgb", toRgbString(panelBorderRgb));
      root.style.setProperty("--panel", panel);
      root.style.setProperty("--scanline", scanline);
      root.style.setProperty("--input-bg", inputBg);
      root.style.setProperty("--timeline-bg", timelineBg);
      root.style.setProperty("--button-bg", buttonBg);
      updateThemeColors();
    }

    let currentMidi = null;
    let midiBlobUrl = null;
    let currentChords = [];
    let currentBass = [];
    let chordTextTokens = [];
    let chordStarts = [];
    let chordClips = [];
    let bassClips = [];
    let activeBassClips = new Set();
    let currentChordIndex = -1;
    let currentFileName = "change.machine.mid";
    let currentBpm = 110;
    let currentBeatPx = 34;
    let bassAutoRegenerate = false;
    let bassSeedCounter = 0;
    let currentSeed = "";
    let seedIsRandom = false;
    let seedDrivesSettings = false;
    let seedManual = false;
    let isPlaying = false;
    let playTimers = [];
    let audioContext = null;
    let masterGain = null;
    let analyser = null;
    let oscData = null;
    let oscCtx = null;
    let oscAnimId = null;
    const activeOscillators = new Set();
    const DEFAULT_GAIN = 0.18;
    let midiAccess = null;
    let midiOutput = null;
    let midiEnabled = false;
    let midiInput = null;
    let preferredOutputId = null;
    let preferredInputId = null;
    let externalBpm = null;
    let lastClockTime = null;
    let clockSmoothing = null;
    const activeChordNotes = new Map();
    const activeBassNotes = new Map();
    let chordNoteCounter = 0;
    let songMode = false;
    let chordMuted = false;
    let bassMuted = false;

    function getMidiVelocity() {
      if (!midiVelocity) return 96;
      const value = Number(midiVelocity.value);
      if (Number.isNaN(value)) return 96;
      return Math.max(1, Math.min(127, value));
    }

    function getChordChannel() {
      if (!chordChannelSelect) return 0;
      const value = parseInt(chordChannelSelect.value, 10);
      if (Number.isNaN(value)) return 0;
      return Math.max(0, Math.min(15, value - 1));
    }

    function getBassChannel() {
      if (!bassChannelSelect) return 1;
      const value = parseInt(bassChannelSelect.value, 10);
      if (Number.isNaN(value)) return 1;
      return Math.max(0, Math.min(15, value - 1));
    }

    function ensureAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = midiEnabled ? 0 : DEFAULT_GAIN;
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.65;
        oscData = new Uint8Array(analyser.fftSize);
        masterGain.connect(analyser);
        analyser.connect(audioContext.destination);
        startOscilloscope();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
    }

    function handleMidiMessage(event) {
      const status = event.data[0];
      if (status === 0xF8) {
        const now = performance.now();
        if (lastClockTime) {
          const delta = now - lastClockTime;
          if (delta > 0) {
            const bpm = 60000 / (delta * 24);
            const clamped = Math.max(20, Math.min(300, bpm));
            clockSmoothing = clockSmoothing === null ? clamped : (clockSmoothing * 0.8 + clamped * 0.2);
            externalBpm = clockSmoothing;
            if (midiEnabled) {
              tempoInput.disabled = true;
              tempoReadout.textContent = `EXT ${externalBpm.toFixed(1)} BPM`;
            }
          }
        }
        lastClockTime = now;
      } else if (status === 0xFA || status === 0xFC) {
        lastClockTime = null;
        externalBpm = null;
        clockSmoothing = null;
        if (midiEnabled) {
          tempoInput.disabled = false;
          updateReadouts();
        }
      }
    }

    async function ensureMidi() {
      if (!midiEnabled) return;
      if (!navigator.requestMIDIAccess) {
        return;
      }
      if (!midiAccess) {
        try {
          midiAccess = await navigator.requestMIDIAccess({ sysex: false });
          midiAccess.onstatechange = () => {
            populateMidiOutputs();
          };
        } catch (err) {
          return;
        }
      }
      populateMidiOutputs();
    }

    function populateMidiOutputs() {
      const outputs = midiAccess ? Array.from(midiAccess.outputs.values()) : [];
      let selectedOut = preferredOutputId
        ? outputs.find(output => output.id === preferredOutputId)
        : null;
      if (!selectedOut) {
        selectedOut = outputs.find(output =>
          (output.name || "").toLowerCase().includes("logic pro virtual in")
        ) || outputs[0] || null;
      }
      midiOutput = selectedOut;
      if (midiOutput) {
        preferredOutputId = midiOutput.id;
      }

      const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];
      let selectedIn = preferredInputId
        ? inputs.find(input => input.id === preferredInputId)
        : null;
      if (!selectedIn) {
        selectedIn = inputs.find(input =>
          (input.name || "").toLowerCase().includes("logic pro virtual out")
        ) || inputs[0] || null;
      }
      if (midiInput && midiInput !== selectedIn) {
        midiInput.onmidimessage = null;
      }
      midiInput = selectedIn || null;
      if (midiInput) {
        preferredInputId = midiInput.id;
      }
      if (midiInput) {
        midiInput.onmidimessage = handleMidiMessage;
      }
      refreshMidiRouteOptions();
    }

    function sendChordNoteOn(note, velocity = 96) {
      if (!midiEnabled || !midiOutput) return;
      const channel = getChordChannel();
      const id = chordNoteCounter + 1;
      chordNoteCounter = id;
      midiOutput.send([0x90 + channel, note, velocity]);
      activeChordNotes.set(note, { channel, id });
      return id;
    }

    function sendChordNoteOff(note, noteId = null) {
      if (!midiEnabled || !midiOutput) return;
      const entry = activeChordNotes.get(note);
      if (noteId !== null && (!entry || entry.id !== noteId)) return;
      const resolved = entry && entry.channel !== undefined ? entry.channel : getChordChannel();
      midiOutput.send([0x80 + resolved, note, 0]);
      activeChordNotes.delete(note);
    }

    function sendBassNoteOn(note, velocity = 96) {
      if (!midiEnabled || !midiOutput) return;
      const channel = getBassChannel();
      midiOutput.send([0x90 + channel, note, velocity]);
      activeBassNotes.set(note, channel);
    }

    function sendBassNoteOff(note) {
      if (!midiEnabled || !midiOutput) return;
      const channel = activeBassNotes.get(note);
      const resolved = channel === undefined ? getBassChannel() : channel;
      midiOutput.send([0x80 + resolved, note, 0]);
      activeBassNotes.delete(note);
    }

    function sendChordPanic() {
      if (!midiEnabled || !midiOutput) {
        activeChordNotes.clear();
        return;
      }
      const channel = getChordChannel();
      activeChordNotes.forEach((entry, note) => {
        const resolved = entry && entry.channel !== undefined ? entry.channel : channel;
        midiOutput.send([0x80 + resolved, note, 0]);
      });
      midiOutput.send([0xB0 + channel, 64, 0]);
      midiOutput.send([0xB0 + channel, 123, 0]);
      midiOutput.send([0xB0 + channel, 120, 0]);
      activeChordNotes.clear();
    }

    function sendAllNotesOff() {
      if (!midiEnabled || !midiOutput) {
        activeChordNotes.clear();
        activeBassNotes.clear();
        return;
      }
      const channels = new Set();
      activeChordNotes.forEach((entry, note) => {
        const resolved = entry && entry.channel !== undefined ? entry.channel : getChordChannel();
        midiOutput.send([0x80 + resolved, note, 0]);
        channels.add(resolved);
      });
      activeBassNotes.forEach((channel, note) => {
        midiOutput.send([0x80 + channel, note, 0]);
        channels.add(channel);
      });
      channels.add(getChordChannel());
      channels.add(getBassChannel());
      channels.forEach(channel => {
        midiOutput.send([0xB0 + channel, 64, 0]);
        midiOutput.send([0xB0 + channel, 123, 0]);
        midiOutput.send([0xB0 + channel, 120, 0]);
      });
      activeChordNotes.clear();
      activeBassNotes.clear();
    }


    function scheduleMidiChord(notes, startMs, durationMs) {
      if (!midiOutput || chordMuted) return;
      const onId = setTimeout(() => {
        sendChordPanic();
        const velocity = getMidiVelocity();
        const noteIds = new Map();
        notes.forEach(note => {
          const id = sendChordNoteOn(note, velocity);
          noteIds.set(note, id);
        });
        const offId = setTimeout(() => {
          notes.forEach(note => sendChordNoteOff(note, noteIds.get(note) ?? null));
        }, Math.max(0, durationMs));
        playTimers.push(offId);
      }, Math.max(0, startMs));
      playTimers.push(onId);
    }

    function scheduleMidiBass(note, startMs, durationMs) {
      if (!midiOutput || bassMuted) return;
      const onId = setTimeout(() => {
        const velocity = Math.max(1, Math.round(getMidiVelocity() * 0.85));
        sendBassNoteOn(note, velocity);
      }, Math.max(0, startMs));
      const offId = setTimeout(() => {
        sendBassNoteOff(note);
      }, Math.max(0, startMs + durationMs));
      playTimers.push(onId, offId);
    }

    function refreshMidiRouteOptions() {
      if (!midiOutSelect || !midiInSelect) return;
      const outputs = midiAccess ? Array.from(midiAccess.outputs.values()) : [];
      const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];

      midiOutSelect.innerHTML = "";
      if (!outputs.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "No MIDI outputs";
        midiOutSelect.appendChild(option);
        midiOutSelect.disabled = true;
      } else {
        outputs.forEach(output => {
          const option = document.createElement("option");
          option.value = output.id;
          option.textContent = output.name || output.id;
          if (midiOutput && output.id === midiOutput.id) {
            option.selected = true;
          }
          midiOutSelect.appendChild(option);
        });
        midiOutSelect.disabled = false;
      }

      midiInSelect.innerHTML = "";
      if (!inputs.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "No MIDI inputs";
        midiInSelect.appendChild(option);
        midiInSelect.disabled = true;
      } else {
        inputs.forEach(input => {
          const option = document.createElement("option");
          option.value = input.id;
          option.textContent = input.name || input.id;
          if (midiInput && input.id === midiInput.id) {
            option.selected = true;
          }
          midiInSelect.appendChild(option);
        });
        midiInSelect.disabled = false;
      }
    }

    function resizeOscilloscope() {
      if (!oscilloscope) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = oscilloscope.getBoundingClientRect();
      oscilloscope.width = Math.max(1, Math.floor(rect.width * dpr));
      oscilloscope.height = Math.max(1, Math.floor(rect.height * dpr));
      oscCtx = oscilloscope.getContext("2d");
      oscCtx.setTransform(1, 0, 0, 1, 0, 0);
      oscCtx.scale(dpr, dpr);
    }

    function startOscilloscope() {
      if (!oscilloscope || !analyser) return;
      resizeOscilloscope();
      if (oscAnimId) cancelAnimationFrame(oscAnimId);

      const draw = () => {
        oscAnimId = requestAnimationFrame(draw);
        if (!oscCtx) return;
        const width = oscilloscope.clientWidth;
        const height = oscilloscope.clientHeight;
        oscCtx.clearRect(0, 0, width, height);
        oscCtx.fillStyle = oscFillColor;
        oscCtx.fillRect(0, 0, width, height);

        analyser.getByteTimeDomainData(oscData);
        oscCtx.lineWidth = 2.4;
        oscCtx.strokeStyle = oscStrokeColor;
        oscCtx.shadowBlur = 12;
        oscCtx.shadowColor = oscShadowColor;
        oscCtx.beginPath();

        const sliceWidth = width / (oscData.length - 1);
        let x = 0;
        for (let i = 0; i < oscData.length; i++) {
          const v = oscData[i] / 128.0;
          const centered = (v - 1) * 1.35;
          const y = height / 2 + centered * (height / 2);
          if (i === 0) {
            oscCtx.moveTo(x, y);
          } else {
            oscCtx.lineTo(x, y);
          }
          x += sliceWidth;
        }
        oscCtx.lineTo(width, height / 2);
        oscCtx.stroke();

        oscCtx.shadowBlur = 0;
        oscCtx.strokeStyle = oscMidColor;
        oscCtx.beginPath();
        oscCtx.moveTo(0, height / 2);
        oscCtx.lineTo(width, height / 2);
        oscCtx.stroke();
      };

      draw();
    }

    function midiToFreq(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }

    function playChordAtTime(notes, startTime, durationSec) {
      if (chordMuted) return;
      const attack = 0.02;
      const release = Math.max(0.05, durationSec * 0.35);
      notes.forEach(note => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "sine";
        osc.frequency.value = midiToFreq(note);
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.18, startTime + attack);
        gain.gain.linearRampToValueAtTime(0.0001, Math.max(startTime + attack + 0.01, startTime + durationSec - release));
        gain.gain.linearRampToValueAtTime(0, startTime + durationSec);
        osc.connect(gain);
        gain.connect(masterGain);
        activeOscillators.add(osc);
        osc.onended = () => {
          activeOscillators.delete(osc);
        };
        osc.start(startTime);
        osc.stop(startTime + durationSec + 0.02);
      });
    }

    function playBassNoteAtTime(note, startTime, durationSec) {
      if (bassMuted) return;
      const attack = 0.01;
      const release = Math.max(0.08, durationSec * 0.4);
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = "triangle";
      osc.frequency.value = midiToFreq(note);
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(0.12, startTime + attack);
      gain.gain.linearRampToValueAtTime(0.0001, Math.max(startTime + attack + 0.01, startTime + durationSec - release));
      gain.gain.linearRampToValueAtTime(0, startTime + durationSec);
      osc.connect(gain);
      gain.connect(masterGain);
      activeOscillators.add(osc);
      osc.onended = () => {
        activeOscillators.delete(osc);
      };
      osc.start(startTime);
      osc.stop(startTime + durationSec + 0.03);
    }

    function clearTimers() {
      playTimers.forEach(id => clearTimeout(id));
      playTimers = [];
    }

    function setActiveChord(index) {
      if (currentChordIndex >= 0 && chordClips[currentChordIndex]) {
        chordClips[currentChordIndex].classList.remove("active");
      }
      currentChordIndex = index;
      if (currentChordIndex >= 0 && chordClips[currentChordIndex]) {
        const clip = chordClips[currentChordIndex];
        clip.classList.add("active");
        const clipLeft = clip.offsetLeft;
        const clipRight = clipLeft + clip.offsetWidth;
        const viewLeft = timelineView.scrollLeft;
        const viewRight = viewLeft + timelineView.clientWidth;
        const targetLeft = Math.max(clipLeft - 16, 0);
        if (clipRight > viewRight || clipLeft < viewLeft) {
          timelineView.scrollLeft = targetLeft;
        }
        timelineScroll.value = String(timelineView.scrollLeft);
      }
      renderProgressionHighlight(currentChordIndex);
    }

    function scrollTimelineToBeat(beat) {
      if (!timelineView) return;
      const targetLeft = Math.max(beat * currentBeatPx - 16, 0);
      timelineView.scrollLeft = targetLeft;
      timelineScroll.value = String(timelineView.scrollLeft);
    }

    function findChordIndexAtBeat(beat) {
      if (!chordStarts.length) return 0;
      for (let i = chordStarts.length - 1; i >= 0; i--) {
        if (beat >= chordStarts[i] - 1e-6) return i;
      }
      return 0;
    }

    function clearBassHighlights() {
      if (!bassClips.length) return;
      bassClips.forEach(item => {
        if (item && item.el) {
          item.el.classList.remove("active");
        }
      });
      activeBassClips.clear();
    }

    function setBassClipActive(index, active) {
      const item = bassClips[index];
      if (!item || !item.el) return;
      if (active) {
        item.el.classList.add("active");
        activeBassClips.add(index);
      } else {
        item.el.classList.remove("active");
        activeBassClips.delete(index);
      }
    }

    function auditionChordByIndex(index) {
      if (!currentChords.length || !currentChords[index]) return;
      stopPlayback();
      setActiveChord(index);
      scrollTimelineToBeat(chordStarts[index] || 0);
      ensureAudio();
      restoreMasterGain();
      ensureMidi();
      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      const chord = currentChords[index];
      if (!chordMuted) {
        playChordAtTime(chord.notes, audioContext.currentTime, chord.duration * beatSec);
      }
      if (midiEnabled && !chordMuted) {
        sendChordPanic();
        const velocity = getMidiVelocity();
        chord.notes.forEach(note => sendChordNoteOn(note, velocity));
        const offId = setTimeout(() => {
          chord.notes.forEach(note => sendChordNoteOff(note));
        }, chord.duration * beatSec * 1000);
        playTimers.push(offId);
      }
    }

    function auditionBassNote(note, duration, startBeat, clipIndex) {
      if (!currentChords.length) return;
      stopPlayback();
      const chordIndex = findChordIndexAtBeat(startBeat);
      setActiveChord(chordIndex);
      clearBassHighlights();
      if (clipIndex !== null && clipIndex !== undefined) {
        setBassClipActive(clipIndex, true);
      }
      ensureAudio();
      restoreMasterGain();
      ensureMidi();
      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      if (!bassMuted) {
        playBassNoteAtTime(note, audioContext.currentTime, duration * beatSec);
      }
      if (midiEnabled && !bassMuted) {
        const velocity = Math.max(1, Math.round(getMidiVelocity() * 0.85));
        sendBassNoteOn(note, velocity);
        const offId = setTimeout(() => {
          sendBassNoteOff(note);
          if (clipIndex !== null && clipIndex !== undefined) {
            setBassClipActive(clipIndex, false);
          }
        }, duration * beatSec * 1000);
        playTimers.push(offId);
      }
      scrollTimelineToBeat(startBeat);
    }

    function stopPlayback() {
      clearTimers();
      clearBassHighlights();
      if (!isPlaying) {
        sendAllNotesOff();
        return;
      }
      isPlaying = false;
      playButton.textContent = "Play";
      if (audioContext && masterGain) {
        const now = audioContext.currentTime;
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setTargetAtTime(0, now, 0.015);
      }
      activeOscillators.forEach(osc => {
        try {
          osc.stop();
        } catch (err) {
          // Ignore if already stopped.
        }
      });
      activeOscillators.clear();
      sendAllNotesOff();
    }

    function restoreMasterGain() {
      if (audioContext && masterGain) {
        masterGain.gain.cancelScheduledValues(audioContext.currentTime);
        masterGain.gain.setValueAtTime(midiEnabled ? 0 : DEFAULT_GAIN, audioContext.currentTime);
      }
    }

    function startPlayback(startIndex) {
      if (!currentChords.length) return;
      ensureAudio();
      ensureMidi();
      isPlaying = true;
      playButton.textContent = "Stop";
      clearTimers();

      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      const safeStart = ((startIndex % currentChords.length) + currentChords.length) % currentChords.length;
      let cursor = 0;
      const startBeat = chordStarts[safeStart] || 0;

      setActiveChord(safeStart);
      clearBassHighlights();
      restoreMasterGain();
      if (midiEnabled) {
        ensureMidi();
      }

      const baseMs = performance.now();
      for (let i = safeStart; i < currentChords.length; i++) {
        const chord = currentChords[i];
        const startTime = audioContext.currentTime + cursor * beatSec;
        playChordAtTime(chord.notes, startTime, chord.duration * beatSec);
        if (midiEnabled) {
          scheduleMidiChord(chord.notes, (baseMs + cursor * beatSec * 1000) - performance.now(), chord.duration * beatSec * 1000);
        }
        const timerId = setTimeout(() => {
          setActiveChord(i);
        }, Math.max(0, cursor * beatSec * 1000));
        playTimers.push(timerId);
        cursor += chord.duration;
      }

      if (currentBass.length) {
        const baseMs = performance.now();
        currentBass.forEach((note, index) => {
          if (note.startBeat < startBeat) return;
          const offsetBeat = note.startBeat - startBeat;
          const startTime = audioContext.currentTime + offsetBeat * beatSec;
          playBassNoteAtTime(note.note, startTime, note.duration * beatSec);
          if (midiEnabled) {
            scheduleMidiBass(note.note, (baseMs + offsetBeat * beatSec * 1000) - performance.now(), note.duration * beatSec * 1000);
          }
          const onId = setTimeout(() => {
            setBassClipActive(index, true);
          }, Math.max(0, offsetBeat * beatSec * 1000));
          const offId = setTimeout(() => {
            setBassClipActive(index, false);
          }, Math.max(0, offsetBeat * beatSec * 1000 + note.duration * beatSec * 1000));
          playTimers.push(onId, offId);
        });
      }

      const endTimer = setTimeout(() => {
        if (!isPlaying) return;
        startPlayback(0);
      }, cursor * beatSec * 1000 + 50);
      playTimers.push(endTimer);
    }

    function updateReadouts() {
      barsReadout.textContent = `${barsInput.value} bars`;
      densityReadout.textContent = `${densityInput.value}%`;
      colorReadout.textContent = `${colorInput.value}%`;
      modulationReadout.textContent = `${modulationInput.value}%`;
      subdivisionDensityReadout.textContent = `${subdivisionDensityInput.value}%`;
      if (bassDensityReadout && bassDensityInput) {
        bassDensityReadout.textContent = `${bassDensityInput.value}%`;
      }
      if (bassMovementReadout && bassMovementInput) {
        bassMovementReadout.textContent = `${bassMovementInput.value}%`;
      }
      if (bassColorReadout && bassColorInput) {
        bassColorReadout.textContent = `${bassColorInput.value}%`;
      }
      if (bassFillsReadout && bassFillsInput) {
        bassFillsReadout.textContent = `${bassFillsInput.value}%`;
      }
      if (bassSubdivisionDensityReadout && bassSubdivisionDensityInput) {
        bassSubdivisionDensityReadout.textContent = `${bassSubdivisionDensityInput.value}%`;
      }
      if (bassRegisterReadout && bassRegisterInput) {
        bassRegisterReadout.textContent = noteLabelFromMidi(parseInt(bassRegisterInput.value, 10) || 36);
      }
      if (midiEnabled) {
        tempoReadout.textContent = externalBpm
          ? `EXT ${externalBpm.toFixed(1)} BPM`
          : `INT ${tempoInput.value} BPM`;
      } else {
        tempoReadout.textContent = `${tempoInput.value} BPM`;
      }
    }

    function getPlaybackBpm() {
      if (midiEnabled && externalBpm) {
        return externalBpm;
      }
      return Math.max(60, Math.min(200, parseInt(tempoInput.value, 10) || 110));
    }

    function render() {
      stopPlayback();
      const previousSeed = currentSeed;
      const seedRaw = seedInput.value.trim() || `$eed-${Date.now()}`;
      const seedLabel = seedRaw;
      if (seedDrivesSettings) {
        applySeedSettings(seedLabel);
      }
      updateReadouts();
      const bars = parseInt(barsInput.value, 10);
      const densityPercent = Math.max(0, Math.min(100, parseInt(densityInput.value, 10) || 0));
      const colorPercent = Math.max(0, Math.min(100, parseInt(colorInput.value, 10) || 0));
      const modulationPercent = Math.max(0, Math.min(100, parseInt(modulationInput.value, 10) || 0));
      const subdivision = subdivisionInput.value;
      const subdivisionDensity = Math.max(0, Math.min(100, parseInt(subdivisionDensityInput.value, 10) || 0)) / 100;
      const bpm = getPlaybackBpm();
      currentBpm = bpm;
      const genre = genreSub ? genreSub.value : "base";
      const genreLabel = (genreMain && genreSub && genreCatalog[genreMain.value] && genreCatalog[genreMain.value].sub[genreSub.value])
        ? genreCatalog[genreMain.value].sub[genreSub.value]
        : genre;
      const keyChoice = keySelect.value;
      let key = keyChoice;
      let keyLabel = keyChoice;
      if (keyChoice === "random") {
        const keyRng = makeRng(`${seedLabel}-key`);
        key = noteNames[Math.floor(keyRng() * noteNames.length)];
        keyLabel = `random → ${key}`;
      }

      const chords = generateProgression({ bars, key, densityPercent, seed: seedLabel, subdivision, subdivisionDensity, genre, modulationPercent, colorPercent });
      if (previousSeed && previousSeed !== seedLabel) {
        bassSeedCounter = 0;
      }
      currentChords = chords;
      if (bassAutoRegenerate) {
        const bassSeed = getBassSeedLabel(seedLabel, false);
        currentBass = generateBassLine({
          chords,
          seed: bassSeed,
          densityPercent: parseInt(bassDensityInput?.value, 10) || 0,
          movementPercent: parseInt(bassMovementInput?.value, 10) || 0,
          fillPercent: parseInt(bassFillsInput?.value, 10) || 0,
          colorPercent: parseInt(bassColorInput?.value, 10) || 0,
          subdivisionDensity: parseInt(bassSubdivisionDensityInput?.value, 10) || 0,
          subdivisionMode: bassSubdivisionInput?.value || "even",
          style: bassStyleInput?.value || "auto",
          register: parseInt(bassRegisterInput?.value, 10) || 36,
          genre,
          mainGenre: genreMain?.value || ""
        });
      } else {
        currentBass = [];
      }
      currentSeed = seedLabel;
      if (seedInput) {
        seedInput.value = seedLabel;
      }
      currentFileName = `${sanitizeFileName(seedLabel)}.mid`;
      rebuildMidi();

      ruler.innerHTML = "";
      track.innerHTML = "";
      timelineView.scrollLeft = 0;

      const totalBeats = chords.reduce((sum, chord) => sum + chord.duration, 0);
      const beatPx = 34;
      currentBeatPx = beatPx;
      const totalWidth = Math.max(Math.round(totalBeats * beatPx), timelineView.clientWidth - 2) + 16;
      timelineView.style.setProperty("--beat-px", `${beatPx}px`);
      timelineView.style.setProperty("--bar-px", `${beatPx * 4}px`);
      ruler.style.width = `${totalWidth}px`;
      track.style.width = `${totalWidth}px`;
      if (bassTrack) {
        bassTrack.style.width = `${totalWidth}px`;
      }
      const maxScroll = Math.max(0, timelineView.scrollWidth - timelineView.clientWidth);
      timelineScroll.max = String(maxScroll);
      timelineScroll.value = "0";

      for (let bar = 0; bar < bars; bar++) {
        const label = document.createElement("div");
        label.className = "bar-label";
        label.style.left = `${bar * 4 * beatPx + 6}px`;
        label.textContent = `Bar ${bar + 1}`;
        ruler.appendChild(label);
      }

      let beatCursor = 0;
      chordStarts = [];
      chordClips = [];
      bassClips = [];
      currentChordIndex = -1;

      chords.forEach((chord, index) => {
        const clip = document.createElement("div");
        clip.className = "clip";
        clip.style.left = `${beatCursor * beatPx}px`;
        clip.style.width = `${Math.max(beatPx * 0.6, chord.duration * beatPx)}px`;
        clip.innerHTML = `<div class="clip-title">${chord.name}</div>`;
        clip.addEventListener("click", (event) => {
          event.preventDefault();
          auditionChordByIndex(index);
        });
        track.appendChild(clip);
        chordStarts.push(beatCursor);
        chordClips.push(clip);
        beatCursor += chord.duration;
      });

      renderBassTrack();

      chordTextTokens = buildProgressionTokens(chords);
      progressionText.value = formatProgressionTextFromTokens(chordTextTokens);
      renderProgressionHighlight(currentChordIndex);
      const subdivisionLabel = subdivision === "mixed" ? "even+triplet" : "even";
      const seedDisplay = seedLabel.startsWith("$eed") ? seedLabel : `$eed ${seedLabel}`;
      footer.textContent = `Key ${keyLabel} | ${bars} bars | ${bpm} BPM | ${genreLabel} | density ${densityPercent}% | color ${colorPercent}% | mod ${modulationPercent}% | ${subdivisionLabel} | subdiv ${Math.round(subdivisionDensity * 100)}% | ${seedDisplay}`;
    }

    function applyRandomSeedIfNeeded() {
      if (seedIsRandom) {
        const rand = Math.random().toString(36).slice(2, 8);
        seedInput.value = `$eed-${rand}`;
        return;
      }
      if (!seedManual) {
        const rand = Math.random().toString(36).slice(2, 8);
        seedInput.value = `$eed-${rand}`;
      }
    }

    function randomizeBassControls() {
      if (bassDensityInput) bassDensityInput.value = String(Math.floor(Math.random() * 101));
      if (bassMovementInput) bassMovementInput.value = String(Math.floor(Math.random() * 101));
      if (bassColorInput) bassColorInput.value = String(Math.floor(Math.random() * 101));
      if (bassFillsInput) bassFillsInput.value = String(Math.floor(Math.random() * 101));
      if (bassSubdivisionDensityInput) bassSubdivisionDensityInput.value = String(Math.floor(Math.random() * 101));
      if (bassSubdivisionInput) bassSubdivisionInput.value = Math.random() < 0.5 ? "even" : "mixed";
      if (bassStyleInput) {
        const styles = Array.from(bassStyleInput.options).map(option => option.value);
        bassStyleInput.value = styles[Math.floor(Math.random() * styles.length)] || "auto";
      }
      if (bassRegisterInput) {
        const min = parseInt(bassRegisterInput.min, 10) || 28;
        const max = parseInt(bassRegisterInput.max, 10) || 52;
        bassRegisterInput.value = String(min + Math.floor(Math.random() * (max - min + 1)));
      }
      updateReadouts();
      bassAutoRegenerate = true;
      regenerateBass(true);
    }

    document.getElementById("generate").addEventListener("click", () => {
      applyRandomSeedIfNeeded();
      render();
    });

    document.getElementById("download").addEventListener("click", () => {
      if (!currentMidi) return;
      if (!midiBlobUrl) return;
      const url = midiBlobUrl;
      const a = document.createElement("a");
      a.href = url;
      a.download = currentFileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    copyProgression.addEventListener("click", async () => {
      const text = progressionText.value.trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        copyProgression.textContent = "Copied";
        setTimeout(() => {
          copyProgression.textContent = "Copy progression";
        }, 1200);
      } catch (err) {
        progressionText.focus();
        progressionText.select();
        document.execCommand("copy");
      }
    });

    importSeed.addEventListener("click", () => {
      const trimmed = seedInput.value.trim();
      if (!trimmed) return;
      seedIsRandom = false;
      seedDrivesSettings = true;
      seedManual = false;
      render();
      seedDrivesSettings = false;
    });

    seedInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        if (seedInput.value.trim()) {
          seedIsRandom = false;
          seedDrivesSettings = true;
          seedManual = false;
          render();
          seedDrivesSettings = false;
        }
      }
    });

    seedInput.addEventListener("input", () => {
      seedIsRandom = false;
      seedDrivesSettings = true;
      seedManual = seedInput.value.trim().length > 0;
    });

    copySeed.addEventListener("click", async () => {
      const seedValue = (seedInput.value.trim() || currentSeed || "").trim();
      if (!seedValue) return;
      try {
        await navigator.clipboard.writeText(seedValue);
        copySeed.textContent = "Copied";
        setTimeout(() => {
          copySeed.textContent = "Copy $eed";
        }, 1200);
      } catch (err) {
        seedInput.focus();
        seedInput.select();
        document.execCommand("copy");
      }
    });

    randomSeed.addEventListener("click", () => {
      const rand = Math.random().toString(36).slice(2, 8);
      seedInput.value = `$eed-${rand}`;
      seedIsRandom = true;
      seedDrivesSettings = true;
      seedManual = false;
      render();
      seedDrivesSettings = false;
    });

    if (bassGenerate) {
      bassGenerate.addEventListener("click", () => {
        regenerateBass(true);
      });
    }

    const helpContent = [
      "SYSTEM: Generates chord progressions and exports MIDI blocks.",
      "",
      "CONTROLS",
      "- Key center: Choose a root or random.",
      "- Genre + Subgenre: Pick a main style and a specific variant.",
      "- Tempo: BPM for playback and MIDI.",
      "- MIDI out: WebMIDI in Chrome, defaults to Logic Pro Virtual In/Out, follows external clock when detected.",
      "- MIDI velocity: Sets chord + bass velocity while MIDI Out is on.",
      "- Bars: Length of the progression.",
      "- Harmonic density (%): How busy the harmony feels.",
      "- Color (%): How extended the chord voicings are (higher = more extensions).",
      "- Theme: Use the bottom slider to shift the overall palette.",
      "- Modulation amount (%): Likelihood of key shifts.",
      "- Subdivision density (%): How often bars subdivide.",
      "- Subdivision mode: Even only or even + triplet feel.",
      "- Bass controls ($ong): Density, movement, fills, subdivision, style, register, and channel.",
      "- Bass fills (%): Scale-based fill notes (0% none, 100% every chord).",
      "- Mute icons: Toggle chord/bass audio + MIDI.",
      "- $eed: Paste any text to make a repeatable progression, or share creative $eeds with others.",
      "",
      "BUTTONS",
      "- ¢hords: Generate a new progression.",
      "- Play: Listen with a sine synth (loops).",
      "- Download .mid: Save the MIDI file.",
      "- MIDI Out: Enable WebMIDI output (Chrome).",
      "- Import $eed: Load the current $eed value.",
      "- Copy $eed: Copy the current $eed.",
      "- Random $eed: Randomizes $eed and settings.",
      "- Copy progression: Copy chord text.",
      "- ฿ass: Generate a bass line in $ong mode.",
      "",
      "HOTKEYS",
      "- Space: Play/Stop (global).",
      "- Left/Right: Step through chords.",
      "- C: ¢hords (new progression).",
      "- R: Random $eed.",
      "- Enter (in $eed): Import $eed.",
      "",
      "UNDER CONSTRUCTION",
      "- Expanded MIDI I/O options.",
      "- More themes."
    ].join("\n");

    let helpTypeTimer = null;

    function typeHelpText() {
      if (!helpText) return;
      helpText.textContent = "";
      if (helpTypeTimer) clearInterval(helpTypeTimer);
      let index = 0;
      helpTypeTimer = setInterval(() => {
        helpText.textContent = helpContent.slice(0, index);
        index += 1;
        if (index > helpContent.length) {
          clearInterval(helpTypeTimer);
          helpTypeTimer = null;
        }
      }, 2);
    }

    function openHelp() {
      helpModal.classList.add("active");
      helpModal.setAttribute("aria-hidden", "false");
      typeHelpText();
    }

    function closeHelp() {
      helpModal.classList.remove("active");
      helpModal.setAttribute("aria-hidden", "true");
      if (helpTypeTimer) {
        clearInterval(helpTypeTimer);
        helpTypeTimer = null;
      }
    }

    function openRouteModal() {
      if (!routeModal) return;
      routeModal.classList.add("active");
      routeModal.setAttribute("aria-hidden", "false");
      refreshMidiRouteOptions();
    }

    function closeRouteModal() {
      if (!routeModal) return;
      routeModal.classList.remove("active");
      routeModal.setAttribute("aria-hidden", "true");
    }

    function setPanelCollapsed(panel, button) {
      if (!panel || !button) return;
      panel.classList.toggle("collapsed");
      button.textContent = panel.classList.contains("collapsed") ? "▸" : "▾";
    }

    function updateMuteButton(button, muted) {
      if (!button) return;
      button.setAttribute("aria-pressed", muted ? "true" : "false");
      button.textContent = "M";
    }

    function setSongMode(active) {
      songMode = active;
      document.body.classList.toggle("song-mode", songMode);
      if (songToggle) {
        songToggle.textContent = songMode ? "¢hange" : "$ong";
      }
      if (titleLeft && titleRight) {
        titleLeft.textContent = songMode ? "$ong" : "¢hange";
        titleRight.textContent = songMode ? "Machine" : "machine";
      }
      if (songMode) {
        if (themeSlider) {
          themeSlider.value = String(200);
          applyThemeMix(2);
        }
        if (!currentChords.length) {
          render();
        }
        bassAutoRegenerate = true;
        regenerateBass(true);
      } else if (themeSlider) {
        themeSlider.value = "0";
        applyThemeMix(0);
      }
    }

    helpButton.addEventListener("click", openHelp);
    helpClose.addEventListener("click", closeHelp);
    helpModal.addEventListener("click", (event) => {
      if (event.target === helpModal) {
        closeHelp();
      }
    });


    playButton.addEventListener("click", () => {
      if (isPlaying) {
        stopPlayback();
        return;
      }
      const startIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
      startPlayback(startIndex);
    });

    document.addEventListener("keydown", (event) => {
      const tag = (event.target && event.target.tagName) ? event.target.tagName.toLowerCase() : "";
      if (!currentChords.length) return;
      const isCtrl = event.ctrlKey || event.metaKey;
      if (event.key === "Escape" && helpModal.classList.contains("active")) {
        event.preventDefault();
        closeHelp();
      } else if (event.key === "Escape" && routeModal && routeModal.classList.contains("active")) {
        event.preventDefault();
        closeRouteModal();
      } else if ((event.key === "c" || event.key === "C") && !isCtrl) {
        if (event.target === seedInput) return;
        event.preventDefault();
        applyRandomSeedIfNeeded();
        render();
        return;
      } else if ((event.key === "r" || event.key === "R") && !isCtrl) {
        if (event.target === seedInput) return;
        event.preventDefault();
        randomSeed.click();
        return;
      } else if ((event.key === "b" || event.key === "B") && !isCtrl) {
        if (event.target === seedInput) return;
        if (!bassGenerate) return;
        event.preventDefault();
        bassGenerate.click();
        return;
      } else if (event.key === " ") {
        event.preventDefault();
        if (isPlaying) {
          stopPlayback();
        } else {
          const startIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
          startPlayback(startIndex);
        }
      } else if (event.key === "ArrowRight") {
        if (tag === "input" || tag === "textarea" || tag === "select") return;
        event.preventDefault();
        stopPlayback();
        const nextIndex = (currentChordIndex + 1) % currentChords.length;
        setActiveChord(nextIndex);
        ensureAudio();
        restoreMasterGain();
        ensureMidi();
        const bpm = getPlaybackBpm();
        const beatSec = 60 / bpm;
        if (!chordMuted) {
          playChordAtTime(currentChords[nextIndex].notes, audioContext.currentTime, currentChords[nextIndex].duration * beatSec);
        }
        if (midiEnabled && !chordMuted) {
          const velocity = getMidiVelocity();
          currentChords[nextIndex].notes.forEach(note => sendChordNoteOn(note, velocity));
          const offId = setTimeout(() => {
            currentChords[nextIndex].notes.forEach(note => sendChordNoteOff(note));
          }, currentChords[nextIndex].duration * beatSec * 1000);
          playTimers.push(offId);
        }
      } else if (event.key === "ArrowLeft") {
        if (tag === "input" || tag === "textarea" || tag === "select") return;
        event.preventDefault();
        stopPlayback();
        const prevIndex = Math.max(0, currentChordIndex === -1 ? 0 : currentChordIndex - 1);
        setActiveChord(prevIndex);
        ensureAudio();
        restoreMasterGain();
        ensureMidi();
        const bpm = getPlaybackBpm();
        const beatSec = 60 / bpm;
        if (!chordMuted) {
          playChordAtTime(currentChords[prevIndex].notes, audioContext.currentTime, currentChords[prevIndex].duration * beatSec);
        }
        if (midiEnabled && !chordMuted) {
          const velocity = getMidiVelocity();
          currentChords[prevIndex].notes.forEach(note => sendChordNoteOn(note, velocity));
          const offId = setTimeout(() => {
            currentChords[prevIndex].notes.forEach(note => sendChordNoteOff(note));
          }, currentChords[prevIndex].duration * beatSec * 1000);
          playTimers.push(offId);
        }
      }
    });

    barsInput.addEventListener("input", () => {
      seedDrivesSettings = false;
      updateReadouts();
    });
    densityInput.addEventListener("input", () => {
      seedDrivesSettings = false;
      updateReadouts();
    });
    colorInput.addEventListener("input", () => {
      seedDrivesSettings = false;
      updateReadouts();
      render();
    });
    modulationInput.addEventListener("input", () => {
      seedDrivesSettings = false;
      updateReadouts();
    });
    subdivisionDensityInput.addEventListener("input", () => {
      seedDrivesSettings = false;
      updateReadouts();
    });
    if (bassDensityInput) {
      bassDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassMovementInput) {
      bassMovementInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassColorInput) {
      bassColorInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassFillsInput) {
      bassFillsInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassSubdivisionDensityInput) {
      bassSubdivisionDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassSubdivisionInput) {
      bassSubdivisionInput.addEventListener("change", () => {
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassStyleInput) {
      bassStyleInput.addEventListener("change", () => {
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassRegisterInput) {
      bassRegisterInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassRandom) {
      bassRandom.addEventListener("click", () => {
        randomizeBassControls();
      });
    }
    if (chordChannelSelect) {
      chordChannelSelect.addEventListener("change", () => {
        sendAllNotesOff();
        rebuildMidi();
      });
    }
    if (bassChannelSelect) {
      bassChannelSelect.addEventListener("change", () => {
        sendAllNotesOff();
        rebuildMidi();
      });
    }
    tempoInput.addEventListener("input", () => {
      seedDrivesSettings = false;
      updateReadouts();
      if (isPlaying && (!midiEnabled || !externalBpm)) {
        const resumeIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
        stopPlayback();
        startPlayback(resumeIndex);
      }
    });
    if (subdivisionInput) {
      subdivisionInput.addEventListener("change", () => {
        seedDrivesSettings = false;
      });
    }
    if (keySelect) {
      keySelect.addEventListener("change", () => {
        seedDrivesSettings = false;
      });
    }

    if (genreMain && genreSub) {
      genreMain.addEventListener("change", () => {
        seedDrivesSettings = false;
        populateSubgenres(genreMain.value);
        render();
      });
      genreSub.addEventListener("change", () => {
        seedDrivesSettings = false;
        render();
      });
    }

    timelineScroll.addEventListener("input", () => {
      timelineView.scrollLeft = parseInt(timelineScroll.value, 10) || 0;
    });

    timelineView.addEventListener("scroll", () => {
      timelineScroll.value = String(timelineView.scrollLeft);
    });

    if (midiOutSelect) {
      midiOutSelect.addEventListener("change", () => {
        if (!midiAccess) return;
        const output = midiAccess.outputs.get(midiOutSelect.value) || null;
        midiOutput = output;
        preferredOutputId = output ? output.id : null;
        refreshMidiRouteOptions();
      });
    }

    if (midiInSelect) {
      midiInSelect.addEventListener("change", () => {
        if (!midiAccess) return;
        const input = midiAccess.inputs.get(midiInSelect.value) || null;
        if (midiInput && midiInput !== input) {
          midiInput.onmidimessage = null;
        }
        midiInput = input;
        preferredInputId = input ? input.id : null;
        if (midiInput) {
          midiInput.onmidimessage = handleMidiMessage;
        }
        refreshMidiRouteOptions();
      });
    }

    window.addEventListener("resize", () => {
      resizeOscilloscope();
    });

    if (midiToggle) {
      midiToggle.addEventListener("click", async () => {
        midiEnabled = !midiEnabled;
        if (midiEnabled) {
          tempoInput.disabled = false;
          if (midiVelocity) {
            midiVelocity.disabled = false;
          }
          document.body.classList.add("midi-on");
          await ensureMidi();
          if (!midiAccess) {
            midiEnabled = false;
            tempoInput.disabled = false;
            updateReadouts();
            midiToggle.textContent = "MIDI Out";
            document.body.classList.remove("midi-on");
            closeRouteModal();
            return;
          }
          midiToggle.textContent = midiOutput ? "MIDI Out: On" : "MIDI Out: No device";
          updateReadouts();
          restoreMasterGain();
        } else {
          sendAllNotesOff();
          midiOutput = null;
          if (midiInput) {
            midiInput.onmidimessage = null;
            midiInput = null;
          }
          externalBpm = null;
          lastClockTime = null;
          clockSmoothing = null;
          tempoInput.disabled = false;
          updateReadouts();
          midiToggle.textContent = "MIDI Out";
          restoreMasterGain();
          if (midiVelocity) {
            midiVelocity.disabled = true;
          }
          document.body.classList.remove("midi-on");
          closeRouteModal();
        }
      });
    }

    if (midiRoute) {
      midiRoute.addEventListener("click", async () => {
        if (!midiEnabled) return;
        await ensureMidi();
        openRouteModal();
      });
    }

    if (routeModal) {
      routeModal.addEventListener("click", (event) => {
        if (event.target === routeModal) {
          closeRouteModal();
        }
      });
    }

    if (routeClose) {
      routeClose.addEventListener("click", closeRouteModal);
    }

    if (songToggle) {
      songToggle.addEventListener("click", () => {
        setSongMode(!songMode);
      });
    }

    if (chordMute) {
      updateMuteButton(chordMute, chordMuted);
      chordMute.addEventListener("click", () => {
        chordMuted = !chordMuted;
        updateMuteButton(chordMute, chordMuted);
        sendAllNotesOff();
      });
    }

    if (bassMute) {
      updateMuteButton(bassMute, bassMuted);
      bassMute.addEventListener("click", () => {
        bassMuted = !bassMuted;
        updateMuteButton(bassMute, bassMuted);
        sendAllNotesOff();
      });
    }

    if (chordCollapse) {
      chordCollapse.addEventListener("click", () => {
        setPanelCollapsed(chordPanel, chordCollapse);
      });
    }

    if (bassCollapse) {
      bassCollapse.addEventListener("click", () => {
        setPanelCollapsed(bassPanel, bassCollapse);
      });
    }

    if (midiVelocity && midiVelocityValue) {
      midiVelocityValue.textContent = midiVelocity.value;
      midiVelocity.addEventListener("input", () => {
        midiVelocityValue.textContent = midiVelocity.value;
      });
      midiVelocity.disabled = true;
    }

    if (resetAll) {
      resetAll.addEventListener("click", () => {
        resetToDefaults();
      });
    }

    if (themeSlider) {
      const maxSteps = Math.max(0, (themes.length - 1) * 100);
      themeSlider.max = String(maxSteps);
      themeSlider.addEventListener("input", () => {
        const value = (parseInt(themeSlider.value, 10) || 0) / 100;
        applyThemeMix(value);
      });
      const startValue = (parseInt(themeSlider.value, 10) || 0) / 100;
      applyThemeMix(startValue);
    } else {
      updateThemeColors();
    }

    render();
  </script>
</body>
</html>
