<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>¢hange.machine</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap");

    :root {
      --bg: #0a0f0c;
      --bg-2: #0d1a14;
      --grid: rgba(82, 255, 171, 0.12);
      --text: #c9ffe7;
      --muted: #7fe6c1;
      --glow: #43ffb4;
      --accent: #ffb84a;
      --danger: #ff4d6d;
      --panel: rgba(7, 18, 14, 0.85);
      --panel-border: rgba(103, 255, 190, 0.3);
      --scanline: rgba(10, 26, 20, 0.35);
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 20%, #0f2a1e 0%, #0b120f 45%, #050806 100%);
      color: var(--text);
      font-family: "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.02em;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        repeating-linear-gradient(180deg, transparent 0px, transparent 2px, var(--scanline) 3px),
        radial-gradient(800px 600px at 70% 10%, rgba(67, 255, 180, 0.15), transparent 60%),
        radial-gradient(700px 500px at 10% 80%, rgba(255, 184, 74, 0.15), transparent 60%);
      mix-blend-mode: screen;
      opacity: 0.6;
      pointer-events: none;
      animation: scan 7s linear infinite;
    }

    body::after {
      content: "";
      position: fixed;
      inset: 0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.12'/%3E%3C/svg%3E");
      opacity: 0.2;
      pointer-events: none;
      mix-blend-mode: soft-light;
    }

    @keyframes scan {
      0% { transform: translateY(-2%); }
      100% { transform: translateY(2%); }
    }

    .frame {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px 20px;
    }

    .console {
      width: min(1200px, 100%);
      border: 2px solid var(--panel-border);
      background: var(--panel);
      box-shadow: 0 0 30px rgba(67, 255, 180, 0.2), 0 0 90px rgba(67, 255, 180, 0.15);
      padding: 28px;
      position: relative;
      overflow: visible;
    }

    .progression-panel {
      position: relative;
      overflow: visible;
    }

    .progression-panel::before {
      content: "";
      position: absolute;
      inset: -10px;
      border: 1px dashed rgba(67, 255, 180, 0.2);
      pointer-events: none;
      z-index: 0;
    }

    .progression-panel > * {
      position: relative;
      z-index: 1;
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 24px;
    }

    .title {
      font-family: "Press Start 2P", system-ui, sans-serif;
      font-size: clamp(18px, 2vw, 26px);
      text-transform: uppercase;
      text-shadow: 0 0 10px var(--glow), 0 0 20px rgba(67, 255, 180, 0.4);
    }

    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .status .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent);
      animation: pulse 1.8s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.4); opacity: 1; }
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(250px, 1fr) 2fr;
      gap: 20px;
    }

    .panel {
      border: 1px solid var(--panel-border);
      padding: 18px;
      background: rgba(5, 14, 10, 0.7);
      box-shadow: inset 0 0 20px rgba(8, 40, 28, 0.6);
      min-width: 0;
    }

    .panel h2 {
      margin: 0 0 14px;
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    .panel .button-row + h2 {
      margin-top: 10px;
    }

    .help-button {
      position: fixed;
      right: 22px;
      bottom: 22px;
      z-index: 10;
      border: 1px solid rgba(110, 255, 198, 0.5);
      background: rgba(6, 18, 12, 0.9);
      color: var(--text);
      padding: 10px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 0 14px rgba(67, 255, 180, 0.2);
    }

    .help-button:hover {
      box-shadow: 0 0 18px rgba(67, 255, 180, 0.35);
    }

    .help-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 5, 0.85);
      z-index: 20;
      padding: 24px;
    }

    .help-modal.active {
      display: flex;
    }

    .help-terminal {
      width: min(720px, 100%);
      background: #020705;
      border: 1px solid rgba(110, 255, 198, 0.4);
      box-shadow: 0 0 24px rgba(67, 255, 180, 0.3);
      padding: 20px;
      font-size: 12px;
      line-height: 1.6;
    }

    .help-terminal h3 {
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .help-terminal pre {
      margin: 0;
      white-space: pre-wrap;
      color: var(--text);
    }

    .help-cursor {
      display: inline-block;
      width: 8px;
      margin-left: 2px;
      background: var(--text);
      animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .help-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
    }

    .controls {
      display: grid;
      gap: 14px;
    }

    label {
      display: grid;
      gap: 8px;
      font-size: 12px;
      color: var(--muted);
    }

    input, select, button {
      font-family: inherit;
      font-size: 14px;
    }

    input[type="range"], input[type="number"], input[type="text"], select {
      background: #040b08;
      color: var(--text);
      border: 1px solid rgba(110, 255, 198, 0.3);
      padding: 6px 8px;
      border-radius: 4px;
      outline: none;
    }

    input[type="range"] {
      accent-color: var(--glow);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 6px;
    }

    button {
      border: 1px solid rgba(110, 255, 198, 0.5);
      background: linear-gradient(120deg, rgba(7, 32, 20, 0.9), rgba(8, 64, 40, 0.9));
      color: var(--text);
      padding: 10px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 12px rgba(67, 255, 180, 0.35);
    }

    button.secondary {
      border-color: rgba(255, 184, 74, 0.6);
      color: var(--accent);
    }


    .readout {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .timeline-view {
      --beat-px: 34px;
      --bar-px: calc(var(--beat-px) * 4);
      border: 1px solid rgba(110, 255, 198, 0.3);
      background: rgba(4, 10, 8, 0.65);
      width: 100%;
      max-width: 100%;
      overflow-x: hidden;
      overflow-y: hidden;
      padding-bottom: 6px;
      scrollbar-gutter: stable;
    }

    .ruler {
      position: relative;
      height: 32px;
      border-bottom: 1px solid rgba(110, 255, 198, 0.25);
      background-image:
        repeating-linear-gradient(90deg, rgba(67, 255, 180, 0.35) 0, rgba(67, 255, 180, 0.35) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(67, 255, 180, 0.12) 0, rgba(67, 255, 180, 0.12) 1px, transparent 1px, transparent var(--beat-px));
    }

    .bar-label {
      position: absolute;
      top: 7px;
      font-size: 10px;
      color: var(--muted);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .track {
      position: relative;
      height: 140px;
      background-image:
        repeating-linear-gradient(90deg, rgba(67, 255, 180, 0.3) 0, rgba(67, 255, 180, 0.3) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(67, 255, 180, 0.08) 0, rgba(67, 255, 180, 0.08) 1px, transparent 1px, transparent var(--beat-px));
    }

    .clip {
      position: absolute;
      top: 32px;
      height: 64px;
      border: 1px solid rgba(110, 255, 198, 0.55);
      border-left-width: 2px;
      border-left-color: rgba(255, 184, 74, 0.8);
      background: linear-gradient(135deg, rgba(67, 255, 180, 0.2), rgba(4, 10, 8, 0.75));
      color: var(--text);
      padding: 8px 10px;
      text-shadow: 0 0 6px rgba(67, 255, 180, 0.5);
      box-shadow: 0 0 12px rgba(67, 255, 180, 0.2);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }

    .clip.active {
      border-color: rgba(255, 184, 74, 0.95);
      box-shadow: 0 0 18px rgba(255, 184, 74, 0.35);
    }

    .clip-title {
      font-size: 12px;
      margin-bottom: 0;
    }

    .timeline-scroll {
      margin-top: 10px;
    }

    .timeline-scroll input[type="range"] {
      width: 100%;
    }

    .text-export {
      margin-top: 12px;
      display: grid;
      gap: 10px;
    }

    .text-export textarea {
      width: 100%;
      min-height: 80px;
      background: #040b08;
      color: var(--text);
      border: 1px solid rgba(110, 255, 198, 0.3);
      padding: 8px 10px;
      border-radius: 4px;
      resize: vertical;
    }

    .progression-highlight {
      display: block;
      border: 1px solid rgba(110, 255, 198, 0.3);
      background: #040b08;
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text);
      white-space: pre-wrap;
    }

    .progression-highlight mark {
      background: rgba(255, 184, 74, 0.25);
      color: var(--text);
      padding: 0 2px;
      border-radius: 3px;
      box-shadow: 0 0 8px rgba(255, 184, 74, 0.3);
    }

    .oscilloscope {
      width: 100%;
      height: 120px;
      border: 1px solid rgba(110, 255, 198, 0.3);
      background: radial-gradient(circle at 20% 20%, rgba(67, 255, 180, 0.1), transparent 60%), #020705;
      box-shadow: inset 0 0 20px rgba(7, 40, 24, 0.6);
    }

    .footer {
      margin-top: 18px;
      font-size: 11px;
      color: rgba(127, 230, 193, 0.7);
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .track {
        height: 160px;
      }

      .clip {
        height: 70px;
      }
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="console">
      <div class="header">
        <div class="title">¢hange.machine</div>
        <div class="status"><span class="dot"></span></div>
      </div>

      <div class="grid">
        <section class="panel progression-panel">
          <h2>Controls</h2>
          <div class="controls">
            <label>
              Key center
              <select id="keySelect"></select>
            </label>
            <label>
              Tempo (BPM)
              <input id="tempo" type="range" min="60" max="200" value="110" />
              <span class="readout" id="tempoReadout">110 BPM</span>
            </label>
            <label>
              Bars
              <input id="bars" type="range" min="4" max="32" value="4" />
              <span class="readout" id="barsReadout">4 bars</span>
            </label>
            <label>
              Harmonic density
              <input id="density" type="range" min="0" max="100" value="50" />
              <span class="readout" id="densityReadout">50%</span>
            </label>
            <label>
              Subdivision density
              <input id="subdivisionDensity" type="range" min="0" max="100" value="50" />
              <span class="readout" id="subdivisionDensityReadout">50%</span>
            </label>
            <label>
              Subdivision mode
              <select id="subdivision">
                <option value="even">Even only</option>
                <option value="mixed">Even + triplet</option>
              </select>
            </label>
            <label>
              $eed
              <input id="seed" type="text" placeholder="blank $eed" />
            </label>
            <div class="button-row">
              <button id="importSeed" class="secondary">Import $eed</button>
              <button id="copySeed" class="secondary">Copy $eed</button>
            </div>
          </div>
        </section>

        <section class="panel">
          <div class="button-row">
            <button id="generate">¢hange</button>
            <button id="play">Play</button>
            <button id="download" class="secondary">Download .mid</button>
          </div>
          <h2>Progression</h2>
          <div id="timelineView" class="timeline-view">
            <div id="ruler" class="ruler"></div>
            <div id="track" class="track"></div>
          </div>
          <div class="timeline-scroll">
            <input id="timelineScroll" type="range" min="0" max="0" value="0" />
          </div>
          <div class="text-export">
            <label for="progressionText">Chord text</label>
            <textarea id="progressionText" readonly></textarea>
            <div id="progressionHighlight" class="progression-highlight"></div>
            <button id="copyProgression" class="secondary">Copy progression</button>
          </div>
          <canvas id="oscilloscope" class="oscilloscope"></canvas>
          <div class="footer" id="footer"></div>
        </section>
      </div>
    </div>
  </div>

  <button id="helpButton" class="help-button">?</button>
  <div id="helpModal" class="help-modal" aria-hidden="true">
    <div class="help-terminal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <h3 id="helpTitle">¢hange.machine // operator manual</h3>
      <pre><span id="helpText"></span><span class="help-cursor" aria-hidden="true"></span></pre>
      <div class="help-actions">
        <button id="helpClose" class="secondary">Close</button>
      </div>
    </div>
  </div>

  <script>
    const noteNames = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

    const degreeOffsets = {
      "I": 0,
      "ii": 2,
      "iii": 4,
      "IV": 5,
      "V": 7,
      "vi": 9,
      "vii": 11,
      "bII": 1,
      "bVII": 10,
      "iv": 5,
      "VI": 9
    };

    const qualities = {
      "maj9#11": [0, 4, 11, 14, 18],
      "maj9": [0, 4, 7, 11, 14],
      "m9": [0, 3, 7, 10, 14],
      "13b9": [0, 4, 10, 13, 21],
      "13": [0, 4, 10, 14, 21],
      "7alt": [0, 4, 10, 13, 18]
    };

    const functions = {
      tonic: [
        { degree: "I", quality: "maj9#11" },
        { degree: "I", quality: "maj9" },
        { degree: "vi", quality: "m9" }
      ],
      predom: [
        { degree: "ii", quality: "m9" },
        { degree: "iv", quality: "m9" },
        { degree: "iii", quality: "m9" }
      ],
      dominant: [
        { degree: "V", quality: "13b9" },
        { degree: "V", quality: "7alt" },
        { degree: "bII", quality: "7alt" },
        { degree: "bVII", quality: "13" },
        { degree: "VI", quality: "7alt" }
      ]
    };

    const patternsEvenByDensity = {
      1: [[2, 2], [3, 1], [2, 1, 1]],
      2: [[2, 2], [1.5, 1.5, 1], [2, 1, 1], [1, 1, 2]],
      3: [[1, 1, 2], [1.5, 1.5, 1], [2, 1, 1], [1, 1, 1, 1]],
      4: [[1, 1, 1, 1], [1, 1, 2], [1.5, 1, 1.5], [1, 1.5, 1.5]],
      5: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2], [1.5, 1.5, 1]]
    };

    const patternsTripletByDensity = {
      1: [[4 / 3, 4 / 3, 4 / 3], [2, 4 / 3, 2 / 3]],
      2: [[2 / 3, 2 / 3, 2 / 3, 2], [4 / 3, 2 / 3, 2], [2, 2 / 3, 4 / 3]],
      3: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 4 / 3], [4 / 3, 4 / 3, 2 / 3, 2 / 3]],
      4: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3], [4 / 3, 2 / 3, 4 / 3, 2 / 3]],
      5: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3], [2 / 3, 4 / 3, 2 / 3, 4 / 3]]
    };

    const simplePatterns = [[4], [2, 2], [3, 1], [1, 3]];
    const densePatterns = [
      [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
      [0.5, 0.5, 1, 0.5, 0.5, 1],
      [0.5, 0.5, 0.5, 1, 0.5, 0.5]
    ];

    function pickDensityIndex(densityPercent, rng) {
      const clamped = Math.max(0, Math.min(100, densityPercent));
      const scaled = (clamped / 100) * 4;
      const base = Math.floor(scaled);
      const frac = scaled - base;
      const index = rng() < frac ? base + 1 : base;
      return Math.max(1, Math.min(5, index + 1));
    }

    function xmur3(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function() {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        h ^= h >>> 16;
        return h >>> 0;
      };
    }

    function sfc32(a, b, c, d) {
      return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        let t = (a + b) | 0;
        a = b ^ (b >>> 9);
        b = (c + (c << 3)) | 0;
        c = (c << 21) | (c >>> 11);
        d = (d + 1) | 0;
        t = (t + d) | 0;
        c = (c + t) | 0;
        return (t >>> 0) / 4294967296;
      };
    }

    function makeRng(seedText) {
      const seed = xmur3(seedText)();
      return sfc32(seed, seed ^ 0xa5a5a5a5, seed ^ 0x5a5a5a5a, seed ^ 0x12345678);
    }

    function pick(list, rng) {
      return list[Math.floor(rng() * list.length)];
    }

    function buildChord(rootIndex, quality, rng) {
      const baseRoot = 48 + rootIndex + (rootIndex > 7 ? -12 : 0);
      let notes = qualities[quality].map(interval => baseRoot + interval);

      notes.sort((a, b) => a - b);
      if (notes.length >= 4) {
        const dropIndex = notes.length - 2;
        notes[dropIndex] += 12;
      }
      if (notes.length >= 5 && rng() < 0.55) {
        notes[1] += 12;
      }
      notes = notes.sort((a, b) => a - b);

      while (notes[notes.length - 1] > 84) {
        notes[notes.length - 1] -= 12;
        notes = notes.sort((a, b) => a - b);
      }
      return notes;
    }

    function chordName(rootIndex, quality) {
      return `${noteNames[rootIndex]}${quality}`;
    }

    function generateProgression({ bars, key, densityPercent, seed, subdivision, subdivisionDensity }) {
      const rng = makeRng(seed);
      const totalBars = Math.max(4, bars);
      const totalBeats = totalBars * 4;
      const keyIndex = noteNames.indexOf(key);

      let beatsRemaining = totalBeats;
      let functionState = "predom";
      const chords = [];

      for (let bar = 0; bar < totalBars; bar++) {
        const densityIndex = pickDensityIndex(densityPercent, rng);
        const evenPatterns = patternsEvenByDensity[densityIndex];
        const tripletPatterns = patternsTripletByDensity[densityIndex];
        let pattern = [4];
        if (subdivisionDensity > 0) {
          if (densityPercent >= 95 && rng() < 0.7) {
            pattern = pick(densePatterns, rng);
          } else if (rng() < subdivisionDensity) {
            pattern = pick(evenPatterns, rng);
            if (subdivision === "mixed" && rng() < 0.35) {
              pattern = pick(tripletPatterns, rng);
            }
          } else {
            pattern = pick(simplePatterns, rng);
          }
        }
        for (let i = 0; i < pattern.length; i++) {
          const isPhraseEnd = (bar % 4 === 3) && (i === pattern.length - 1);
          const isPhrasePrep = (bar % 4 === 3) && (i === pattern.length - 2);

          if (isPhraseEnd) {
            functionState = "tonic";
          } else if (isPhrasePrep) {
            functionState = "dominant";
          } else {
            if (functionState === "tonic") {
              functionState = rng() < 0.7 ? "predom" : "dominant";
            } else if (functionState === "predom") {
              functionState = rng() < 0.75 ? "dominant" : "predom";
            } else {
              functionState = rng() < 0.7 ? "tonic" : "predom";
            }
          }

          const choice = pick(functions[functionState], rng);
          const offset = degreeOffsets[choice.degree];
          const rootIndex = (keyIndex + offset + 12) % 12;
          const notes = buildChord(rootIndex, choice.quality, rng);
          const duration = pattern[i];

          chords.push({
            name: chordName(rootIndex, choice.quality),
            duration,
            notes
          });
          beatsRemaining -= duration;
        }
      }

      if (beatsRemaining > 0.01) {
        const last = chords[chords.length - 1];
        last.duration += beatsRemaining;
      }

      return chords;
    }

    function writeVarInt(value) {
      let buffer = value & 0x7f;
      const bytes = [];
      while ((value >>= 7)) {
        buffer <<= 8;
        buffer |= ((value & 0x7f) | 0x80);
      }
      while (true) {
        bytes.push(buffer & 0xff);
        if (buffer & 0x80) buffer >>= 8; else break;
      }
      return bytes;
    }

    function buildMidi(chords, bpm) {
      const ticksPerBeat = 480;
      const track = [];

      function push(...bytes) { track.push(...bytes); }

      push(...writeVarInt(0), 0xff, 0x58, 0x04, 0x04, 0x02, 0x18, 0x08);
      const tempo = Math.round(60000000 / bpm);
      push(...writeVarInt(0), 0xff, 0x51, 0x03,
        (tempo >> 16) & 0xff,
        (tempo >> 8) & 0xff,
        tempo & 0xff
      );
      push(...writeVarInt(0), 0xc0, 0x04);

      for (const chord of chords) {
        chord.notes.forEach(note => {
          push(...writeVarInt(0), 0x90, note, 92);
        });
        const durationTicks = Math.round(chord.duration * ticksPerBeat);
        push(...writeVarInt(durationTicks), 0x80, chord.notes[0], 0);
        chord.notes.slice(1).forEach(note => {
          push(...writeVarInt(0), 0x80, note, 0);
        });
      }

      push(...writeVarInt(0), 0xff, 0x2f, 0x00);

      const trackLength = track.length;
      const header = [
        0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x01, (ticksPerBeat >> 8) & 0xff, ticksPerBeat & 0xff
      ];
      const trackHeader = [
        0x4d, 0x54, 0x72, 0x6b,
        (trackLength >> 24) & 0xff,
        (trackLength >> 16) & 0xff,
        (trackLength >> 8) & 0xff,
        trackLength & 0xff
      ];

      return new Uint8Array([...header, ...trackHeader, ...track]);
    }

    function buildProgressionTokens(chords) {
      const tokens = [];
      let beatInBar = 0;
      const eps = 1e-6;

      chords.forEach((chord, index) => {
        tokens.push({ type: "chord", text: chord.name, index });
        beatInBar += chord.duration;
        if (beatInBar >= 4 - eps) {
          tokens.push({ type: "bar", text: " | " });
          beatInBar -= 4;
          if (beatInBar < eps) beatInBar = 0;
        } else {
          tokens.push({ type: "space", text: " " });
        }
      });

      if (tokens.length && tokens[tokens.length - 1].type !== "bar") {
        tokens.push({ type: "bar", text: " | " });
      }

      return tokens;
    }

    function formatProgressionTextFromTokens(tokens) {
      return tokens.map(token => token.text).join("").replace(/\s\|\s$/, "");
    }

    function renderProgressionHighlight(activeIndex) {
      if (!progressionHighlight) return;
      const html = chordTextTokens.map(token => {
        if (token.type === "chord") {
          if (token.index === activeIndex) {
            return `<mark>${token.text}</mark>`;
          }
          return token.text;
        }
        return token.text;
      }).join("");
      progressionHighlight.innerHTML = html.replace(/\s\|\s$/, "");
    }

    function sanitizeFileName(name) {
      const cleaned = name
        .toString()
        .trim()
        .replace(/\s+/g, "_")
        .replace(/[^a-zA-Z0-9_$-]/g, "");
      return cleaned.length ? cleaned : "change.machine";
    }

    const keySelect = document.getElementById("keySelect");
    const tempoInput = document.getElementById("tempo");
    const tempoReadout = document.getElementById("tempoReadout");
    const barsInput = document.getElementById("bars");
    const densityInput = document.getElementById("density");
    const subdivisionDensityInput = document.getElementById("subdivisionDensity");
    const subdivisionInput = document.getElementById("subdivision");
    const seedInput = document.getElementById("seed");
    const importSeed = document.getElementById("importSeed");
    const copySeed = document.getElementById("copySeed");
    const helpButton = document.getElementById("helpButton");
    const helpModal = document.getElementById("helpModal");
    const helpClose = document.getElementById("helpClose");
    const helpText = document.getElementById("helpText");
    const barsReadout = document.getElementById("barsReadout");
    const densityReadout = document.getElementById("densityReadout");
    const subdivisionDensityReadout = document.getElementById("subdivisionDensityReadout");
    const timelineView = document.getElementById("timelineView");
    const ruler = document.getElementById("ruler");
    const track = document.getElementById("track");
    const timelineScroll = document.getElementById("timelineScroll");
    const progressionText = document.getElementById("progressionText");
    const progressionHighlight = document.getElementById("progressionHighlight");
    const copyProgression = document.getElementById("copyProgression");
    const playButton = document.getElementById("play");
    const oscilloscope = document.getElementById("oscilloscope");
    const footer = document.getElementById("footer");

    const randomOption = document.createElement("option");
    randomOption.value = "random";
    randomOption.textContent = "Random";
    keySelect.appendChild(randomOption);

    noteNames.forEach(name => {
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      keySelect.appendChild(option);
    });
    keySelect.value = "random";

    let currentMidi = null;
    let midiBlobUrl = null;
    let currentChords = [];
    let chordTextTokens = [];
    let chordStarts = [];
    let chordClips = [];
    let currentChordIndex = -1;
    let currentFileName = "change.machine.mid";
    let currentSeed = "";
    let isPlaying = false;
    let playTimers = [];
    let audioContext = null;
    let masterGain = null;
    let analyser = null;
    let oscData = null;
    let oscCtx = null;
    let oscAnimId = null;
    const activeOscillators = new Set();
    const DEFAULT_GAIN = 0.18;

    function ensureAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = DEFAULT_GAIN;
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.85;
        oscData = new Uint8Array(analyser.fftSize);
        masterGain.connect(analyser);
        analyser.connect(audioContext.destination);
        startOscilloscope();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
    }

    function resizeOscilloscope() {
      if (!oscilloscope) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = oscilloscope.getBoundingClientRect();
      oscilloscope.width = Math.max(1, Math.floor(rect.width * dpr));
      oscilloscope.height = Math.max(1, Math.floor(rect.height * dpr));
      oscCtx = oscilloscope.getContext("2d");
      oscCtx.setTransform(1, 0, 0, 1, 0, 0);
      oscCtx.scale(dpr, dpr);
    }

    function startOscilloscope() {
      if (!oscilloscope || !analyser) return;
      resizeOscilloscope();
      if (oscAnimId) cancelAnimationFrame(oscAnimId);

      const draw = () => {
        oscAnimId = requestAnimationFrame(draw);
        if (!oscCtx) return;
        const width = oscilloscope.clientWidth;
        const height = oscilloscope.clientHeight;
        oscCtx.clearRect(0, 0, width, height);
        oscCtx.fillStyle = "rgba(2, 7, 5, 0.9)";
        oscCtx.fillRect(0, 0, width, height);

        analyser.getByteTimeDomainData(oscData);
        oscCtx.lineWidth = 2;
        oscCtx.strokeStyle = "rgba(67, 255, 180, 0.9)";
        oscCtx.shadowBlur = 12;
        oscCtx.shadowColor = "rgba(67, 255, 180, 0.5)";
        oscCtx.beginPath();

        const sliceWidth = width / oscData.length;
        let x = 0;
        for (let i = 0; i < oscData.length; i++) {
          const v = oscData[i] / 128.0;
          const y = (v * height) / 2;
          if (i === 0) {
            oscCtx.moveTo(x, y);
          } else {
            oscCtx.lineTo(x, y);
          }
          x += sliceWidth;
        }
        oscCtx.lineTo(width, height / 2);
        oscCtx.stroke();

        oscCtx.shadowBlur = 0;
        oscCtx.strokeStyle = "rgba(67, 255, 180, 0.2)";
        oscCtx.beginPath();
        oscCtx.moveTo(0, height / 2);
        oscCtx.lineTo(width, height / 2);
        oscCtx.stroke();
      };

      draw();
    }

    function midiToFreq(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }

    function playChordAtTime(notes, startTime, durationSec) {
      const attack = 0.02;
      const release = Math.max(0.05, durationSec * 0.35);
      notes.forEach(note => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "sine";
        osc.frequency.value = midiToFreq(note);
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.18, startTime + attack);
        gain.gain.linearRampToValueAtTime(0.0001, Math.max(startTime + attack + 0.01, startTime + durationSec - release));
        gain.gain.linearRampToValueAtTime(0, startTime + durationSec);
        osc.connect(gain);
        gain.connect(masterGain);
        activeOscillators.add(osc);
        osc.onended = () => {
          activeOscillators.delete(osc);
        };
        osc.start(startTime);
        osc.stop(startTime + durationSec + 0.02);
      });
    }

    function clearTimers() {
      playTimers.forEach(id => clearTimeout(id));
      playTimers = [];
    }

    function setActiveChord(index) {
      if (currentChordIndex >= 0 && chordClips[currentChordIndex]) {
        chordClips[currentChordIndex].classList.remove("active");
      }
      currentChordIndex = index;
      if (currentChordIndex >= 0 && chordClips[currentChordIndex]) {
        const clip = chordClips[currentChordIndex];
        clip.classList.add("active");
        const clipLeft = clip.offsetLeft;
        const clipRight = clipLeft + clip.offsetWidth;
        const viewLeft = timelineView.scrollLeft;
        const viewRight = viewLeft + timelineView.clientWidth;
        const targetLeft = Math.max(clipLeft - 16, 0);
        if (clipRight > viewRight || clipLeft < viewLeft) {
          timelineView.scrollLeft = targetLeft;
        }
        timelineScroll.value = String(timelineView.scrollLeft);
      }
      renderProgressionHighlight(currentChordIndex);
    }

    function stopPlayback() {
      if (!isPlaying) return;
      clearTimers();
      isPlaying = false;
      playButton.textContent = "Play";
      if (audioContext && masterGain) {
        const now = audioContext.currentTime;
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setTargetAtTime(0, now, 0.015);
      }
      activeOscillators.forEach(osc => {
        try {
          osc.stop();
        } catch (err) {
          // Ignore if already stopped.
        }
      });
      activeOscillators.clear();
    }

    function startPlayback(startIndex) {
      if (!currentChords.length) return;
      ensureAudio();
      isPlaying = true;
      playButton.textContent = "Stop";
      clearTimers();

      const bpm = Math.max(60, Math.min(200, parseInt(tempoInput.value, 10) || 110));
      const beatSec = 60 / bpm;
      const safeStart = ((startIndex % currentChords.length) + currentChords.length) % currentChords.length;
      let cursor = 0;

      setActiveChord(safeStart);
      if (masterGain && audioContext) {
        masterGain.gain.cancelScheduledValues(audioContext.currentTime);
        masterGain.gain.setValueAtTime(DEFAULT_GAIN, audioContext.currentTime);
      }

      for (let i = safeStart; i < currentChords.length; i++) {
        const chord = currentChords[i];
        const startTime = audioContext.currentTime + cursor * beatSec;
        playChordAtTime(chord.notes, startTime, chord.duration * beatSec);
        const timerId = setTimeout(() => {
          setActiveChord(i);
        }, Math.max(0, cursor * beatSec * 1000));
        playTimers.push(timerId);
        cursor += chord.duration;
      }

      const endTimer = setTimeout(() => {
        if (!isPlaying) return;
        startPlayback(0);
      }, cursor * beatSec * 1000 + 50);
      playTimers.push(endTimer);
    }

    function updateReadouts() {
      barsReadout.textContent = `${barsInput.value} bars`;
      densityReadout.textContent = `${densityInput.value}%`;
      subdivisionDensityReadout.textContent = `${subdivisionDensityInput.value}%`;
      tempoReadout.textContent = `${tempoInput.value} BPM`;
    }

    function render() {
      stopPlayback();
      updateReadouts();
      const bars = parseInt(barsInput.value, 10);
      const densityPercent = Math.max(0, Math.min(100, parseInt(densityInput.value, 10) || 0));
      const subdivision = subdivisionInput.value;
      const subdivisionDensity = Math.max(0, Math.min(100, parseInt(subdivisionDensityInput.value, 10) || 0)) / 100;
      const bpm = Math.max(60, Math.min(200, parseInt(tempoInput.value, 10) || 110));
      const seedRaw = seedInput.value.trim() || `$eed-${Date.now()}`;
      const seedLabel = seedRaw;
      const keyChoice = keySelect.value;
      let key = keyChoice;
      let keyLabel = keyChoice;
      if (keyChoice === "random") {
        const keyRng = makeRng(`${seedLabel}-key`);
        key = noteNames[Math.floor(keyRng() * noteNames.length)];
        keyLabel = `random → ${key}`;
      }

      const chords = generateProgression({ bars, key, densityPercent, seed: seedLabel, subdivision, subdivisionDensity });
      currentChords = chords;
      currentMidi = buildMidi(chords, bpm);
      currentSeed = seedLabel;
      currentFileName = `${sanitizeFileName(seedLabel)}.mid`;
      if (midiBlobUrl) {
        URL.revokeObjectURL(midiBlobUrl);
      }
      const midiBlob = new Blob([currentMidi], { type: "audio/midi" });
      midiBlobUrl = URL.createObjectURL(midiBlob);

      ruler.innerHTML = "";
      track.innerHTML = "";
      timelineView.scrollLeft = 0;

      const totalBeats = chords.reduce((sum, chord) => sum + chord.duration, 0);
      const beatPx = 34;
      const totalWidth = Math.max(Math.round(totalBeats * beatPx), timelineView.clientWidth - 2) + 16;
      timelineView.style.setProperty("--beat-px", `${beatPx}px`);
      timelineView.style.setProperty("--bar-px", `${beatPx * 4}px`);
      ruler.style.width = `${totalWidth}px`;
      track.style.width = `${totalWidth}px`;
      const maxScroll = Math.max(0, timelineView.scrollWidth - timelineView.clientWidth);
      timelineScroll.max = String(maxScroll);
      timelineScroll.value = "0";

      for (let bar = 0; bar < bars; bar++) {
        const label = document.createElement("div");
        label.className = "bar-label";
        label.style.left = `${bar * 4 * beatPx + 6}px`;
        label.textContent = `Bar ${bar + 1}`;
        ruler.appendChild(label);
      }

      let beatCursor = 0;
      chordStarts = [];
      chordClips = [];
      currentChordIndex = -1;

      chords.forEach(chord => {
        const clip = document.createElement("div");
        clip.className = "clip";
        clip.style.left = `${beatCursor * beatPx}px`;
        clip.style.width = `${Math.max(beatPx * 0.6, chord.duration * beatPx)}px`;
        clip.innerHTML = `<div class="clip-title">${chord.name}</div>`;
        track.appendChild(clip);
        chordStarts.push(beatCursor);
        chordClips.push(clip);
        beatCursor += chord.duration;
      });

      chordTextTokens = buildProgressionTokens(chords);
      progressionText.value = formatProgressionTextFromTokens(chordTextTokens);
      renderProgressionHighlight(currentChordIndex);
      const subdivisionLabel = subdivision === "mixed" ? "even+triplet" : "even";
      const seedDisplay = seedLabel.startsWith("$eed") ? seedLabel : `$eed ${seedLabel}`;
      footer.textContent = `Key ${keyLabel} | ${bars} bars | ${bpm} BPM | density ${densityPercent}% | ${subdivisionLabel} | subdiv ${Math.round(subdivisionDensity * 100)}% | ${seedDisplay}`;
    }

    document.getElementById("generate").addEventListener("click", () => {
      render();
    });

    document.getElementById("download").addEventListener("click", () => {
      if (!currentMidi) return;
      if (!midiBlobUrl) return;
      const url = midiBlobUrl;
      const a = document.createElement("a");
      a.href = url;
      a.download = currentFileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    copyProgression.addEventListener("click", async () => {
      const text = progressionText.value.trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        copyProgression.textContent = "Copied";
        setTimeout(() => {
          copyProgression.textContent = "Copy progression";
        }, 1200);
      } catch (err) {
        progressionText.focus();
        progressionText.select();
        document.execCommand("copy");
      }
    });

    importSeed.addEventListener("click", () => {
      const trimmed = seedInput.value.trim();
      if (!trimmed) return;
      render();
    });

    seedInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        if (seedInput.value.trim()) {
          render();
        }
      }
    });

    copySeed.addEventListener("click", async () => {
      const seedValue = (seedInput.value.trim() || currentSeed || "").trim();
      if (!seedValue) return;
      try {
        await navigator.clipboard.writeText(seedValue);
        copySeed.textContent = "Copied";
        setTimeout(() => {
          copySeed.textContent = "Copy $eed";
        }, 1200);
      } catch (err) {
        seedInput.focus();
        seedInput.select();
        document.execCommand("copy");
      }
    });

    const helpContent = [
      "SYSTEM: Generates chord progressions and exports MIDI blocks.",
      "",
      "CONTROLS",
      "- Key center: Choose a root or random.",
      "- Tempo: BPM for playback and MIDI.",
      "- Bars: Length of the progression.",
      "- Harmonic density (%): How busy the harmony feels.",
      "- Subdivision density (%): How often bars subdivide.",
      "- Subdivision mode: Even only or even + triplet feel.",
      "- $eed: Paste any text to make a repeatable progression.",
      "",
      "BUTTONS",
      "- ¢hange: Generate a new progression.",
      "- Play: Listen with a sine synth (loops).",
      "- Download .mid: Save the MIDI file.",
      "- Import $eed: Loads the current $eed value.",
      "- Copy $eed / Copy progression: Clipboard helpers.",
      "",
      "HOTKEYS",
      "- Space: Play/Stop.",
      "- Left/Right: Step through chords.",
      "- C: ¢hange (new progression).",
      "- Enter (in $eed): Import $eed."
    ].join("\n");

    let helpTypeTimer = null;

    function typeHelpText() {
      if (!helpText) return;
      helpText.textContent = "";
      if (helpTypeTimer) clearInterval(helpTypeTimer);
      let index = 0;
      helpTypeTimer = setInterval(() => {
        helpText.textContent = helpContent.slice(0, index);
        index += 1;
        if (index > helpContent.length) {
          clearInterval(helpTypeTimer);
          helpTypeTimer = null;
        }
      }, 6);
    }

    function openHelp() {
      helpModal.classList.add("active");
      helpModal.setAttribute("aria-hidden", "false");
      typeHelpText();
    }

    function closeHelp() {
      helpModal.classList.remove("active");
      helpModal.setAttribute("aria-hidden", "true");
      if (helpTypeTimer) {
        clearInterval(helpTypeTimer);
        helpTypeTimer = null;
      }
    }

    helpButton.addEventListener("click", openHelp);
    helpClose.addEventListener("click", closeHelp);
    helpModal.addEventListener("click", (event) => {
      if (event.target === helpModal) {
        closeHelp();
      }
    });


    playButton.addEventListener("click", () => {
      if (isPlaying) {
        stopPlayback();
        return;
      }
      const startIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
      startPlayback(startIndex);
    });

    document.addEventListener("keydown", (event) => {
      const tag = (event.target && event.target.tagName) ? event.target.tagName.toLowerCase() : "";
      if (tag === "input" || tag === "textarea" || tag === "select") return;
      if (!currentChords.length) return;
      if (event.key === "Escape" && helpModal.classList.contains("active")) {
        event.preventDefault();
        closeHelp();
      } else if (event.key === "c" || event.key === "C") {
        event.preventDefault();
        render();
      } else if (event.key === " ") {
        event.preventDefault();
        if (isPlaying) {
          stopPlayback();
        } else {
          const startIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
          startPlayback(startIndex);
        }
      } else if (event.key === "ArrowRight") {
        event.preventDefault();
        stopPlayback();
        const nextIndex = (currentChordIndex + 1) % currentChords.length;
        setActiveChord(nextIndex);
        ensureAudio();
        const bpm = Math.max(60, Math.min(200, parseInt(tempoInput.value, 10) || 110));
        const beatSec = 60 / bpm;
        playChordAtTime(currentChords[nextIndex].notes, audioContext.currentTime, currentChords[nextIndex].duration * beatSec);
      } else if (event.key === "ArrowLeft") {
        event.preventDefault();
        stopPlayback();
        const prevIndex = Math.max(0, currentChordIndex === -1 ? 0 : currentChordIndex - 1);
        setActiveChord(prevIndex);
        ensureAudio();
        const bpm = Math.max(60, Math.min(200, parseInt(tempoInput.value, 10) || 110));
        const beatSec = 60 / bpm;
        playChordAtTime(currentChords[prevIndex].notes, audioContext.currentTime, currentChords[prevIndex].duration * beatSec);
      }
    });

    barsInput.addEventListener("input", updateReadouts);
    densityInput.addEventListener("input", updateReadouts);
    subdivisionDensityInput.addEventListener("input", updateReadouts);
    tempoInput.addEventListener("input", updateReadouts);

    timelineScroll.addEventListener("input", () => {
      timelineView.scrollLeft = parseInt(timelineScroll.value, 10) || 0;
    });

    timelineView.addEventListener("scroll", () => {
      timelineScroll.value = String(timelineView.scrollLeft);
    });

    window.addEventListener("resize", () => {
      resizeOscilloscope();
    });

    render();
  </script>
</body>
</html>
