<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>¢hange.machine</title>
  <style>
    @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Share+Tech+Mono&display=swap");

    :root {
      --bg: #0a0f0c;
      --bg-2: #0f2a1e;
      --bg-3: #050806;
      --grid-rgb: 82, 255, 171;
      --grid: rgba(var(--grid-rgb), 0.12);
      --text: #c9ffe7;
      --muted: #7fe6c1;
      --muted-rgb: 127, 230, 193;
      --glow: #43ffb4;
      --glow-rgb: 67, 255, 180;
      --accent: #ffb84a;
      --accent-rgb: 255, 184, 74;
      --border-rgb: 110, 255, 198;
      --panel-border-rgb: 103, 255, 190;
      --danger: #ff4d6d;
      --danger-rgb: 255, 77, 109;
      --panel: rgba(7, 18, 14, 0.85);
      --panel-border: rgba(var(--panel-border-rgb), 0.3);
      --scanline: rgba(10, 26, 20, 0.35);
      --input-bg: #040b08;
      --timeline-bg: rgba(4, 10, 8, 0.65);
      --button-bg: linear-gradient(120deg, rgba(7, 32, 20, 0.9), rgba(8, 64, 40, 0.9));
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 800px at 20% 20%, var(--bg-2) 0%, var(--bg) 45%, var(--bg-3) 100%);
      background-repeat: no-repeat;
      background-attachment: fixed;
      background-size: cover;
      color: var(--text);
      font-family: "Share Tech Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      letter-spacing: 0.02em;
    }

    body::before {
      content: "";
      position: fixed;
      inset: -25%;
      background:
        repeating-linear-gradient(180deg, transparent 0px, transparent 2px, var(--scanline) 3px),
        radial-gradient(800px 600px at 70% 10%, rgba(var(--glow-rgb), 0.15), transparent 60%),
        radial-gradient(700px 500px at 10% 80%, rgba(var(--accent-rgb), 0.15), transparent 60%);
      mix-blend-mode: screen;
      opacity: 0.6;
      pointer-events: none;
      animation: scan 7s linear infinite;
      will-change: transform;
    }

    body::after {
      content: "";
      position: fixed;
      inset: -25%;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 120 120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='0.12'/%3E%3C/svg%3E");
      opacity: 0.2;
      pointer-events: none;
      mix-blend-mode: soft-light;
      will-change: transform;
    }

    @keyframes scan {
      0% { transform: translateY(-2%); }
      100% { transform: translateY(2%); }
    }

    .frame {
      min-height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px 20px;
    }

    .console {
      width: min(1200px, 100%);
      border: 2px solid var(--panel-border);
      background: var(--panel);
      box-shadow: 0 0 30px rgba(var(--glow-rgb), 0.2), 0 0 90px rgba(var(--glow-rgb), 0.15);
      padding: 28px;
      position: relative;
      overflow: visible;
    }

    .progression-panel {
      position: relative;
      overflow: visible;
    }

    .progression-panel::before {
      content: "";
      position: absolute;
      inset: -10px;
      border: 1px dashed rgba(var(--glow-rgb), 0.2);
      pointer-events: none;
      z-index: 0;
    }

    .song-mode #chordPanel.progression-panel::before {
      opacity: 0;
    }

    .progression-panel > * {
      position: relative;
      z-index: 1;
    }

    .header {
      display: flex;
      flex-wrap: nowrap;
      align-items: center;
      justify-content: flex-start;
      gap: 4px;
      margin-bottom: 24px;
    }

    .title {
      font-family: "Press Start 2P", system-ui, sans-serif;
      font-size: clamp(18px, 2vw, 26px);
      text-transform: uppercase;
      text-shadow: 0 0 10px var(--glow), 0 0 20px rgba(var(--glow-rgb), 0.4);
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 0 0 auto;
      white-space: nowrap;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 12px;
      color: var(--muted);
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 10px var(--accent);
      animation: pulse 1.8s ease-in-out infinite;
    }

    .title-dot {
      flex: none;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 0.6; }
      50% { transform: scale(1.4); opacity: 1; }
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(210px, 0.9fr) 2.1fr;
      gap: 16px;
    }

    .song-mode .grid {
      grid-template-columns: minmax(220px, 0.9fr) 2.1fr;
      align-items: start;
      row-gap: 0;
      column-gap: 16px;
    }

    .song-mode #chordPanel {
      grid-column: 1;
      grid-row: 1;
    }

    .song-mode #bassPanel {
      grid-column: 1;
      grid-row: 2;
    }

    .song-mode #melodyPanel {
      grid-column: 1;
      grid-row: 3;
    }

    .song-mode #drumPanel {
      grid-column: 1;
      grid-row: 4;
    }

    .song-mode #timelinePanel {
      grid-column: 2;
      grid-row: 1 / span 4;
    }

    .panel {
      border: 1px solid var(--panel-border);
      padding: 12px;
      background: var(--panel);
      box-shadow: inset 0 0 20px rgba(var(--glow-rgb), 0.15);
      min-width: 0;
    }

    .reset-button {
      position: fixed;
      top: 10px;
      right: 14px;
      z-index: 20;
    }

    .panel h2 {
      margin: 0 0 10px;
      font-size: 11px;
      color: var(--muted);
      letter-spacing: 0.2em;
      text-transform: uppercase;
    }

    .panel .button-row + h2 {
      margin-top: 6px;
    }

    .panel-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
    }

    .panel-top h2 {
      margin: 0;
    }

    .panel-top-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .volume-control {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 9px;
      color: var(--muted);
    }

    .volume-control input[type="range"] {
      width: 70px;
    }

    .midi-on .volume-control {
      display: none;
    }

    .header-button {
      padding: 4px 8px;
      font-size: 11px;
      letter-spacing: 0.2em;
    }

    .icon-toggle {
      padding: 4px 6px;
      font-size: 12px;
      line-height: 1;
      letter-spacing: 0;
      text-transform: none;
    }

    .icon-toggle[aria-pressed="true"] {
      border-color: rgba(var(--danger-rgb, 255, 77, 109), 0.8);
      color: rgba(var(--danger-rgb, 255, 77, 109), 1);
    }

    .panel-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 6px;
    }

    .panel-actions:empty {
      display: none;
      margin-bottom: 0;
    }

    .song-only {
      display: none;
    }

    .song-mode .song-only {
      display: grid;
    }

    .panel.collapsed .controls {
      display: none;
    }

    .panel.collapsed .panel-actions {
      margin-bottom: 0;
    }

    .song-mode .panel.collapsed {
      padding-bottom: 0;
    }

    .song-mode .panel.collapsed .panel-top {
      margin-bottom: 0;
    }

    .song-mode .panel.collapsed + .panel.collapsed {
      margin-top: -1px;
      border-top: 0;
    }

    .song-mode .panel.align-track {
      transform: translateY(var(--track-shift, 0px));
    }

    .help-button {
      position: fixed;
      right: 22px;
      bottom: 22px;
      z-index: 10;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--panel);
      color: var(--text);
      padding: 10px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 0 14px rgba(var(--glow-rgb), 0.2);
    }

    .help-button:hover {
      box-shadow: 0 0 18px rgba(var(--glow-rgb), 0.35);
    }

    .song-controls {
      position: fixed;
      left: 22px;
      bottom: 22px;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .song-toggle {
      position: static;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--panel);
      color: var(--text);
      padding: 10px 14px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 0 14px rgba(var(--glow-rgb), 0.2);
    }

    .song-toggle:hover {
      box-shadow: 0 0 18px rgba(var(--glow-rgb), 0.35);
    }

    .history-button {
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--panel);
      color: var(--text);
      padding: 10px 12px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.2);
      min-width: 40px;
    }

    .history-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      box-shadow: none;
    }

    .theme-control {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 9;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--panel);
      border: 1px solid rgba(var(--border-rgb), 0.45);
      border-radius: 6px;
      color: var(--muted);
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.25);
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .theme-control input[type="range"] {
      width: 180px;
    }

    .theme-control .theme-readout {
      display: none;
    }

    @media (max-width: 700px) {
      .theme-control {
        width: calc(100% - 120px);
        justify-content: space-between;
      }

      .theme-control input[type="range"] {
        flex: 1;
        width: auto;
      }

      .theme-control .theme-readout {
        display: none;
      }
    }

    .help-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 5, 0.85);
      z-index: 20;
      padding: 24px;
    }

    .help-modal.active {
      display: flex;
    }

    .help-terminal {
      width: min(720px, 100%);
      max-height: min(70vh, 520px);
      background: var(--bg-3);
      border: 1px solid rgba(var(--border-rgb), 0.4);
      box-shadow: 0 0 24px rgba(var(--glow-rgb), 0.3);
      padding: 16px 18px;
      font-size: 12px;
      line-height: 1.6;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .help-terminal h3 {
      margin: 0 0 10px;
      font-size: 12px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--muted);
    }

    .help-terminal pre {
      margin: 0;
      white-space: pre-wrap;
      color: var(--text);
      overflow-y: auto;
      max-height: 52vh;
      padding-right: 6px;
    }

    .help-terminal pre {
      scrollbar-width: thin;
      scrollbar-color: rgba(var(--glow-rgb), 0.7) rgba(var(--border-rgb), 0.15);
    }

    .help-terminal pre::-webkit-scrollbar {
      width: 8px;
    }

    .help-terminal pre::-webkit-scrollbar-track {
      background: rgba(var(--border-rgb), 0.15);
      border-radius: 6px;
    }

    .help-terminal pre::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, rgba(var(--glow-rgb), 0.8), rgba(var(--accent-rgb), 0.5));
      border-radius: 6px;
      border: 1px solid rgba(var(--border-rgb), 0.3);
    }

    .route-modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 5, 0.8);
      z-index: 18;
      padding: 24px;
    }

    .route-modal.active {
      display: flex;
    }

    .route-panel {
      width: min(420px, 100%);
      background: var(--panel);
      border: 1px solid rgba(var(--border-rgb), 0.4);
      box-shadow: 0 0 20px rgba(var(--glow-rgb), 0.25);
      padding: 16px;
      font-size: 12px;
    }

    .route-panel h3 {
      margin: 0 0 10px;
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.15em;
    }

    .route-panel label {
      margin-bottom: 10px;
    }

    .route-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 8px;
    }

    .help-cursor {
      display: inline-block;
      width: 10px;
      height: 1em;
      margin-left: 2px;
      border-left: 2px solid var(--text);
      background: transparent;
      vertical-align: -2px;
      animation: blink 1s steps(2, start) infinite;
    }

    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    .help-actions {
      display: flex;
      justify-content: flex-end;
      margin-top: 14px;
    }

    .controls {
      display: grid;
      gap: 6px;
      min-width: 0;
    }

    label {
      display: grid;
      gap: 3px;
      font-size: 9px;
      color: var(--muted);
      min-width: 0;
    }


    .label-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }

    .genre-row {
      display: flex;
      gap: 6px;
      min-width: 0;
    }

    .genre-row select {
      flex: 1;
      min-width: 0;
      max-width: 100%;
    }

    .blend-toggle-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-top: 4px;
    }

    .blend-add {
      display: none;
    }

    .blend-selects {
      display: none;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-top: 6px;
    }

    .blend-selects .blend-select {
      width: 100%;
    }

    .blend-mode .blend-add {
      display: inline-flex;
    }

    .blend-mode #genreRow {
      display: none;
    }

    .blend-mode .blend-selects {
      display: grid;
    }

    input, select, button {
      font-family: inherit;
      font-size: 12px;
    }

    input[type="range"], input[type="number"], input[type="text"], select {
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid rgba(var(--border-rgb), 0.3);
      padding: 3px 5px;
      border-radius: 4px;
      outline: none;
      max-width: 100%;
    }

    select {
      width: 100%;
    }

    input[type="range"] {
      accent-color: var(--glow);
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 1px;
    }

    .action-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .copy-small {
      padding: 6px 12px;
      font-size: 10px;
      letter-spacing: 0.1em;
    }

    .action-toggle {
      padding: 6px 12px;
      font-size: 10px;
      letter-spacing: 0.12em;
    }

    .midi-velocity {
      display: none;
      align-items: center;
      gap: 6px;
      font-size: 9px;
      color: var(--muted);
      padding: 2px 4px;
      border: 1px solid rgba(var(--border-rgb), 0.2);
      border-radius: 4px;
    }

    .midi-on .midi-velocity {
      display: flex;
    }

    .tempo-inline {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 9px;
      color: var(--muted);
      padding: 2px 4px;
      border: 1px solid rgba(var(--border-rgb), 0.2);
      border-radius: 4px;
    }

    .tempo-inline input[type="range"] {
      width: 120px;
    }

    .tempo-inline input[type="number"] {
      width: 64px;
      padding: 4px 6px;
      border-radius: 4px;
      text-align: right;
      accent-color: var(--glow);
      caret-color: var(--glow);
      color-scheme: dark;
    }

    .tempo-inline input[type="number"]::-webkit-inner-spin-button,
    .tempo-inline input[type="number"]::-webkit-outer-spin-button {
      opacity: 0;
      filter: drop-shadow(0 0 4px rgba(var(--glow-rgb), 0.6));
      background: linear-gradient(180deg, rgba(var(--glow-rgb), 0.35), rgba(var(--accent-rgb), 0.2));
      border-left: 1px solid rgba(var(--border-rgb), 0.35);
    }

    .tempo-inline input[type="number"]:hover::-webkit-inner-spin-button,
    .tempo-inline input[type="number"]:hover::-webkit-outer-spin-button,
    .tempo-inline input[type="number"]:focus::-webkit-inner-spin-button,
    .tempo-inline input[type="number"]:focus::-webkit-outer-spin-button {
      opacity: 0.85;
    }

    .tempo-readout {
      color: var(--text);
      font-size: 10px;
      min-width: 56px;
      text-align: right;
    }

    .small-toggle {
      padding: 4px 8px;
      font-size: 9px;
      letter-spacing: 0.14em;
    }

    .midi-route {
      display: none;
    }

    .midi-on .midi-route {
      display: inline-flex;
      align-items: center;
    }

    .bass-panel {
      display: none;
    }

    .song-mode .bass-panel {
      display: block;
    }

    .melody-panel {
      display: none;
    }

    .song-mode .melody-panel {
      display: block;
    }

    .drum-panel {
      display: none;
    }

    .song-mode .drum-panel {
      display: block;
    }

    .midi-velocity input[type="range"] {
      width: 110px;
    }

    .midi-velocity-value {
      color: var(--text);
      font-size: 10px;
      min-width: 22px;
      text-align: right;
    }

    button {
      border: 1px solid rgba(var(--border-rgb), 0.5);
      background: var(--button-bg);
      color: var(--text);
      padding: 5px 8px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.35);
    }

    button.secondary {
      border-color: rgba(var(--accent-rgb), 0.6);
      color: var(--accent);
    }


    .readout {
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .readout.inline {
      margin-top: 0;
      font-size: 10px;
      color: var(--text);
    }

    .timeline-view {
      --beat-px: 34px;
      --bar-px: calc(var(--beat-px) * 4);
      border: 1px solid rgba(var(--border-rgb), 0.3);
      background: var(--timeline-bg);
      width: 100%;
      max-width: 100%;
      position: relative;
      overflow-x: hidden;
      overflow-y: hidden;
      padding-bottom: 6px;
      scrollbar-gutter: stable;
    }

    .selection-box {
      position: absolute;
      border: 1px dashed rgba(var(--accent-rgb), 0.85);
      background: rgba(var(--accent-rgb), 0.12);
      box-shadow: 0 0 10px rgba(var(--accent-rgb), 0.2);
      pointer-events: none;
      z-index: 3;
    }

    .ruler {
      position: relative;
      height: 32px;
      border-bottom: 1px solid rgba(var(--border-rgb), 0.25);
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.35) 0, rgba(var(--glow-rgb), 0.35) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.12) 0, rgba(var(--glow-rgb), 0.12) 1px, transparent 1px, transparent var(--beat-px));
    }

    .bar-label {
      position: absolute;
      top: 7px;
      font-size: 10px;
      color: var(--muted);
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .form-lane {
      position: relative;
      height: 26px;
      border-bottom: 1px solid rgba(var(--border-rgb), 0.35);
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.2) 0, rgba(var(--glow-rgb), 0.2) 1px, transparent 1px, transparent var(--bar-px));
    }

    .form-lane.hidden {
      display: none;
    }

    .hidden {
      display: none;
    }

    .form-block {
      position: absolute;
      top: 2px;
      height: 22px;
      border: 1px solid rgba(var(--accent-rgb), 0.55);
      background: rgba(var(--accent-rgb), 0.16);
      color: var(--text);
      font-size: 10px;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      padding: 0 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      box-shadow: inset 0 0 10px rgba(var(--accent-rgb), 0.2);
    }

    .track {
      position: relative;
      height: 140px;
      border-bottom: 1px solid rgba(var(--border-rgb), 0.5);
      box-shadow: inset 0 -1px 0 rgba(var(--accent-rgb), 0.22);
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.3) 0, rgba(var(--glow-rgb), 0.3) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.08) 0, rgba(var(--glow-rgb), 0.08) 1px, transparent 1px, transparent var(--beat-px));
    }

    .track + .track {
      border-top: 1px solid rgba(var(--border-rgb), 0.5);
      box-shadow: inset 0 1px 0 rgba(var(--accent-rgb), 0.22);
    }

    .clip {
      position: absolute;
      top: 32px;
      height: 64px;
      border: 1px solid rgba(var(--border-rgb), 0.55);
      border-left-width: 2px;
      border-left-color: rgba(var(--accent-rgb), 0.8);
      background: linear-gradient(135deg, rgba(var(--glow-rgb), 0.2), rgba(4, 10, 8, 0.75));
      color: var(--text);
      padding: 8px 10px;
      text-shadow: 0 0 6px rgba(var(--glow-rgb), 0.5);
      box-shadow: 0 0 12px rgba(var(--glow-rgb), 0.2);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .clip.active {
      border-color: rgba(var(--accent-rgb), 0.95);
      box-shadow: 0 0 18px rgba(var(--accent-rgb), 0.35);
    }

    .clip.selected,
    .bass-clip.selected,
    .melody-clip.selected,
    .drum-clip.selected {
      border-color: rgba(var(--accent-rgb), 0.9);
      box-shadow: 0 0 16px rgba(var(--accent-rgb), 0.45);
    }

    .clip-title {
      font-size: 12px;
      margin-bottom: 0;
    }

    .bass-track {
      display: none;
      height: 64px;
      margin-top: 8px;
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.22) 0, rgba(var(--glow-rgb), 0.22) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.06) 0, rgba(var(--glow-rgb), 0.06) 1px, transparent 1px, transparent var(--beat-px));
    }

    .song-mode .bass-track {
      display: block;
    }

    .melody-track {
      display: none;
      height: 86px;
      margin-top: 8px;
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.22) 0, rgba(var(--glow-rgb), 0.22) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.06) 0, rgba(var(--glow-rgb), 0.06) 1px, transparent 1px, transparent var(--beat-px));
    }

    .song-mode .melody-track {
      display: block;
    }

    .drum-track {
      display: none;
      height: 74px;
      margin-top: 8px;
      background-image:
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.18) 0, rgba(var(--glow-rgb), 0.18) 1px, transparent 1px, transparent var(--bar-px)),
        repeating-linear-gradient(90deg, rgba(var(--glow-rgb), 0.05) 0, rgba(var(--glow-rgb), 0.05) 1px, transparent 1px, transparent var(--beat-px));
    }

    .song-mode .drum-track {
      display: block;
    }

    .bass-clip {
      position: absolute;
      top: 0;
      height: 18px;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      border-left-width: 2px;
      border-left-color: rgba(var(--accent-rgb), 0.7);
      background: linear-gradient(135deg, rgba(var(--accent-rgb), 0.18), rgba(0, 0, 0, 0));
      color: var(--text);
      padding: 2px 5px;
      font-size: 9px;
      line-height: 1.1;
      text-shadow: 0 0 4px rgba(var(--glow-rgb), 0.4);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .bass-clip.active {
      border-color: rgba(var(--muted-rgb), 0.95);
      box-shadow: 0 0 12px rgba(var(--muted-rgb), 0.35);
      background: linear-gradient(135deg, rgba(var(--muted-rgb), 0.35), rgba(0, 0, 0, 0));
    }

    .melody-clip {
      position: absolute;
      top: 0;
      height: 20px;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      border-left-width: 2px;
      border-left-color: rgba(var(--glow-rgb), 0.7);
      background: linear-gradient(135deg, rgba(var(--glow-rgb), 0.22), rgba(0, 0, 0, 0));
      color: var(--text);
      padding: 2px 5px;
      font-size: 9px;
      line-height: 1.1;
      text-shadow: 0 0 4px rgba(var(--glow-rgb), 0.4);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .melody-clip.active {
      border-color: rgba(var(--glow-rgb), 0.95);
      box-shadow: 0 0 14px rgba(var(--glow-rgb), 0.45);
      background: linear-gradient(135deg, rgba(var(--glow-rgb), 0.45), rgba(0, 0, 0, 0));
    }

    .drum-clip {
      position: absolute;
      top: 0;
      height: 16px;
      border: 1px solid rgba(var(--border-rgb), 0.5);
      border-left-width: 2px;
      border-left-color: rgba(var(--muted-rgb), 0.85);
      background: linear-gradient(135deg, rgba(var(--muted-rgb), 0.24), rgba(0, 0, 0, 0));
      color: var(--text);
      padding: 2px 4px;
      font-size: 9px;
      line-height: 1.1;
      text-shadow: 0 0 4px rgba(var(--glow-rgb), 0.4);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    .drum-clip.active {
      border-color: rgba(var(--muted-rgb), 0.95);
      box-shadow: 0 0 12px rgba(var(--muted-rgb), 0.45);
      background: linear-gradient(135deg, rgba(var(--muted-rgb), 0.4), rgba(0, 0, 0, 0));
    }

    .timeline-scroll {
      margin-top: 10px;
    }

    .timeline-scroll input[type="range"] {
      width: 100%;
    }

    .text-export {
      margin-top: 12px;
      display: grid;
      gap: 10px;
    }

    .text-export textarea {
      width: 100%;
      min-height: 80px;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid rgba(var(--border-rgb), 0.3);
      padding: 8px 10px;
      border-radius: 4px;
      resize: vertical;
    }

    .progression-highlight {
      display: block;
      border: 1px solid rgba(var(--border-rgb), 0.3);
      background: var(--input-bg);
      padding: 10px;
      border-radius: 4px;
      font-size: 12px;
      line-height: 1.6;
      color: var(--text);
      white-space: pre-wrap;
    }

    .progression-highlight mark {
      background: rgba(var(--accent-rgb), 0.25);
      color: var(--text);
      padding: 0 2px;
      border-radius: 3px;
      box-shadow: 0 0 8px rgba(var(--accent-rgb), 0.3);
    }

    .oscilloscope {
      width: 100%;
      height: 60px;
      border: none;
      background: transparent;
      box-shadow: none;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .playing .oscilloscope {
      opacity: 1;
      visibility: visible;
    }

    .oscilloscope.inline {
      flex: 1 1 auto;
      min-width: 120px;
    }

    .footer {
      margin-top: 18px;
      font-size: 11px;
      color: rgba(var(--muted-rgb), 0.7);
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }

      .song-mode .grid {
        grid-template-columns: minmax(180px, 0.9fr) 2fr;
      }

      .track {
        height: 160px;
      }

      .clip {
        height: 70px;
      }

      .bass-track {
        height: 56px;
      }

      .bass-clip {
        height: 26px;
        top: 12px;
      }

      .melody-track {
        height: 72px;
      }

      .melody-clip {
        height: 22px;
      }

      .drum-track {
        height: 64px;
      }

      .drum-clip {
        height: 14px;
      }
    }
  </style>
</head>
<body>
  <div class="frame">
    <div class="console">
      <div class="header">
        <div class="title">
          <span id="titleLeft">¢hange</span>
          <span class="dot title-dot" aria-hidden="true"></span>
          <span id="titleRight">machine</span>
        </div>
        <canvas id="oscilloscope" class="oscilloscope inline"></canvas>
      </div>
      <button id="resetAll" class="secondary reset-button">Reset</button>

      <div class="grid">
        <section class="panel progression-panel" id="chordPanel">
          <div class="panel-top">
            <button id="generate" class="header-button">¢hords</button>
            <div class="panel-top-actions">
              <div class="volume-control">
                <span>VOL</span>
                <input id="chordVolume" type="range" min="0" max="200" value="100" />
              </div>
              <button id="chordLoopMode" class="secondary small-toggle">Loop</button>
              <button id="chordMute" class="secondary icon-toggle" aria-pressed="false" title="Mute chords">M</button>
              <button id="chordCollapse" class="secondary">▾</button>
            </div>
          </div>
          <div class="controls">
            <label>
              Key center
              <select id="keySelect"></select>
            </label>
            <label>
              Genre
              <div class="genre-row" id="genreRow">
                <select id="genreMain"></select>
                <select id="genreSub"></select>
              </div>
            </label>
            <div class="blend-toggle-row">
              <button id="blendToggle" class="secondary small-toggle" type="button">Blend</button>
              <button id="blendAdd" class="secondary small-toggle blend-add" type="button">+</button>
            </div>
            <div id="blendSelects" class="blend-selects"></div>
            <label>
              Bars
              <input id="bars" type="range" min="4" max="32" value="4" />
              <span class="readout" id="barsReadout">4 bars</span>
            </label>
            <label>
              <div class="label-row">
                <span>Form</span>
                <button id="formToggle" class="secondary small-toggle" type="button" aria-pressed="false">Off</button>
                <span class="readout inline" id="formComplexityReadout">30%</span>
              </div>
              <input id="formComplexity" type="range" min="0" max="100" value="30" />
            </label>
            <label>
              <div class="label-row">
                <span>Harmonic density</span>
                <span class="readout inline" id="densityReadout">50%</span>
              </div>
              <input id="density" type="range" min="0" max="100" value="15" />
            </label>
            <label>
              <div class="label-row">
                <span>Color</span>
                <span class="readout inline" id="colorReadout">50%</span>
              </div>
              <input id="color" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Modulation amount</span>
                <span class="readout inline" id="modulationReadout">15%</span>
              </div>
              <input id="modulation" type="range" min="0" max="100" value="15" />
            </label>
            <label>
              <div class="label-row">
                <span>Subdivision density</span>
                <span class="readout inline" id="subdivisionDensityReadout">20%</span>
              </div>
              <input id="subdivisionDensity" type="range" min="0" max="100" value="20" />
            </label>
            <label>
              Subdivision mode
              <select id="subdivision">
                <option value="even">Even only</option>
                <option value="mixed">Even + triplet</option>
              </select>
            </label>
            <label>
              Backing
              <select id="backingStyle"></select>
            </label>
            <label class="backing-comp hidden" id="backingCompWrap">
              <div class="label-row">
                <span>Backing complexity</span>
                <span class="readout inline" id="backingCompReadout">50%</span>
              </div>
              <input id="backingComp" type="range" min="0" max="100" value="50" />
            </label>
            <label class="song-only">
              ch
              <select id="chordChannel"></select>
            </label>
            <div class="button-row">
              <button id="randomSettings" class="secondary">Random</button>
            </div>
          </div>
        </section>

        <section class="panel bass-panel" id="bassPanel">
          <div class="panel-top">
            <button id="bassGenerate" class="header-button">฿ass</button>
            <div class="panel-top-actions">
              <div class="volume-control">
                <span>VOL</span>
                <input id="bassVolume" type="range" min="0" max="200" value="100" />
              </div>
              <button id="bassLoopMode" class="secondary small-toggle">Loop</button>
              <button id="bassMute" class="secondary icon-toggle" aria-pressed="false" title="Mute bass">M</button>
              <button id="bassCollapse" class="secondary">▾</button>
            </div>
          </div>
          <div class="controls bass-controls">
            <label>
              Bass genre
              <div class="genre-row">
                <select id="bassGenreMain"></select>
                <select id="bassGenreSub"></select>
              </div>
            </label>
            <label>
              <div class="label-row">
                <span>Bass density</span>
                <span class="readout inline" id="bassDensityReadout">55%</span>
              </div>
              <input id="bassDensity" type="range" min="0" max="100" value="55" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass movement</span>
                <span class="readout inline" id="bassMovementReadout">40%</span>
              </div>
              <input id="bassMovement" type="range" min="0" max="100" value="40" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass color</span>
                <span class="readout inline" id="bassColorReadout">50%</span>
              </div>
              <input id="bassColor" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass fills</span>
                <span class="readout inline" id="bassFillsReadout">50%</span>
              </div>
              <input id="bassFills" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass rests</span>
                <span class="readout inline" id="bassRestsReadout">50%</span>
              </div>
              <input id="bassRests" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Bass subdivision density</span>
                <span class="readout inline" id="bassSubdivisionDensityReadout">45%</span>
              </div>
              <input id="bassSubdivisionDensity" type="range" min="0" max="100" value="45" />
            </label>
            <label>
              Bass subdivision mode
              <select id="bassSubdivision">
                <option value="even">Even only</option>
                <option value="mixed">Even + triplet</option>
              </select>
            </label>
            <label>
              ch
              <select id="bassChannel"></select>
            </label>
            <label>
              Bass style
              <select id="bassStyle">
                <option value="auto">Auto (genre)</option>
                <option value="root">Root</option>
                <option value="octave">Root + octave</option>
                <option value="walk">Walking</option>
                <option value="arp">Arp</option>
              </select>
            </label>
            <label>
              Bass register
              <input id="bassRegister" type="range" min="28" max="52" value="36" />
              <span class="readout" id="bassRegisterReadout">C2</span>
            </label>
            <div class="button-row">
              <button id="bassRandom" class="secondary">Random bass</button>
            </div>
          </div>
        </section>

        <section class="panel melody-panel" id="melodyPanel">
          <div class="panel-top">
            <button id="melodyGenerate" class="header-button">₥elody</button>
            <div class="panel-top-actions">
              <div class="volume-control">
                <span>VOL</span>
                <input id="melodyVolume" type="range" min="0" max="200" value="100" />
              </div>
              <button id="melodyLoopMode" class="secondary small-toggle">Loop</button>
              <button id="melodyMute" class="secondary icon-toggle" aria-pressed="false" title="Mute melody">M</button>
              <button id="melodyCollapse" class="secondary">▾</button>
            </div>
          </div>
          <div class="controls melody-controls">
            <label>
              Melody genre
              <div class="genre-row">
                <select id="melodyGenreMain"></select>
                <select id="melodyGenreSub"></select>
              </div>
            </label>
            <label>
              <div class="label-row">
                <span>Melody density</span>
                <span class="readout inline" id="melodyDensityReadout">60%</span>
              </div>
              <input id="melodyDensity" type="range" min="0" max="100" value="60" />
            </label>
            <label>
              <div class="label-row">
                <span>Melody movement</span>
                <span class="readout inline" id="melodyMovementReadout">55%</span>
              </div>
              <input id="melodyMovement" type="range" min="0" max="100" value="55" />
            </label>
            <label>
              <div class="label-row">
                <span>Melody color</span>
                <span class="readout inline" id="melodyColorReadout">10%</span>
              </div>
              <input id="melodyColor" type="range" min="0" max="100" value="10" />
            </label>
            <label>
              <div class="label-row">
                <span>Melody fills</span>
                <span class="readout inline" id="melodyFillsReadout">45%</span>
              </div>
              <input id="melodyFills" type="range" min="0" max="100" value="45" />
            </label>
            <label>
              <div class="label-row">
                <span>Melody rests</span>
                <span class="readout inline" id="melodyRestsReadout">50%</span>
              </div>
              <input id="melodyRests" type="range" min="0" max="100" value="50" />
            </label>
            <label>
              <div class="label-row">
                <span>Melody subdivision density</span>
                <span class="readout inline" id="melodySubdivisionDensityReadout">55%</span>
              </div>
              <input id="melodySubdivisionDensity" type="range" min="0" max="100" value="55" />
            </label>
            <label>
              Melody subdivision mode
              <select id="melodySubdivision">
                <option value="even">Even only</option>
                <option value="mixed">Even + triplet</option>
              </select>
            </label>
            <label>
              ch
              <select id="melodyChannel"></select>
            </label>
            <label>
              Melody style
              <select id="melodyStyle">
                <option value="auto">Auto (genre)</option>
                <option value="step">Step</option>
                <option value="leap">Leap</option>
                <option value="arp">Arp</option>
                <option value="motif">Motif</option>
              </select>
            </label>
            <label>
              Melody register
              <input id="melodyRegister" type="range" min="60" max="84" value="72" />
              <span class="readout" id="melodyRegisterReadout">C5</span>
            </label>
            <div class="button-row">
              <button id="melodyRandom" class="secondary">Random melody</button>
            </div>
          </div>
        </section>

        <section class="panel drum-panel" id="drumPanel">
          <div class="panel-top">
            <button id="drumGenerate" class="header-button">Đrums</button>
            <div class="panel-top-actions">
              <div class="volume-control">
                <span>VOL</span>
                <input id="drumVolume" type="range" min="0" max="200" value="100" />
              </div>
              <button id="drumLoopMode" class="secondary small-toggle">Loop</button>
              <button id="drumMute" class="secondary icon-toggle" aria-pressed="false" title="Mute drums">M</button>
              <button id="drumCollapse" class="secondary">▾</button>
            </div>
          </div>
          <div class="controls drum-controls">
            <label>
              Drum genre
              <div class="genre-row">
                <select id="drumGenreMain"></select>
                <select id="drumGenreSub"></select>
              </div>
            </label>
            <label>
              <div class="label-row">
                <span>Drum density</span>
                <span class="readout inline" id="drumDensityReadout">55%</span>
              </div>
              <input id="drumDensity" type="range" min="0" max="100" value="55" />
            </label>
            <label>
              <div class="label-row">
                <span>Drum complexity</span>
                <span class="readout inline" id="drumComplexityReadout">45%</span>
              </div>
              <input id="drumComplexity" type="range" min="0" max="100" value="45" />
            </label>
            <label>
              <div class="label-row">
                <span>Drum fills</span>
                <span class="readout inline" id="drumFillsReadout">45%</span>
              </div>
              <input id="drumFills" type="range" min="0" max="100" value="45" />
            </label>
            <label>
              <div class="label-row">
                <span>Ghost notes</span>
                <span class="readout inline" id="drumGhostReadout">40%</span>
              </div>
              <input id="drumGhost" type="range" min="0" max="100" value="40" />
            </label>
            <label>
              <div class="label-row">
                <span>Drum velocity</span>
                <span class="readout inline" id="drumVelocityReadout">90%</span>
              </div>
              <input id="drumVelocity" type="range" min="0" max="100" value="90" />
            </label>
            <label>
              Drum style
              <select id="drumStyle">
                <option value="auto">Auto (genre)</option>
                <option value="rock">Rock</option>
                <option value="pop">Pop</option>
                <option value="funk">Funk</option>
                <option value="jazz">Jazz</option>
                <option value="hiphop">Hip-hop</option>
                <option value="blues">Blues</option>
                <option value="latin">Latin</option>
                <option value="electronic">Electronic</option>
                <option value="reggae">Reggae</option>
              </select>
            </label>
            <div class="button-row">
              <button id="drumRandom" class="secondary">Random drums</button>
            </div>
          </div>
        </section>

        <section class="panel" id="timelinePanel">
          <div class="button-row" id="mainActions">
            <button id="play">Play</button>
            <button id="download" class="secondary">Download .mid</button>
            <button id="midiToggle" class="secondary">MIDI Out</button>
            <button id="midiRoute" class="secondary midi-route">Route</button>
            <div class="midi-velocity">
              <span>Vel</span>
              <input id="midiVelocity" type="range" min="1" max="127" value="60" />
              <span id="midiVelocityValue" class="midi-velocity-value">60</span>
            </div>
            <div class="tempo-inline">
              <span>Tempo</span>
              <input id="tempo" type="range" min="40" max="200" value="75" step="0.1" />
              <input id="tempoNumber" type="number" min="40" max="240" step="0.1" value="75" />
            </div>
          </div>
          <h2>Progression</h2>
          <div id="timelineView" class="timeline-view">
            <div id="ruler" class="ruler"></div>
            <div id="formLane" class="form-lane hidden"></div>
            <div id="track" class="track chord-track"></div>
            <div id="bassTrack" class="track bass-track"></div>
            <div id="melodyTrack" class="track melody-track"></div>
            <div id="drumTrack" class="track drum-track"></div>
          </div>
          <div class="timeline-scroll">
            <input id="timelineScroll" type="range" min="0" max="0" value="0" />
          </div>
          <div class="text-export">
            <label for="progressionHighlight">Chord text</label>
            <div id="progressionHighlight" class="progression-highlight" role="textbox" aria-readonly="true"></div>
            <textarea id="progressionText" readonly hidden></textarea>
            <div class="action-row">
              <button id="copyProgression" class="secondary copy-small">Copy progression</button>
              <button id="selectToggle" class="secondary action-toggle">Select</button>
            </div>
          </div>
          <div class="footer" id="footer"></div>
        </section>
      </div>
    </div>
  </div>

  <div class="song-controls">
    <button id="songToggle" class="song-toggle">$ong</button>
    <button id="undoButton" class="history-button" type="button" title="Undo">←</button>
    <button id="redoButton" class="history-button" type="button" title="Redo">→</button>
  </div>
  <div class="theme-control">
    <span>Theme</span>
    <input id="themeSlider" type="range" min="0" max="400" value="0" step="1" />
  </div>
  <button id="helpButton" class="help-button">?</button>
  <div id="routeModal" class="route-modal" aria-hidden="true">
    <div class="route-panel" role="dialog" aria-modal="true" aria-labelledby="routeTitle">
      <h3 id="routeTitle">MIDI Routing</h3>
      <label>
        MIDI Out
        <select id="midiOutSelect"></select>
      </label>
      <label>
        MIDI In (clock)
        <select id="midiInSelect"></select>
      </label>
      <div class="route-actions">
        <button id="routeClose" class="secondary">X</button>
      </div>
    </div>
  </div>
  <div id="helpModal" class="help-modal" aria-hidden="true">
    <div class="help-terminal" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
      <h3 id="helpTitle">¢hange.machine // operator manual</h3>
      <pre><span id="helpText"></span><span class="help-cursor" aria-hidden="true"></span></pre>
      <div class="help-actions">
        <button id="helpClose" class="secondary">X</button>
      </div>
    </div>
  </div>

  <script>
    const noteNames = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

    const degreeOffsets = {
      "I": 0,
      "i": 0,
      "ii": 2,
      "iii": 4,
      "IV": 5,
      "iv": 5,
      "V": 7,
      "v": 7,
      "vi": 9,
      "vii": 11,
      "bII": 1,
      "bIII": 3,
      "bVI": 8,
      "bVII": 10,
      "VI": 9,
      "#IV": 6
    };

    const qualities = {
      "maj": [0, 4, 7],
      "m": [0, 3, 7],
      "dim": [0, 3, 6],
      "dim7": [0, 3, 6, 9],
      "m7b5": [0, 3, 6, 10],
      "5": [0, 7, 12],
      "sus2": [0, 2, 7],
      "sus4": [0, 5, 7],
      "add9": [0, 4, 7, 14],
      "6": [0, 4, 7, 9],
      "m6": [0, 3, 7, 9],
      "6/9": [0, 4, 7, 9, 14],
      "7": [0, 4, 7, 10],
      "7sus4": [0, 5, 7, 10],
      "11": [0, 4, 7, 10, 14, 17],
      "9": [0, 4, 7, 10, 14],
      "m7": [0, 3, 7, 10],
      "m9": [0, 3, 7, 10, 14],
      "m11": [0, 3, 7, 10, 14, 17],
      "maj7": [0, 4, 7, 11],
      "maj9#11": [0, 4, 11, 14, 18],
      "maj9": [0, 4, 7, 11, 14],
      "maj13": [0, 4, 7, 11, 14, 21],
      "13b9": [0, 4, 10, 13, 21],
      "13": [0, 4, 10, 14, 21],
      "7alt": [0, 4, 10, 13, 18]
    };
    const qualityLabels = {
      "maj": "maj",
      "m": "m",
      "dim": "dim",
      "dim7": "dim7",
      "m7b5": "m7b5",
      "5": "5",
      "sus2": "sus2",
      "sus4": "sus4",
      "add9": "add9",
      "6": "6",
      "m6": "m6",
      "6/9": "6/9",
      "7": "7",
      "7sus4": "7sus4",
      "11": "11",
      "9": "9",
      "m7": "m7",
      "m9": "m9",
      "m11": "m11",
      "maj7": "maj7",
      "maj9#11": "maj9#11",
      "maj9": "maj9",
      "maj13": "maj13",
      "13b9": "13b9",
      "13": "13",
      "7alt": "7alt"
    };

    const colorQualityPools = {
      maj: {
        low: ["maj", "add9", "6"],
        lowmid: ["maj", "add9", "6/9", "maj7"],
        mid: ["maj7", "6/9", "maj9"],
        high: ["maj9", "maj9#11", "maj13"],
        ultra: ["maj9#11", "maj13"]
      },
      min: {
        low: ["m", "m6"],
        lowmid: ["m", "m6", "m7"],
        mid: ["m7", "m9"],
        high: ["m9", "m11"],
        ultra: ["m11", "m9"]
      },
      dom: {
        low: ["7", "7sus4"],
        lowmid: ["7", "9", "7sus4"],
        mid: ["9", "13", "11"],
        high: ["7alt", "13b9", "13", "11"],
        ultra: ["7alt", "13b9", "13", "11"]
      },
      dim: {
        low: ["dim"],
        lowmid: ["dim"],
        mid: ["dim7"],
        high: ["dim7"],
        ultra: ["dim7"]
      },
      halfdim: {
        low: ["m7b5"],
        lowmid: ["m7b5"],
        mid: ["m7b5"],
        high: ["m7b5"],
        ultra: ["m7b5"]
      },
      sus: {
        low: ["sus2", "sus4"],
        lowmid: ["sus4"],
        mid: ["sus4", "7sus4"],
        high: ["7sus4"],
        ultra: ["7sus4"]
      },
      power: {
        low: ["5"],
        lowmid: ["5"],
        mid: ["5"],
        high: ["5"],
        ultra: ["5"]
      }
    };

    function getQualityFamily(quality) {
      if (["maj", "maj7", "maj9", "maj9#11", "maj13", "6", "6/9", "add9"].includes(quality)) return "maj";
      if (["m", "m7", "m9", "m11", "m6"].includes(quality)) return "min";
      if (["7", "9", "11", "13", "13b9", "7alt", "7sus4"].includes(quality)) return "dom";
      if (["dim", "dim7"].includes(quality)) return "dim";
      if (["m7b5"].includes(quality)) return "halfdim";
      if (["sus2", "sus4"].includes(quality)) return "sus";
      if (["5"].includes(quality)) return "power";
      return "maj";
    }

    function applyColorToQuality(quality, colorPercent, colorSeed) {
      if (!qualities[quality]) return quality;
      const family = getQualityFamily(quality);
      const pools = colorQualityPools[family] || colorQualityPools.maj;
      const tiers = ["low", "lowmid", "mid", "high", "ultra"];
      const rng = makeRng(`${colorSeed}|${quality}`);
      const base = (Math.max(0, Math.min(100, colorPercent)) / 100) * (tiers.length - 1);
      const jitter = (rng() - 0.5) * 0.9;
      const tierIndex = Math.max(0, Math.min(tiers.length - 1, Math.round(base + jitter)));
      const tier = tiers[tierIndex];
      const options = pools[tier] && pools[tier].length ? pools[tier] : [quality];
      return options[Math.floor(rng() * options.length)];
    }

    const genreProfiles = {
      base: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 0,
        subdivisionBias: 0,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9#11" },
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m9" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "iv", quality: "m9" },
            { degree: "iii", quality: "m9" }
          ],
          dominant: [
            { degree: "V", quality: "13b9" },
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "bVII", quality: "13" },
            { degree: "VI", quality: "7alt" }
          ]
        }
      },
      jazz: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "iv", quality: "m7" },
            { degree: "iii", quality: "m7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" },
            { degree: "bII", quality: "7alt" }
          ]
        }
      },
      baroque: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -25,
        subdivisionBias: -0.25,
        functions: {
          tonic: [
            { degree: "I", quality: "maj" },
            { degree: "vi", quality: "m" },
            { degree: "iii", quality: "m" }
          ],
          predom: [
            { degree: "ii", quality: "m" },
            { degree: "IV", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "maj" },
            { degree: "vii", quality: "dim" }
          ]
        }
      },
      classical: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "maj" },
            { degree: "vi", quality: "m" },
            { degree: "iii", quality: "m" }
          ],
          predom: [
            { degree: "ii", quality: "m" },
            { degree: "IV", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "vii", quality: "dim" },
            { degree: "V", quality: "maj" }
          ]
        }
      },
      neoclassical: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m9" },
            { degree: "bVI", quality: "maj" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj7" },
            { degree: "bII", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13b9" }
          ]
        }
      },
      rock: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "V", "IV"],
          ["I", "bVII", "IV", "I"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["5", "maj"],
          "IV": ["5", "maj"],
          "V": ["5", "7"],
          "vi": ["m", "m7"],
          "bVII": ["5", "maj"]
        }
      },
      metal: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: -0.05,
        templates: [
          ["i", "bVI", "bVII", "i"],
          ["i", "bII", "i", "bVII"],
          ["i", "bVI", "i", "bVII"],
          ["i", "bII", "bIII", "bII"]
        ],
        degreeQualities: {
          "i": ["5", "m"],
          "bII": ["5", "maj"],
          "bIII": ["5", "maj"],
          "bVI": ["5", "maj"],
          "bVII": ["5", "maj"]
        }
      },
      punk: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -30,
        subdivisionBias: -0.35,
        templates: [
          ["I", "IV", "V", "IV"],
          ["I", "bVII", "IV", "V"],
          ["I", "V", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["5"],
          "IV": ["5"],
          "V": ["5"],
          "bVII": ["5"]
        }
      },
      pop: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 0,
        subdivisionBias: -0.05,
        templates: [
          ["I", "V", "vi", "IV"],
          ["vi", "IV", "I", "V"],
          ["I", "vi", "IV", "V"],
          ["IV", "V", "iii", "vi"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"],
          "iii": ["m"],
          "ii": ["m"]
        }
      },
      "synth-pop": {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: -0.05,
        templates: [
          ["I", "V", "vi", "IV"],
          ["vi", "IV", "I", "V"],
          ["I", "V", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9", "sus2"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"]
        }
      },
      "indie-pop": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.1,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "vi", "V"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9", "maj7"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9", "maj7"]
        }
      },
      "dream-pop": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        templates: [
          ["I", "vi", "IV", "I"],
          ["I", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"],
          "V": ["sus4", "maj"]
        }
      },
      blues: {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: 0.05,
        bluesBars: [
          { base: "I", passing: ["VI", "ii"] },
          { base: "IV", passing: ["I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["#IV", "IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["IV", "ii"] },
          { base: "IV", passing: ["I", "ii"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["I", "bII"] }
        ],
        bluesQualityMap: {
          "I": ["7", "9"],
          "IV": ["7", "9"],
          "V": ["7", "9", "13"],
          "VI": ["7"],
          "ii": ["m7"],
          "#IV": ["dim7"],
          "bII": ["7alt"]
        }
      },
      "chicago-blues": {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        bluesBars: [
          { base: "I", passing: ["IV", "VI"] },
          { base: "IV", passing: ["I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["#IV", "IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "IV", passing: ["IV", "I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["IV", "ii"] },
          { base: "IV", passing: ["I", "ii"] },
          { base: "I", passing: ["VI", "ii"] },
          { base: "V", passing: ["I", "bII"] }
        ],
        bluesQualityMap: {
          "I": ["9", "13"],
          "IV": ["9"],
          "V": ["9", "13"],
          "VI": ["7"],
          "ii": ["m7"],
          "#IV": ["dim7"],
          "bII": ["7alt"]
        }
      },
      "delta-blues": {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 0,
        subdivisionBias: 0,
        bluesBars: [
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["IV"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["#IV", "IV"] },
          { base: "IV", passing: ["IV"] },
          { base: "IV", passing: ["I"] },
          { base: "I", passing: ["VI"] },
          { base: "I", passing: ["VI"] },
          { base: "V", passing: ["bVII"] },
          { base: "bVII", passing: ["IV"] },
          { base: "I", passing: ["VI"] },
          { base: "V", passing: ["I"] }
        ],
        bluesQualityMap: {
          "I": ["7"],
          "IV": ["7"],
          "V": ["7", "9"],
          "VI": ["7"],
          "bVII": ["7"],
          "#IV": ["dim7"]
        }
      },
      "minor-blues": {
        type: "blues",
        allowTriplets: true,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: 0.05,
        bluesBars: [
          { base: "i", passing: ["bVI"] },
          { base: "iv", passing: ["i"] },
          { base: "i", passing: ["bVI"] },
          { base: "i", passing: ["#IV", "iv"] },
          { base: "iv", passing: ["iv"] },
          { base: "iv", passing: ["i"] },
          { base: "i", passing: ["bVI"] },
          { base: "i", passing: ["bVI"] },
          { base: "V", passing: ["iv"] },
          { base: "iv", passing: ["i"] },
          { base: "i", passing: ["bVI"] },
          { base: "V", passing: ["i"] }
        ],
        bluesQualityMap: {
          "i": ["m7", "m9"],
          "iv": ["m7"],
          "V": ["7", "9"],
          "bVI": ["maj7"],
          "#IV": ["dim7"]
        }
      },
      rnb: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" },
            { degree: "iii", quality: "m7" }
          ],
          dominant: [
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      soul: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "6/9" },
            { degree: "I", quality: "maj7" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" },
            { degree: "IV", quality: "6/9" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "bVII", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "7sus4" }
          ]
        }
      },
      "neo-soul": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 20,
        subdivisionBias: 0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "I", quality: "6/9" },
            { degree: "vi", quality: "m9" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj9" },
            { degree: "iii", quality: "m9" },
            { degree: "iv", quality: "m9" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13b9" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      funk: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "7" },
            { degree: "I", quality: "9" },
            { degree: "I", quality: "13" }
          ],
          predom: [
            { degree: "IV", quality: "7" },
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "9" }
          ],
          dominant: [
            { degree: "V", quality: "9" },
            { degree: "bVII", quality: "9" },
            { degree: "V", quality: "7sus4" }
          ]
        }
      },
      reggae: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -20,
        subdivisionBias: -0.25,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "bVII", "IV", "V"],
          ["I", "V", "IV", "I"]
        ],
        degreeQualities: {
          "I": ["maj", "sus2"],
          "V": ["maj", "sus4"],
          "vi": ["m"],
          "IV": ["maj", "sus2"],
          "bVII": ["maj"]
        }
      },
      calypso: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: 0.05,
        templates: [
          ["I", "V", "I", "V"],
          ["I", "bVII", "IV", "V"],
          ["I", "vi", "ii", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "6"],
          "V": ["7", "maj"],
          "vi": ["m"],
          "ii": ["m"],
          "IV": ["maj"],
          "bVII": ["maj"]
        }
      },
      ska: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        templates: [
          ["I", "IV", "V", "IV"],
          ["I", "bVII", "IV", "V"],
          ["I", "V", "IV", "I"]
        ],
        degreeQualities: {
          "I": ["maj", "6"],
          "IV": ["maj", "6"],
          "V": ["7", "maj"],
          "bVII": ["maj"]
        }
      },
      dancehall: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.15,
        templates: [
          ["i", "bVII", "bVI", "bVII"],
          ["i", "bVI", "bVII", "i"]
        ],
        degreeQualities: {
          "i": ["m", "m7"],
          "bVI": ["maj"],
          "bVII": ["maj"]
        }
      },
      prog: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 20,
        subdivisionBias: 0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "vi", quality: "m9" },
            { degree: "bVI", quality: "maj7" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj9" },
            { degree: "bII", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13" }
          ]
        }
      },
      americana: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -25,
        subdivisionBias: -0.3,
        templates: [
          ["I", "IV", "I", "V"],
          ["I", "V", "IV", "I"],
          ["I", "vi", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "IV": ["maj"],
          "V": ["maj", "sus4"],
          "vi": ["m"]
        }
      },
      bebop: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 20,
        subdivisionBias: 0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "ii", quality: "m7b5" },
            { degree: "iv", quality: "m7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" },
            { degree: "bII", quality: "7alt" },
            { degree: "VI", quality: "7" }
          ]
        }
      },
      "hard-bop": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "6/9" },
            { degree: "I", quality: "maj7" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "iv", quality: "m7" },
            { degree: "IV", quality: "7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "bVII", quality: "7" },
            { degree: "#IV", quality: "dim7" }
          ]
        }
      },
      "cool-jazz": {
        type: "functional",
        allowTriplets: true,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "maj9" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      "modal-jazz": {
        type: "template",
        allowTriplets: true,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: 0.1,
        templates: [
          ["i", "bVII", "IV", "i"],
          ["i", "IV", "bVII", "i"],
          ["i", "bVII", "i", "IV"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "bVII": ["7", "9"],
          "IV": ["7", "9"]
        }
      },
      fusion: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 25,
        subdivisionBias: 0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj9" },
            { degree: "I", quality: "maj9#11" },
            { degree: "vi", quality: "m9" }
          ],
          predom: [
            { degree: "ii", quality: "m9" },
            { degree: "IV", quality: "maj9" },
            { degree: "iii", quality: "m9" }
          ],
          dominant: [
            { degree: "V", quality: "7alt" },
            { degree: "bII", quality: "7alt" },
            { degree: "V", quality: "13b9" }
          ]
        }
      },
      lofi: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.2,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "6/9" },
            { degree: "vi", quality: "m7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      gospel: {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: 0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "6/9" },
            { degree: "I", quality: "maj7" }
          ],
          predom: [
            { degree: "IV", quality: "maj7" },
            { degree: "ii", quality: "m7" },
            { degree: "bVII", quality: "7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "V", quality: "7sus4" }
          ]
        }
      },
      bossa: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.05,
        templates: [
          ["ii", "V", "I", "VI"],
          ["ii", "V", "I", "I"]
        ],
        degreeQualities: {
          "ii": ["m7"],
          "V": ["7", "9"],
          "I": ["maj7", "6/9"],
          "VI": ["7"]
        }
      },
      "latin-jazz": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" },
            { degree: "I", quality: "6/9" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "9" },
            { degree: "V", quality: "13" }
          ]
        }
      },
      samba: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: 0.05,
        templates: [
          ["I", "vi", "ii", "V"],
          ["ii", "V", "I", "I"]
        ],
        degreeQualities: {
          "I": ["maj7", "6/9"],
          "vi": ["m7"],
          "ii": ["m7"],
          "V": ["7", "9"]
        }
      },
      swing: {
        type: "functional",
        allowTriplets: true,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "maj7" }
          ],
          predom: [
            { degree: "ii", quality: "m7" },
            { degree: "IV", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" }
          ]
        }
      },
      impressionist: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "add9" },
            { degree: "I", quality: "maj7" },
            { degree: "bVI", quality: "maj7" }
          ],
          predom: [
            { degree: "IV", quality: "add9" },
            { degree: "ii", quality: "m7" },
            { degree: "bII", quality: "maj7" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      romantic: {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.15,
        functions: {
          tonic: [
            { degree: "I", quality: "maj" },
            { degree: "vi", quality: "m" },
            { degree: "bIII", quality: "maj" }
          ],
          predom: [
            { degree: "ii", quality: "m" },
            { degree: "IV", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "vii", quality: "dim7" }
          ]
        }
      },
      "modern-classical": {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: 5,
        subdivisionBias: -0.05,
        functions: {
          tonic: [
            { degree: "I", quality: "add9" },
            { degree: "I", quality: "sus2" }
          ],
          predom: [
            { degree: "IV", quality: "sus2" },
            { degree: "ii", quality: "m7" },
            { degree: "bII", quality: "maj" }
          ],
          dominant: [
            { degree: "V", quality: "7sus4" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      folk: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -25,
        subdivisionBias: -0.35,
        templates: [
          ["I", "IV", "V", "I"],
          ["I", "V", "vi", "IV"],
          ["I", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj"],
          "IV": ["maj"],
          "V": ["maj"],
          "vi": ["m"]
        }
      },
      country: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -30,
        subdivisionBias: -0.35,
        templates: [
          ["I", "IV", "V", "I"],
          ["I", "V", "IV", "I"],
          ["I", "vi", "IV", "V"]
        ],
        degreeQualities: {
          "I": ["maj"],
          "IV": ["maj"],
          "V": ["maj"],
          "vi": ["m"]
        }
      },
      "gypsy-jazz": {
        type: "functional",
        allowTriplets: true,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: 0.1,
        functions: {
          tonic: [
            { degree: "I", quality: "6" },
            { degree: "I", quality: "maj7" },
            { degree: "vi", quality: "m6" }
          ],
          predom: [
            { degree: "ii", quality: "m7b5" },
            { degree: "iv", quality: "m6" }
          ],
          dominant: [
            { degree: "V", quality: "7" },
            { degree: "V", quality: "9" },
            { degree: "#IV", quality: "dim7" }
          ]
        }
      },
      "hip-hop": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.2,
        templates: [
          ["i", "bVII", "bVI", "bVII"],
          ["i", "bIII", "bVII", "bVI"],
          ["i", "bVI", "bVII", "i"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "bIII": ["maj7"],
          "bVI": ["maj7"],
          "bVII": ["7"]
        }
      },
      "boom-bap": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.15,
        templates: [
          ["i", "bVII", "bVI", "bVII"],
          ["i", "iv", "bVII", "i"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "iv": ["m7"],
          "bVI": ["maj7"],
          "bVII": ["7"]
        }
      },
      trap: {
        type: "template",
        allowTriplets: true,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.1,
        templates: [
          ["i", "bVI", "bVII", "i"],
          ["i", "bVII", "bVI", "i"]
        ],
        degreeQualities: {
          "i": ["m9", "m7"],
          "bVI": ["maj7"],
          "bVII": ["7"]
        }
      },
      "lofi-hiphop": {
        type: "functional",
        allowTriplets: false,
        allowDense: false,
        densityBias: -10,
        subdivisionBias: -0.2,
        functions: {
          tonic: [
            { degree: "i", quality: "m7" },
            { degree: "i", quality: "m9" }
          ],
          predom: [
            { degree: "iv", quality: "m7" },
            { degree: "bVI", quality: "maj7" }
          ],
          dominant: [
            { degree: "bVII", quality: "7" },
            { degree: "V", quality: "7" }
          ]
        }
      },
      edm: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 5,
        subdivisionBias: -0.05,
        templates: [
          ["I", "vi", "IV", "V"],
          ["vi", "IV", "I", "V"],
          ["I", "V", "vi", "IV"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"],
          "V": ["maj", "sus4"]
        }
      },
      house: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.05,
        templates: [
          ["I", "vi", "IV", "V"],
          ["ii", "V", "I", "I"]
        ],
        degreeQualities: {
          "I": ["maj7", "6/9"],
          "vi": ["m7"],
          "IV": ["maj7"],
          "V": ["7", "9"],
          "ii": ["m7"]
        }
      },
      downtempo: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -15,
        subdivisionBias: -0.25,
        templates: [
          ["I", "vi", "IV", "I"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"],
          "V": ["sus4", "maj"]
        }
      },
      trance: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 10,
        subdivisionBias: 0.1,
        templates: [
          ["I", "V", "vi", "IV"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"]
        }
      },
      dubstep: {
        type: "template",
        allowTriplets: false,
        allowDense: true,
        densityBias: 15,
        subdivisionBias: -0.05,
        templates: [
          ["i", "bVI", "bVII", "i"],
          ["i", "bVII", "bVI", "i"]
        ],
        degreeQualities: {
          "i": ["m7", "m9"],
          "bVI": ["maj"],
          "bVII": ["maj"]
        }
      },
      indie: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -5,
        subdivisionBias: -0.1,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "vi", "V"],
          ["vi", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m", "m7"],
          "IV": ["maj", "add9"]
        }
      },
      "post-rock": {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -20,
        subdivisionBias: -0.25,
        templates: [
          ["I", "V", "vi", "IV"],
          ["I", "IV", "I", "V"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "V": ["maj", "sus4"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"]
        }
      },
      minimalism: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -35,
        subdivisionBias: -0.45,
        templates: [
          ["I", "I", "IV", "I"],
          ["I", "V", "I", "I"]
        ],
        degreeQualities: {
          "I": ["add9", "sus2"],
          "IV": ["add9", "sus2"],
          "V": ["sus4", "maj"]
        }
      },
      ambient: {
        type: "template",
        allowTriplets: false,
        allowDense: false,
        densityBias: -35,
        subdivisionBias: -0.4,
        templates: [
          ["I", "vi", "IV", "I"],
          ["I", "IV", "I", "I"]
        ],
        degreeQualities: {
          "I": ["maj7", "add9"],
          "vi": ["m7"],
          "IV": ["maj7", "add9"]
        }
      }
    };

    const patternsEvenByDensity = {
      1: [[2, 2], [3, 1], [2, 1, 1]],
      2: [[2, 2], [1.5, 1.5, 1], [2, 1, 1], [1, 1, 2]],
      3: [[1, 1, 2], [1.5, 1.5, 1], [2, 1, 1], [1, 1, 1, 1]],
      4: [[1, 1, 1, 1], [1, 1, 2], [1.5, 1, 1.5], [1, 1.5, 1.5]],
      5: [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 2], [1.5, 1.5, 1]]
    };

    const patternsTripletByDensity = {
      1: [[4 / 3, 4 / 3, 4 / 3], [2, 4 / 3, 2 / 3]],
      2: [[2 / 3, 2 / 3, 2 / 3, 2], [4 / 3, 2 / 3, 2], [2, 2 / 3, 4 / 3]],
      3: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 4 / 3], [4 / 3, 4 / 3, 2 / 3, 2 / 3]],
      4: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3], [4 / 3, 2 / 3, 4 / 3, 2 / 3]],
      5: [[2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3, 2 / 3], [2 / 3, 4 / 3, 2 / 3, 4 / 3]]
    };

    const simplePatterns = [[4], [2, 2], [3, 1], [1, 3]];
    const densePatterns = [
      [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],
      [0.5, 0.5, 1, 0.5, 0.5, 1],
      [0.5, 0.5, 0.5, 1, 0.5, 1]
    ];

    function pickDensityIndex(densityPercent, rng) {
      const clamped = Math.max(0, Math.min(100, densityPercent));
      const scaled = (clamped / 100) * 4;
      const base = Math.floor(scaled);
      const frac = scaled - base;
      const index = rng() < frac ? base + 1 : base;
      return Math.max(1, Math.min(5, index + 1));
    }

    function chooseSubdivisionPattern({
      densityAdjusted,
      subdivisionAdjusted,
      allowTriplets,
      allowDense,
      subdivisionMode,
      rng
    }) {
      const densityIndex = pickDensityIndex(densityAdjusted, rng);
      const evenPatterns = patternsEvenByDensity[densityIndex];
      const tripletPatterns = patternsTripletByDensity[densityIndex];
      let pattern = [4];
      if (subdivisionAdjusted > 0) {
        if (allowDense && densityAdjusted >= 90 && rng() < 0.7) {
          pattern = pick(densePatterns, rng);
        } else if (rng() < subdivisionAdjusted) {
          pattern = pick(evenPatterns, rng);
          if (allowTriplets && subdivisionMode === "mixed" && rng() < 0.35) {
            pattern = pick(tripletPatterns, rng);
          }
        } else {
          pattern = pick(simplePatterns, rng);
        }
      }
      return pattern;
    }

    function xmur3(str) {
      let h = 1779033703 ^ str.length;
      for (let i = 0; i < str.length; i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function() {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        h ^= h >>> 16;
        return h >>> 0;
      };
    }

    function sfc32(a, b, c, d) {
      return function() {
        a >>>= 0; b >>>= 0; c >>>= 0; d >>>= 0;
        let t = (a + b) | 0;
        a = b ^ (b >>> 9);
        b = (c + (c << 3)) | 0;
        c = (c << 21) | (c >>> 11);
        d = (d + 1) | 0;
        t = (t + d) | 0;
        c = (c + t) | 0;
        return (t >>> 0) / 4294967296;
      };
    }

    function makeRng(seedText) {
      const seed = xmur3(seedText)();
      return sfc32(seed, seed ^ 0xa5a5a5a5, seed ^ 0x5a5a5a5a, seed ^ 0x12345678);
    }

    function pick(list, rng) {
      return list[Math.floor(rng() * list.length)];
    }

    function buildChord(rootIndex, quality, rng) {
      const baseRoot = 48 + rootIndex + (rootIndex > 7 ? -12 : 0);
      let notes = qualities[quality].map(interval => baseRoot + interval);

      notes.sort((a, b) => a - b);
      if (notes.length >= 4 && quality !== "5") {
        const dropIndex = notes.length - 2;
        notes[dropIndex] += 12;
        if (notes.length >= 5 && rng() < 0.55) {
          notes[1] += 12;
        }
        notes = notes.sort((a, b) => a - b);
      }

      while (notes[notes.length - 1] > 84) {
        notes[notes.length - 1] -= 12;
        notes = notes.sort((a, b) => a - b);
      }
      return notes;
    }

    function chordName(rootIndex, quality) {
      const label = qualityLabels[quality] ?? quality;
      return `${noteNames[rootIndex]}${label}`;
    }

    function noteLabelFromMidi(note) {
      const safe = Math.max(0, Math.round(note));
      const name = noteNames[safe % 12] || "C";
      const octave = Math.floor(safe / 12) - 1;
      return `${name}${octave}`;
    }

    const drumNoteLabels = {
      36: "K",
      38: "S",
      37: "R",
      39: "CL",
      42: "HH",
      46: "OH",
      49: "CR",
      51: "RD",
      45: "LT",
      47: "MT",
      50: "HT"
    };

    function drumLabelFromMidi(note) {
      return drumNoteLabels[note] || noteLabelFromMidi(note);
    }

    function clampToRange(note, min, max) {
      let value = note;
      while (value > max) value -= 12;
      while (value < min) value += 12;
      return value;
    }

    function maybeModulateKey(currentKeyIndex, baseKeyIndex, rng, modulationPercent) {
      const chance = Math.max(0, Math.min(100, modulationPercent)) / 100;
      if (chance <= 0) return currentKeyIndex;
      const forceChange = chance >= 1;
      if (forceChange || rng() < chance) {
        if (!forceChange && rng() < 0.25) return baseKeyIndex;
        const steps = [2, 5, 7, 10];
        let nextIndex = currentKeyIndex;
        for (let i = 0; i < 6 && nextIndex === currentKeyIndex; i++) {
          const step = pick(steps, rng) * (rng() < 0.5 ? -1 : 1);
          nextIndex = (currentKeyIndex + step + 12) % 12;
        }
        return nextIndex === currentKeyIndex ? (currentKeyIndex + 7) % 12 : nextIndex;
      }
      return currentKeyIndex;
    }

    function pickBluesQuality(degree, profile, rng) {
      if (profile && profile.bluesQualityMap && profile.bluesQualityMap[degree]) {
        return pick(profile.bluesQualityMap[degree], rng);
      }
      return profile && profile.bluesQuality ? profile.bluesQuality : "7";
    }

    function generateBluesProgression({
      bars,
      key,
      seed,
      rng,
      modulationPercent,
      densityAdjusted,
      subdivisionAdjusted,
      allowTriplets,
      allowDense,
      subdivisionMode,
      profile,
      colorPercent,
      minBars = 4
    }) {
      const totalBars = Math.max(minBars, bars);
      const keyIndex = noteNames.indexOf(key);
      const bluesBars = profile && profile.bluesBars ? profile.bluesBars : [
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "IV", passing: [] },
        { base: "IV", passing: [] },
        { base: "I", passing: [] },
        { base: "I", passing: [] },
        { base: "V", passing: [] },
        { base: "IV", passing: [] },
        { base: "I", passing: [] },
        { base: "V", passing: [] }
      ];
      const chords = [];
      let chordIndex = 0;
      let currentKeyIndex = keyIndex;
      for (let bar = 0; bar < totalBars; bar++) {
        currentKeyIndex = maybeModulateKey(currentKeyIndex, keyIndex, rng, modulationPercent);
        const barDef = bluesBars[bar % bluesBars.length];
        const baseDegree = typeof barDef === "string" ? barDef : barDef.base;
        const passing = typeof barDef === "string" ? [] : (barDef.passing || []);
        const pattern = chooseSubdivisionPattern({
          densityAdjusted,
          subdivisionAdjusted,
          allowTriplets,
          allowDense,
          subdivisionMode,
          rng
        });

        for (let i = 0; i < pattern.length; i++) {
          let degree = baseDegree;
          if (i > 0 && passing.length) {
            degree = pick(passing, rng);
          }
          const offset = degreeOffsets[degree] ?? 0;
          const rootIndex = (currentKeyIndex + offset + 12) % 12;
          const qualityBase = pickBluesQuality(degree, profile, rng);
          const colorSeed = `${seed}|color|${chordIndex}`;
          const quality = applyColorToQuality(qualityBase, colorPercent, colorSeed);
          const voicingSeed = `${seed}|voice|${chordIndex}`;
          chords.push({
            name: chordName(rootIndex, quality),
            quality,
            duration: pattern[i],
            notes: buildChord(rootIndex, quality, makeRng(voicingSeed))
          });
          chordIndex += 1;
        }
      }
      return chords;
    }

    function generateBlendedProgression({
      bars,
      key,
      densityPercent,
      seed,
      subdivision,
      subdivisionDensity,
      genres,
      modulationPercent,
      colorPercent,
      minBars = 4
    }) {
      const rng = makeRng(seed);
      const totalBars = Math.max(minBars, bars);
      const totalBeats = totalBars * 4;
      const keyIndex = noteNames.indexOf(key);
      const genreList = (Array.isArray(genres) ? genres : [genres]).filter(Boolean);
      const profileEntries = genreList.length
        ? genreList.map(genreKey => ({
          key: genreKey,
          profile: genreProfiles[genreKey] || genreProfiles.base
        }))
        : [{ key: "base", profile: genreProfiles.base }];

      let beatsRemaining = totalBeats;
      let functionState = "predom";
      const chords = [];
      let chordIndex = 0;
      let currentKeyIndex = keyIndex;
      const templateState = new Map();

      for (let bar = 0; bar < totalBars; bar++) {
        currentKeyIndex = maybeModulateKey(currentKeyIndex, keyIndex, rng, modulationPercent);
        const entry = pick(profileEntries, rng);
        const barProfile = entry.profile || genreProfiles.base;
        const densityAdjusted = Math.max(0, Math.min(100, densityPercent + (barProfile.densityBias || 0)));
        const subdivisionAdjusted = Math.max(0, Math.min(1, subdivisionDensity + (barProfile.subdivisionBias || 0)));
        const allowTriplets = barProfile.allowTriplets !== false;
        const allowDense = barProfile.allowDense !== false;
        const pattern = chooseSubdivisionPattern({
          densityAdjusted,
          subdivisionAdjusted,
          allowTriplets,
          allowDense,
          subdivisionMode: subdivision,
          rng
        });

        let barDef = null;
        if (barProfile.type === "blues" && barProfile.bluesBars) {
          barDef = barProfile.bluesBars[bar % barProfile.bluesBars.length];
        }

        let templateEntry = null;
        if (barProfile.type === "template" && barProfile.templates && barProfile.templates.length) {
          templateEntry = templateState.get(entry.key);
          if (!templateEntry) {
            templateEntry = { template: pick(barProfile.templates, rng), index: 0 };
            templateState.set(entry.key, templateEntry);
          }
        }

        for (let i = 0; i < pattern.length; i++) {
          let degree = "I";
          let quality = "maj";

          if (barProfile.type === "blues" && barDef) {
            const baseDegree = typeof barDef === "string" ? barDef : barDef.base;
            const passing = typeof barDef === "string" ? [] : (barDef.passing || []);
            degree = baseDegree;
            if (i > 0 && passing.length) {
              degree = pick(passing, rng);
            }
            quality = pickBluesQuality(degree, barProfile, rng);
          } else if (barProfile.type === "template" && templateEntry) {
            degree = templateEntry.template[templateEntry.index % templateEntry.template.length];
            templateEntry.index += 1;
            const qualityPool = barProfile.degreeQualities && barProfile.degreeQualities[degree];
            if (qualityPool && qualityPool.length) {
              quality = pick(qualityPool, rng);
            } else if (degree === degree.toLowerCase()) {
              quality = "m";
            } else {
              quality = "maj";
            }
          } else {
            const functions = barProfile.functions || genreProfiles.base.functions;
            const isPhraseEnd = (bar % 4 === 3) && (i === pattern.length - 1);
            const isPhrasePrep = (bar % 4 === 3) && (i === pattern.length - 2);

            if (isPhraseEnd) {
              functionState = "tonic";
            } else if (isPhrasePrep) {
              functionState = "dominant";
            } else {
              if (functionState === "tonic") {
                functionState = rng() < 0.7 ? "predom" : "dominant";
              } else if (functionState === "predom") {
                functionState = rng() < 0.75 ? "dominant" : "predom";
              } else {
                functionState = rng() < 0.7 ? "tonic" : "predom";
              }
            }

            const choice = pick(functions[functionState], rng);
            degree = choice.degree;
            quality = choice.quality;
          }

          const offset = degreeOffsets[degree] ?? 0;
          const rootIndex = (currentKeyIndex + offset + 12) % 12;
          const colorSeed = `${seed}|color|${chordIndex}`;
          const coloredQuality = applyColorToQuality(quality, colorPercent, colorSeed);
          const voicingSeed = `${seed}|voice|${chordIndex}`;
          const notes = buildChord(rootIndex, coloredQuality, makeRng(voicingSeed));
          const duration = pattern[i];

          chords.push({
            name: chordName(rootIndex, coloredQuality),
            quality: coloredQuality,
            duration,
            notes
          });
          chordIndex += 1;
          beatsRemaining -= duration;
        }
      }

      if (beatsRemaining > 0.01 && chords.length) {
        const last = chords[chords.length - 1];
        last.duration += beatsRemaining;
      }
      return chords;
    }

    function generateProgressionCore({
      bars,
      key,
      densityPercent,
      seed,
      subdivision,
      subdivisionDensity,
      genre,
      modulationPercent,
      colorPercent,
      minBars = 4
    }) {
      const genreList = Array.isArray(genre) ? genre.filter(Boolean) : [genre];
      if (genreList.length > 1) {
        return generateBlendedProgression({
          bars,
          key,
          densityPercent,
          seed,
          subdivision,
          subdivisionDensity,
          genres: genreList,
          modulationPercent,
          colorPercent,
          minBars
        });
      }

      const rng = makeRng(seed);
      const totalBars = Math.max(minBars, bars);
      const totalBeats = totalBars * 4;
      const keyIndex = noteNames.indexOf(key);
      const resolvedGenre = genreList[0] || "base";
      const profile = genreProfiles[resolvedGenre] || genreProfiles.base;

      if (profile.type === "blues") {
        return generateBluesProgression({
          bars: totalBars,
          key,
          seed,
          rng,
          modulationPercent,
          densityAdjusted: Math.max(0, Math.min(100, densityPercent + (profile.densityBias || 0))),
          subdivisionAdjusted: Math.max(0, Math.min(1, subdivisionDensity + (profile.subdivisionBias || 0))),
          allowTriplets: profile.allowTriplets !== false,
          allowDense: profile.allowDense !== false,
          subdivisionMode: subdivision,
          profile,
          colorPercent,
          minBars
        });
      }

      const densityAdjusted = Math.max(0, Math.min(100, densityPercent + (profile.densityBias || 0)));
      const subdivisionAdjusted = Math.max(0, Math.min(1, subdivisionDensity + (profile.subdivisionBias || 0)));
      const allowTriplets = profile.allowTriplets !== false;
      const allowDense = profile.allowDense !== false;

      let beatsRemaining = totalBeats;
      let functionState = "predom";
      const chords = [];
      let chordIndex = 0;
      const template = profile.type === "template" ? pick(profile.templates, rng) : null;
      let templateIndex = 0;
      let currentKeyIndex = keyIndex;

      for (let bar = 0; bar < totalBars; bar++) {
        currentKeyIndex = maybeModulateKey(currentKeyIndex, keyIndex, rng, modulationPercent);
        const pattern = chooseSubdivisionPattern({
          densityAdjusted,
          subdivisionAdjusted,
          allowTriplets,
          allowDense,
          subdivisionMode: subdivision,
          rng
        });

        for (let i = 0; i < pattern.length; i++) {
          let degree = "I";
          let quality = "maj";

          if (profile.type === "template") {
            degree = template[templateIndex % template.length];
            templateIndex += 1;
            const qualityPool = profile.degreeQualities[degree];
            if (qualityPool && qualityPool.length) {
              quality = pick(qualityPool, rng);
            } else if (degree === degree.toLowerCase()) {
              quality = "m";
            } else {
              quality = "maj";
            }
          } else {
            const isPhraseEnd = (bar % 4 === 3) && (i === pattern.length - 1);
            const isPhrasePrep = (bar % 4 === 3) && (i === pattern.length - 2);

            if (isPhraseEnd) {
              functionState = "tonic";
            } else if (isPhrasePrep) {
              functionState = "dominant";
            } else {
              if (functionState === "tonic") {
                functionState = rng() < 0.7 ? "predom" : "dominant";
              } else if (functionState === "predom") {
                functionState = rng() < 0.75 ? "dominant" : "predom";
              } else {
                functionState = rng() < 0.7 ? "tonic" : "predom";
              }
            }

            const choice = pick(profile.functions[functionState], rng);
            degree = choice.degree;
            quality = choice.quality;
          }

          const offset = degreeOffsets[degree] ?? 0;
          const rootIndex = (currentKeyIndex + offset + 12) % 12;
          const colorSeed = `${seed}|color|${chordIndex}`;
          const coloredQuality = applyColorToQuality(quality, colorPercent, colorSeed);
          const voicingSeed = `${seed}|voice|${chordIndex}`;
          const notes = buildChord(rootIndex, coloredQuality, makeRng(voicingSeed));
          const duration = pattern[i];

          chords.push({
            name: chordName(rootIndex, coloredQuality),
            quality: coloredQuality,
            duration,
            notes
          });
          chordIndex += 1;
          beatsRemaining -= duration;
        }
      }

      if (beatsRemaining > 0.01) {
        const last = chords[chords.length - 1];
        last.duration += beatsRemaining;
      }

      return chords;
    }

    function generateProgression({
      bars,
      key,
      densityPercent,
      seed,
      subdivision,
      subdivisionDensity,
      genre,
      modulationPercent,
      colorPercent,
      formEnabled: formEnabledOverride,
      formComplexity: formComplexityOverride
    }) {
      const totalBars = Math.max(4, bars);
      const complexity = normalizePercent(
        formComplexityOverride ?? (formComplexityInput ? formComplexityInput.value : 0),
        0
      );
      const enableForm = (formEnabledOverride ?? formEnabled) && totalBars >= 8;
      if (!enableForm) {
        currentFormSections = [];
        return generateProgressionCore({
          bars: totalBars,
          key,
          densityPercent,
          seed,
          subdivision,
          subdivisionDensity,
          genre,
          modulationPercent,
          colorPercent
        });
      }

      const sections = buildFormSections(totalBars, complexity, seed);
      currentFormSections = sections;
      const chords = [];
      const sectionCache = new Map();
      sections.forEach(section => {
        const adjustments = getFormSectionAdjustments(section.name);
        const density = applySectionAdjustments(densityPercent, adjustments.chord.density, complexity);
        const color = applySectionAdjustments(colorPercent, adjustments.chord.color, complexity);
        const mod = applySectionAdjustments(modulationPercent, adjustments.chord.modulation, complexity);
        const subdiv = clampValue(
          (subdivisionDensity ?? 0) + scaleSectionDelta(adjustments.chord.subdivision, complexity) / 100,
          0,
          1
        );
        const groupId = section.repeatGroup || section.occurrence || 1;
        const cacheKey = `${section.name}:${section.bars}:g${groupId}`;
        const baseKey = `${section.name}:${section.bars}:g1`;
        const repeatAllowed = ["verse", "chorus", "pre"].includes(section.name);
        let sectionChords = null;
        if (section.name === "solo" && sectionCache.has(`chorus:${section.bars}:g1`)) {
          sectionChords = cloneChordList(sectionCache.get(`chorus:${section.bars}:g1`));
        } else if (repeatAllowed && sectionCache.has(cacheKey)) {
          const base = sectionCache.get(cacheKey);
          if (section.name === "verse" && groupId > 1 && sectionCache.has(baseKey)) {
            const sectionSeed = `${seed}|${section.name}-${section.startBar}-variant`;
            const fresh = generateProgressionCore({
              bars: section.bars,
              key,
              densityPercent: density,
              seed: sectionSeed,
              subdivision,
              subdivisionDensity: subdiv,
              genre,
              modulationPercent: mod,
              colorPercent: color,
              minBars: 1
            });
            const variationRng = makeRng(`${sectionSeed}|variation`);
            sectionChords = createSectionVariation(sectionCache.get(baseKey), fresh, complexity, variationRng);
          } else {
            sectionChords = cloneChordList(base);
          }
        } else {
          const sectionSeed = `${seed}|${section.name}-${section.startBar}`;
          sectionChords = generateProgressionCore({
            bars: section.bars,
            key,
            densityPercent: density,
            seed: sectionSeed,
            subdivision,
            subdivisionDensity: subdiv,
            genre,
            modulationPercent: mod,
            colorPercent: color,
            minBars: 1
          });
          if (repeatAllowed) {
            sectionCache.set(cacheKey, cloneChordList(sectionChords));
            if (!sectionCache.has(baseKey)) {
              sectionCache.set(baseKey, cloneChordList(sectionChords));
            }
          }
        }
        sectionChords.forEach(chord => {
          chord.section = section.name;
          chords.push(chord);
        });
      });
      return chords;
    }

    function generateBassLineWithForm({
      chords,
      sections,
      seed,
      densityPercent,
      movementPercent,
      fillPercent,
      restPercent,
      colorPercent,
      subdivisionDensity,
      subdivisionMode,
      style,
      register,
      genre,
      mainGenre,
      formComplexity
    }) {
      if (!sections || !sections.length) {
        return generateBassLine({
          chords,
          seed,
          densityPercent,
          movementPercent,
          fillPercent,
          restPercent,
          colorPercent,
          subdivisionDensity,
          subdivisionMode,
          style,
          register,
          genre,
          mainGenre
        });
      }
      const complexity = normalizePercent(formComplexity, 0);
      const cache = new Map();
      const notes = [];
      sections.forEach(section => {
        const sectionChords = extractChordsForSection(chords, section.startBar, section.bars);
        if (!sectionChords.length) return;
        const adjustments = getFormSectionAdjustments(section.name);
        const density = applySectionAdjustments(densityPercent, adjustments.bass.density, complexity);
        const movement = applySectionAdjustments(movementPercent, adjustments.bass.movement, complexity);
        const fills = applySectionAdjustments(fillPercent, adjustments.bass.fills, complexity);
        const color = applySectionAdjustments(colorPercent, adjustments.bass.color, complexity);
        const subdiv = applySectionAdjustments(subdivisionDensity, adjustments.bass.subdivision, complexity);
        const rests = clampValue(restPercent ?? 50, 0, 100);
        const cacheKey = `${section.name}:${section.bars}`;
        const repeatAllowed = ["verse", "chorus", "pre"].includes(section.name) && complexity < 75;
        let sectionNotes = null;
        if (repeatAllowed && cache.has(cacheKey)) {
          sectionNotes = cache.get(cacheKey).map(note => ({ ...note }));
        } else {
          const sectionSeed = `${seed}|bass|${section.name}`;
          sectionNotes = generateBassLine({
            chords: sectionChords,
            seed: sectionSeed,
            densityPercent: density,
            movementPercent: movement,
            fillPercent: fills,
            restPercent: rests,
            colorPercent: color,
            subdivisionDensity: subdiv,
            subdivisionMode,
            style,
            register,
            genre,
            mainGenre
          });
          if (repeatAllowed) {
            cache.set(cacheKey, sectionNotes.map(note => ({ ...note })));
          }
        }
        const offset = section.startBar * 4;
        sectionNotes.forEach(note => {
          notes.push({ ...note, startBeat: note.startBeat + offset });
        });
      });
      return notes;
    }

    function generateMelodyLineWithForm({
      chords,
      sections,
      seed,
      densityPercent,
      movementPercent,
      fillPercent,
      restPercent,
      colorPercent,
      subdivisionDensity,
      subdivisionMode,
      style,
      register,
      genre,
      mainGenre,
      formComplexity
    }) {
      if (!sections || !sections.length) {
        return generateMelodyLine({
          chords,
          seed,
          densityPercent,
          movementPercent,
          fillPercent,
          restPercent,
          colorPercent,
          subdivisionDensity,
          subdivisionMode,
          style,
          register,
          genre,
          mainGenre
        });
      }
      const complexity = normalizePercent(formComplexity, 0);
      const cache = new Map();
      const notes = [];
      sections.forEach(section => {
        const sectionChords = extractChordsForSection(chords, section.startBar, section.bars);
        if (!sectionChords.length) return;
        const adjustments = getFormSectionAdjustments(section.name);
        const isSolo = section.name === "solo";
        const soloFactor = complexity / 100;
        let density = applySectionAdjustments(densityPercent, adjustments.melody.density, complexity);
        let movement = applySectionAdjustments(movementPercent, adjustments.melody.movement, complexity);
        let fills = applySectionAdjustments(fillPercent, adjustments.melody.fills, complexity);
        let color = applySectionAdjustments(colorPercent, adjustments.melody.color, complexity);
        let subdiv = applySectionAdjustments(subdivisionDensity, adjustments.melody.subdivision, complexity);
        let rests = clampValue(restPercent ?? 50, 0, 100);
        let sectionRegister = register;
        let sectionSubdivisionMode = subdivisionMode;
        if (isSolo) {
          density = clampValue(density + 26 + Math.round(soloFactor * 14), 0, 100);
          movement = clampValue(movement + 34 + Math.round(soloFactor * 12), 0, 100);
          fills = clampValue(fills + 30 + Math.round(soloFactor * 10), 0, 100);
          color = clampValue(color + 22, 0, 100);
          subdiv = clampValue(subdiv + 35, 0, 100);
          sectionRegister = clampValue(register + 8 + Math.round(soloFactor * 8), 60, 90);
          if (sectionSubdivisionMode === "even") {
            sectionSubdivisionMode = "mixed";
          }
          rests = clampValue(rests - 15, 0, 100);
        }
        const cacheKey = `${section.name}:${section.bars}`;
        const repeatAllowed = ["verse", "chorus", "pre"].includes(section.name) && complexity < 75;
        let sectionNotes = null;
        if (repeatAllowed && cache.has(cacheKey)) {
          sectionNotes = cache.get(cacheKey).map(note => ({ ...note }));
        } else {
          const sectionSeed = `${seed}|melody|${section.name}`;
          const sectionStyle = isSolo && ["auto", "step", "motif"].includes(style) ? "leap" : style;
          sectionNotes = generateMelodyLine({
            chords: sectionChords,
            seed: sectionSeed,
            densityPercent: density,
            movementPercent: movement,
            fillPercent: fills,
            restPercent: rests,
            colorPercent: color,
            subdivisionDensity: subdiv,
            subdivisionMode: sectionSubdivisionMode,
            style: sectionStyle,
            register: sectionRegister,
            genre,
            mainGenre
          });
          if (repeatAllowed) {
            cache.set(cacheKey, sectionNotes.map(note => ({ ...note })));
          }
        }
        const offset = section.startBar * 4;
        sectionNotes.forEach(note => {
          notes.push({ ...note, startBeat: note.startBeat + offset });
        });
      });
      return notes;
    }

    function generateDrumPatternWithForm({
      bars,
      sections,
      seed,
      densityPercent,
      complexityPercent,
      fillPercent,
      ghostPercent,
      velocityPercent,
      style,
      genre,
      mainGenre,
      formComplexity
    }) {
      if (!sections || !sections.length) {
        return generateDrumPattern({
          bars,
          seed,
          densityPercent,
          complexityPercent,
          fillPercent,
          ghostPercent,
          velocityPercent,
          style,
          genre,
          mainGenre
        });
      }
      const complexity = normalizePercent(formComplexity, 0);
      const cache = new Map();
      const notes = [];
      sections.forEach(section => {
        const adjustments = getFormSectionAdjustments(section.name);
        const density = applySectionAdjustments(densityPercent, adjustments.drum.density, complexity);
        const detail = applySectionAdjustments(complexityPercent, adjustments.drum.complexity, complexity);
        const fills = applySectionAdjustments(fillPercent, adjustments.drum.fills, complexity);
        const ghost = applySectionAdjustments(ghostPercent, adjustments.drum.ghost, complexity);
        const cacheKey = `${section.name}:${section.bars}`;
        const repeatAllowed = ["verse", "chorus", "pre"].includes(section.name) && complexity < 75;
        let sectionNotes = null;
        if (repeatAllowed && cache.has(cacheKey)) {
          sectionNotes = cache.get(cacheKey).map(note => ({ ...note }));
        } else {
          const sectionSeed = `${seed}|drum|${section.name}`;
          sectionNotes = generateDrumPattern({
            bars: section.bars,
            seed: sectionSeed,
            densityPercent: density,
            complexityPercent: detail,
            fillPercent: fills,
            ghostPercent: ghost,
            velocityPercent,
            style,
            genre,
            mainGenre
          });
          if (repeatAllowed) {
            cache.set(cacheKey, sectionNotes.map(note => ({ ...note })));
          }
        }
        const offset = section.startBar * 4;
        sectionNotes.forEach(hit => {
          notes.push({ ...hit, startBeat: hit.startBeat + offset });
        });
      });
      return notes;
    }

    function clampValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function normalizePercent(value, fallback = 0) {
      const num = parseInt(value, 10);
      if (Number.isNaN(num)) return fallback;
      return clampValue(num, 0, 100);
    }

    function buildFormSections(totalBars, complexityPercent, seed) {
      const complexity = clampValue(complexityPercent, 0, 100) / 100;
      const rng = makeRng(`${seed}|form-layout|${Math.round(complexityPercent)}`);
      if (complexity >= 1) {
        return [{
          name: "solo",
          bars: totalBars,
          index: 0,
          repeatGroup: 1,
          occurrence: 1,
          label: "Solo 1",
          startBar: 0
        }];
      }
      const minSectionBars = complexity >= 0.75 ? 1 : 2;
      const wantIntro = totalBars >= 8 && (complexity < 0.15 || rng() < (0.55 + complexity * 0.25));
      const wantOutro = totalBars >= 8 && (complexity < 0.2 ? rng() < 0.6 : rng() < (0.35 + complexity * 0.35));

      const maxSections = Math.max(3, Math.floor(totalBars / minSectionBars));
      const baseSections = 3 + (wantIntro ? 1 : 0) + (wantOutro ? 1 : 0);
      const targetSections = Math.min(
        maxSections,
        Math.max(baseSections, Math.round(4 + complexity * (maxSections - 4)))
      );

      const structure = [];
      if (wantIntro) structure.push("intro");
      structure.push("verse");
      structure.push("chorus");

      const pickWeighted = (choices) => {
        const total = choices.reduce((sum, item) => sum + item.weight, 0);
        let roll = rng() * total;
        for (let i = 0; i < choices.length; i++) {
          roll -= choices[i].weight;
          if (roll <= 0) return choices[i].name;
        }
        return choices[choices.length - 1].name;
      };

      while (structure.length < targetSections - (wantOutro ? 1 : 0)) {
        const last = structure[structure.length - 1];
        const baseWeights = [
          { name: "verse", weight: 1.1 },
          { name: "chorus", weight: 1.0 },
          { name: "pre", weight: 0.2 + complexity * 0.8 },
          { name: "bridge", weight: 0.15 + complexity * 0.7 },
          { name: "solo", weight: 0.2 + complexity * 2.4 }
        ];
        if (last === "verse") {
          baseWeights.find(item => item.name === "chorus").weight += 0.4;
          baseWeights.find(item => item.name === "pre").weight += 0.3;
          baseWeights.find(item => item.name === "verse").weight += 0.2;
        } else if (last === "chorus") {
          baseWeights.find(item => item.name === "verse").weight += 0.35;
          baseWeights.find(item => item.name === "bridge").weight += 0.25;
          baseWeights.find(item => item.name === "solo").weight += 0.2;
        } else if (last === "pre") {
          baseWeights.find(item => item.name === "chorus").weight += 0.6;
        } else if (last === "bridge") {
          baseWeights.find(item => item.name === "chorus").weight += 0.5;
          baseWeights.find(item => item.name === "verse").weight += 0.2;
        } else if (last === "solo") {
          baseWeights.find(item => item.name === "chorus").weight += 0.6;
          baseWeights.find(item => item.name === "verse").weight += 0.2;
        }
        const next = pickWeighted(baseWeights);
        structure.push(next);
      }

      if (complexity >= 0.6 && !structure.some(entry => (typeof entry === "string" ? entry : entry.name) === "solo")) {
        const coreIndices = structure
          .map((entry, index) => ({ name: typeof entry === "string" ? entry : entry.name, index }))
          .filter(item => !["intro", "outro", "solo"].includes(item.name))
          .map(item => item.index);
        if (coreIndices.length) {
          const pickIndex = coreIndices[Math.floor(rng() * coreIndices.length)];
          structure[pickIndex] = "solo";
        } else {
          const insertAt = Math.max(1, structure.length - (wantOutro ? 1 : 0));
          structure.splice(insertAt, 0, "solo");
        }
      }

      const hasName = (name) => structure.some(entry => (typeof entry === "string" ? entry : entry.name) === name);
      if (complexity <= 0.3) {
        const coreSlots = Math.max(1, targetSections - (wantIntro ? 1 : 0) - (wantOutro ? 1 : 0));
        const core = [];
        const groupCounts = {};
        let nextCore = rng() < 0.5 ? "chorus" : "verse";
        while (core.length < coreSlots) {
          const groupId = (groupCounts[nextCore] || 0) + 1;
          groupCounts[nextCore] = groupId;
          core.push({ name: nextCore, repeatGroup: groupId });
          if (core.length < coreSlots) {
            core.push({ name: nextCore, repeatGroup: groupId });
          }
          nextCore = nextCore === "verse" ? "chorus" : "verse";
        }
        structure.length = 0;
        if (wantIntro) structure.push({ name: "intro", repeatGroup: 1 });
        structure.push(...core.slice(0, coreSlots));
        if (wantOutro) structure.push({ name: "outro", repeatGroup: 1 });
      } else {
        if (!hasName("verse")) structure.splice(wantIntro ? 1 : 0, 0, "verse");
        if (!hasName("chorus")) structure.push("chorus");
        if (wantOutro) structure.push("outro");
      }

      const lengthRanges = {
        intro: [1, 4],
        verse: [2, 6],
        pre: [2, 4],
        chorus: [2, 6],
        bridge: [2, 4],
        solo: [1, 4],
        outro: [1, 4]
      };

      const pickSectionBars = (name) => {
        const range = lengthRanges[name] || [2, 4];
        if (complexity <= 0.3) {
          return Math.max(minSectionBars, 2);
        }
        const min = Math.max(minSectionBars, range[0] + Math.floor(complexity * 1));
        const max = Math.max(min, range[1] + Math.floor(complexity * 2));
        return min + Math.floor(rng() * (max - min + 1));
      };

      let sections = structure.map((entry, index) => {
        const name = typeof entry === "string" ? entry : entry.name;
        const repeatGroup = (entry && typeof entry === "object" && entry.repeatGroup) ? entry.repeatGroup : null;
        return {
          name,
          bars: pickSectionBars(name),
          index,
          repeatGroup
        };
      });

      let sumBars = sections.reduce((sum, section) => sum + section.bars, 0);
      const removable = ["outro", "intro", "bridge", "pre"];
      if (complexity < 0.6) {
        removable.push("solo");
      }
      removable.forEach(type => {
        if (sumBars <= totalBars) return;
        for (let i = sections.length - 1; i >= 0 && sumBars > totalBars; i--) {
          if (sections[i].name === type) {
            sumBars -= sections[i].bars;
            sections.splice(i, 1);
          }
        }
      });

      while (sumBars > totalBars && sections.length) {
        const candidate = sections.reduce((best, section) => (section.bars > best.bars ? section : best), sections[0]);
        if (candidate.bars <= minSectionBars) break;
        candidate.bars -= 1;
        sumBars -= 1;
      }

      while (sumBars < totalBars && sections.length) {
        const expandable = sections.filter(section => ["verse", "chorus", "bridge", "solo"].includes(section.name));
        const pool = expandable.length ? expandable : sections;
        const target = pool[Math.floor(rng() * pool.length)];
        target.bars += 1;
        sumBars += 1;
      }

      const labelMap = {
        intro: "Intro",
        verse: "Verse",
        pre: "Pre",
        chorus: "Chorus",
        bridge: "Bridge",
        solo: "Solo",
        outro: "Ending"
      };

      let cursor = 0;
      const groupCounts = {};
      const lastGroup = {};
      const lowComplexityRepeatAll = complexityPercent <= 30;
      sections = sections.map(section => {
        let group = section.repeatGroup;
        const hasPrev = lastGroup[section.name];
        if (!group) {
          const shortRepeatChance = clampValue(0.8 - complexity * 0.5, 0.2, 0.8);
          const repeatChance = hasPrev
            ? Math.min(0.95, shortRepeatChance + (section.bars <= 2 ? 0.25 : 0))
            : 0;
          if (hasPrev && (lowComplexityRepeatAll || rng() < repeatChance)) {
            group = lastGroup[section.name];
          } else {
            group = (groupCounts[section.name] || 0) + 1;
          }
        }
        groupCounts[section.name] = Math.max(groupCounts[section.name] || 0, group);
        lastGroup[section.name] = group;
        const startBar = cursor;
        cursor += section.bars;
        return {
          ...section,
          repeatGroup: group,
          occurrence: group,
          label: `${labelMap[section.name] || section.name} ${group}`,
          startBar
        };
      });

      return sections;
    }

    function getFormSectionAdjustments(sectionName) {
      const profile = {
        chord: { density: 0, color: 0, modulation: 0, subdivision: 0 },
        bass: { density: 0, movement: 0, color: 0, fills: 0, subdivision: 0 },
        melody: { density: 0, movement: 0, color: 0, fills: 0, subdivision: 0 },
        drum: { density: 0, complexity: 0, fills: 0, ghost: 0 }
      };

      const set = (target, updates) => Object.assign(profile[target], updates);

      if (sectionName === "intro") {
        set("chord", { density: -35, color: -15, subdivision: -18 });
        set("bass", { density: -30, movement: -18, color: -20, fills: -30, subdivision: -18 });
        set("melody", { density: -40, movement: -22, color: -20, fills: -35, subdivision: -18 });
        set("drum", { density: -35, complexity: -25, fills: -35, ghost: -18 });
      } else if (sectionName === "pre") {
        set("chord", { density: 10, color: 6, subdivision: 6 });
        set("bass", { density: 12, movement: 10, color: 8, fills: 10, subdivision: 8 });
        set("melody", { density: 12, movement: 12, color: 8, fills: 10, subdivision: 8 });
        set("drum", { density: 12, complexity: 10, fills: 12, ghost: 8 });
      } else if (sectionName === "chorus") {
        set("chord", { density: 20, color: 15, subdivision: 10 });
        set("bass", { density: 20, movement: 12, color: 12, fills: 15, subdivision: 10 });
        set("melody", { density: 18, movement: 12, color: 12, fills: 15, subdivision: 10 });
        set("drum", { density: 22, complexity: 15, fills: 18, ghost: 10 });
      } else if (sectionName === "bridge") {
        set("chord", { density: 12, color: 20, modulation: 15, subdivision: 8 });
        set("bass", { density: 10, movement: 18, color: 15, fills: 12, subdivision: 10 });
        set("melody", { density: 12, movement: 20, color: 18, fills: 12, subdivision: 10 });
        set("drum", { density: 8, complexity: 18, fills: 12, ghost: 8 });
      } else if (sectionName === "solo") {
        set("chord", { density: 15, color: 20, modulation: 10, subdivision: 12 });
        set("bass", { density: 15, movement: 22, color: 18, fills: 18, subdivision: 12 });
        set("melody", { density: 38, movement: 32, color: 28, fills: 26, subdivision: 18 });
        set("drum", { density: 15, complexity: 18, fills: 18, ghost: 10 });
      } else if (sectionName === "outro") {
        set("chord", { density: -30, color: -10, subdivision: -15 });
        set("bass", { density: -28, movement: -16, color: -15, fills: -22, subdivision: -15 });
        set("melody", { density: -35, movement: -20, color: -15, fills: -25, subdivision: -15 });
        set("drum", { density: -30, complexity: -18, fills: -30, ghost: -12 });
      }

      return profile;
    }

    function scaleSectionDelta(delta, complexityPercent) {
      const factor = clampValue(complexityPercent, 0, 100) / 100;
      return delta * factor;
    }

    function applySectionAdjustments(base, delta, complexityPercent) {
      return clampValue(base + scaleSectionDelta(delta, complexityPercent), 0, 100);
    }

    function cloneChordList(chords) {
      return chords.map(chord => ({
        name: chord.name,
        quality: chord.quality,
        duration: chord.duration,
        notes: chord.notes ? chord.notes.slice() : [],
        section: chord.section || null
      }));
    }

    function createSectionVariation(baseChords, freshChords, complexityPercent, rng = Math.random) {
      if (!baseChords.length || !freshChords.length) return cloneChordList(baseChords);
      const variation = baseChords.map(chord => ({
        name: chord.name,
        quality: chord.quality,
        duration: chord.duration,
        notes: chord.notes ? chord.notes.slice() : []
      }));
      const maxSwap = Math.min(baseChords.length, freshChords.length);
      if (maxSwap <= 2) return variation;
      const midStart = 1;
      const midEnd = maxSwap - 2;
      const chance = clampValue(complexityPercent, 0, 100) / 100 * 0.6 + 0.2;
      for (let i = midStart; i <= midEnd; i++) {
        if (rng() < chance) {
          variation[i] = {
            name: freshChords[i].name,
            quality: freshChords[i].quality,
            duration: freshChords[i].duration,
            notes: freshChords[i].notes ? freshChords[i].notes.slice() : []
          };
        }
      }
      return variation;
    }

    function extractChordsForSection(chords, startBar, bars) {
      const startBeat = startBar * 4;
      const endBeat = startBeat + bars * 4;
      let cursor = 0;
      const slice = [];
      chords.forEach(chord => {
        const chordStart = cursor;
        const chordEnd = cursor + chord.duration;
        cursor = chordEnd;
        if (chordEnd <= startBeat) return;
        if (chordStart >= endBeat) return;
        if (chordStart + 1e-6 < startBeat || chordEnd - 1e-6 > endBeat) return;
        slice.push({
          name: chord.name,
          quality: chord.quality,
          duration: chord.duration,
          notes: chord.notes ? chord.notes.slice() : []
        });
      });
      return slice;
    }

    function renderFormLane(sections, totalBars, beatPx) {
      if (!formLane) return;
      formLane.innerHTML = "";
      if (!sections || !sections.length) {
        formLane.classList.add("hidden");
        return;
      }
      formLane.classList.remove("hidden");
      formLane.style.width = `${Math.max(1, totalBars * 4 * beatPx)}px`;
      sections.forEach(section => {
        const block = document.createElement("div");
        block.className = "form-block";
        block.textContent = section.label || section.name;
        block.style.left = `${section.startBar * 4 * beatPx}px`;
        block.style.width = `${section.bars * 4 * beatPx - 6}px`;
        formLane.appendChild(block);
      });
    }

    function setFormEnabledState(enabled) {
      formEnabled = !!enabled;
      if (formToggle) {
        formToggle.textContent = formEnabled ? "On" : "Off";
        formToggle.setAttribute("aria-pressed", formEnabled ? "true" : "false");
      }
      if (formComplexityInput) {
        formComplexityInput.disabled = !formEnabled;
      }
    }

    function cloneChordArray(chords) {
      return (chords || []).map(chord => ({
        name: chord.name,
        quality: chord.quality,
        duration: chord.duration,
        notes: chord.notes ? chord.notes.slice() : [],
        section: chord.section || null
      }));
    }

    function cloneNoteArray(notes) {
      return (notes || []).map(note => ({ ...note }));
    }

    function cloneFormArray(sections) {
      return (sections || []).map(section => ({ ...section }));
    }

    function getCurrentGenreLabel() {
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      if (blendSubs) {
        return blendSubs.map(getSubGenreLabel).join(" + ");
      }
      if (genreMain && genreSub && genreCatalog[genreMain.value] && genreCatalog[genreMain.value].sub[genreSub.value]) {
        return genreCatalog[genreMain.value].sub[genreSub.value];
      }
      return genreSub?.value || "base";
    }

    function captureSnapshot() {
      if (!currentChords || !currentChords.length) return null;
      const subdivisionDensityValue = parseInt(subdivisionDensityInput?.value, 10);
      const snapshot = {
        controls: {
          key: keySelect?.value || "",
          genreMain: genreMain?.value || "",
          genreSub: genreSub?.value || "",
          bars: barsInput?.value || "",
          density: densityInput?.value || "",
          color: colorInput?.value || "",
          modulation: modulationInput?.value || "",
          subdivision: subdivisionInput?.value || "",
          subdivisionDensity: subdivisionDensityInput?.value || "",
          backingStyle: backingStyleInput?.value || "blocks",
          backingComp: backingCompInput?.value || "",
          formEnabled,
          formComplexity: formComplexityInput?.value || "",
          tempo: (tempoNumber?.value || tempoInput?.value) || "",
          chordVolume: chordVolumeInput?.value || "",
          bassVolume: bassVolumeInput?.value || "",
          melodyVolume: melodyVolumeInput?.value || "",
          drumVolume: drumVolumeInput?.value || "",
          chordChannel: chordChannelSelect?.value || "",
          bassChannel: bassChannelSelect?.value || "",
          melodyChannel: melodyChannelSelect?.value || "",
          bassGenreMain: bassGenreMain?.value || "",
          bassGenreSub: bassGenreSub?.value || "",
          melodyGenreMain: melodyGenreMain?.value || "",
          melodyGenreSub: melodyGenreSub?.value || "",
          drumGenreMain: drumGenreMain?.value || "",
          drumGenreSub: drumGenreSub?.value || "",
          bassDensity: bassDensityInput?.value || "",
          bassMovement: bassMovementInput?.value || "",
          bassColor: bassColorInput?.value || "",
          bassFills: bassFillsInput?.value || "",
          bassRests: bassRestsInput?.value || "",
          bassSubdivisionDensity: bassSubdivisionDensityInput?.value || "",
          bassSubdivision: bassSubdivisionInput?.value || "",
          bassStyle: bassStyleInput?.value || "",
          bassRegister: bassRegisterInput?.value || "",
          melodyDensity: melodyDensityInput?.value || "",
          melodyMovement: melodyMovementInput?.value || "",
          melodyColor: melodyColorInput?.value || "",
          melodyFills: melodyFillsInput?.value || "",
          melodyRests: melodyRestsInput?.value || "",
          melodySubdivisionDensity: melodySubdivisionDensityInput?.value || "",
          melodySubdivision: melodySubdivisionInput?.value || "",
          melodyStyle: melodyStyleInput?.value || "",
          melodyRegister: melodyRegisterInput?.value || "",
          drumDensity: drumDensityInput?.value || "",
          drumComplexity: drumComplexityInput?.value || "",
          drumFills: drumFillsInput?.value || "",
          drumGhost: drumGhostInput?.value || "",
          drumVelocity: drumVelocityInput?.value || "",
          drumStyle: drumStyleInput?.value || "",
          loopModes: {
            chord: chordPlaybackMode,
            bass: bassPlaybackMode,
            melody: melodyPlaybackMode,
            drum: drumPlaybackMode
          },
          mutes: {
            chord: chordMuted,
            bass: bassMuted,
            melody: melodyMuted,
            drum: drumMuted
          },
          songMode,
          selectionMode,
          themeValue: themeSlider?.value || "0",
          blendMode: document.body.classList.contains("blend-mode"),
          manualBlendEnabled,
          manualBlendGenres: manualBlendGenres.slice(),
          panelsCollapsed: {
            chord: chordPanel?.classList.contains("collapsed") || false,
            bass: bassPanel?.classList.contains("collapsed") || false,
            melody: melodyPanel?.classList.contains("collapsed") || false,
            drum: drumPanel?.classList.contains("collapsed") || false
          }
        },
        state: {
          currentSeed,
          bassSeedCounter,
          melodySeedCounter,
          drumSeedCounter,
          bassAutoRegenerate,
          melodyAutoRegenerate,
          drumAutoRegenerate,
          currentKeyUsed,
          currentKeyLabel,
          currentBpm,
          currentFileName
        },
        cycle: {
          seedLabel: currentSeed,
          bars: parseInt(barsInput?.value, 10) || 4,
          bpm: currentBpm,
          key: currentKeyUsed,
          keyLabel: currentKeyLabel,
          genreLabel: getCurrentGenreLabel(),
          densityPercent: parseInt(densityInput?.value, 10) || 0,
          colorPercent: parseInt(colorInput?.value, 10) || 0,
          modulationPercent: parseInt(modulationInput?.value, 10) || 0,
          subdivision: subdivisionInput?.value || "even",
          subdivisionDensity: Number.isNaN(subdivisionDensityValue)
            ? 0
            : Math.max(0, Math.min(100, subdivisionDensityValue)) / 100,
          chords: cloneChordArray(currentChords),
          bass: cloneNoteArray(currentBass),
          melody: cloneNoteArray(currentMelody),
          drums: cloneNoteArray(currentDrums),
          formSections: cloneFormArray(currentFormSections),
          formComplexity: formComplexityInput?.value || "",
          counters: {
            bass: bassSeedCounter,
            melody: melodySeedCounter,
            drum: drumSeedCounter
          }
        },
        selection: {
          chords: Array.from(selectedChordIndices),
          bass: Array.from(selectedBassIndices),
          melody: Array.from(selectedMelodyIndices),
          drums: Array.from(selectedDrumIndices)
        }
      };
      return snapshot;
    }

    function updateHistoryButtons() {
      if (undoButton) undoButton.disabled = historyIndex <= 0;
      if (redoButton) redoButton.disabled = historyIndex >= historyStack.length - 1;
    }

    function pushHistory() {
      if (suppressHistory) return;
      const snapshot = captureSnapshot();
      if (!snapshot) return;
      if (historyIndex < historyStack.length - 1) {
        historyStack.splice(historyIndex + 1);
      }
      historyStack.push(snapshot);
      if (historyStack.length > HISTORY_LIMIT) {
        historyStack.shift();
      }
      historyIndex = historyStack.length - 1;
      updateHistoryButtons();
    }

    function applySnapshot(snapshot) {
      if (!snapshot) return;
      suppressHistory = true;
      stopPlayback();
      if (keySelect && snapshot.controls.key) keySelect.value = snapshot.controls.key;
      if (genreMain && genreSub && snapshot.controls.genreMain) {
        genreMain.value = snapshot.controls.genreMain;
        populateSubgenresFor(genreMain.value, genreSub, snapshot.controls.genreSub);
      }
      if (bassGenreMain && bassGenreSub && snapshot.controls.bassGenreMain) {
        bassGenreMain.value = snapshot.controls.bassGenreMain;
        populateSubgenresFor(bassGenreMain.value, bassGenreSub, snapshot.controls.bassGenreSub);
      }
      if (melodyGenreMain && melodyGenreSub && snapshot.controls.melodyGenreMain) {
        melodyGenreMain.value = snapshot.controls.melodyGenreMain;
        populateSubgenresFor(melodyGenreMain.value, melodyGenreSub, snapshot.controls.melodyGenreSub);
      }
      if (drumGenreMain && drumGenreSub && snapshot.controls.drumGenreMain) {
        drumGenreMain.value = snapshot.controls.drumGenreMain;
        populateSubgenresFor(drumGenreMain.value, drumGenreSub, snapshot.controls.drumGenreSub);
      }

      if (barsInput) barsInput.value = snapshot.controls.bars;
      if (densityInput) densityInput.value = snapshot.controls.density;
      if (colorInput) colorInput.value = snapshot.controls.color;
      if (modulationInput) modulationInput.value = snapshot.controls.modulation;
      if (subdivisionInput) subdivisionInput.value = snapshot.controls.subdivision;
      if (subdivisionDensityInput) subdivisionDensityInput.value = snapshot.controls.subdivisionDensity;
      if (backingStyleInput) backingStyleInput.value = snapshot.controls.backingStyle || "blocks";
      if (backingCompInput) backingCompInput.value = snapshot.controls.backingComp || "50";
      if (formComplexityInput) formComplexityInput.value = snapshot.controls.formComplexity;
      setFormEnabledState(snapshot.controls.formEnabled);
      resolveBackingSettings();
      updateBackingCompVisibility(backingStyleInput?.value);

      if (tempoInput) tempoInput.value = snapshot.controls.tempo;
      if (tempoNumber) tempoNumber.value = snapshot.controls.tempo;
      if (chordVolumeInput) chordVolumeInput.value = snapshot.controls.chordVolume;
      if (bassVolumeInput) bassVolumeInput.value = snapshot.controls.bassVolume;
      if (melodyVolumeInput) melodyVolumeInput.value = snapshot.controls.melodyVolume;
      if (drumVolumeInput) drumVolumeInput.value = snapshot.controls.drumVolume;
      if (chordChannelSelect) chordChannelSelect.value = snapshot.controls.chordChannel;
      if (bassChannelSelect) bassChannelSelect.value = snapshot.controls.bassChannel;
      if (melodyChannelSelect) melodyChannelSelect.value = snapshot.controls.melodyChannel;

      if (bassDensityInput) bassDensityInput.value = snapshot.controls.bassDensity;
      if (bassMovementInput) bassMovementInput.value = snapshot.controls.bassMovement;
      if (bassColorInput) bassColorInput.value = snapshot.controls.bassColor;
      if (bassFillsInput) bassFillsInput.value = snapshot.controls.bassFills;
      if (bassRestsInput) bassRestsInput.value = snapshot.controls.bassRests || "50";
      if (bassSubdivisionDensityInput) bassSubdivisionDensityInput.value = snapshot.controls.bassSubdivisionDensity;
      if (bassSubdivisionInput) bassSubdivisionInput.value = snapshot.controls.bassSubdivision;
      if (bassStyleInput) bassStyleInput.value = snapshot.controls.bassStyle;
      if (bassRegisterInput) bassRegisterInput.value = snapshot.controls.bassRegister;

      if (melodyDensityInput) melodyDensityInput.value = snapshot.controls.melodyDensity;
      if (melodyMovementInput) melodyMovementInput.value = snapshot.controls.melodyMovement;
      if (melodyColorInput) melodyColorInput.value = snapshot.controls.melodyColor;
      if (melodyFillsInput) melodyFillsInput.value = snapshot.controls.melodyFills;
      if (melodyRestsInput) melodyRestsInput.value = snapshot.controls.melodyRests || "50";
      if (melodySubdivisionDensityInput) melodySubdivisionDensityInput.value = snapshot.controls.melodySubdivisionDensity;
      if (melodySubdivisionInput) melodySubdivisionInput.value = snapshot.controls.melodySubdivision;
      if (melodyStyleInput) melodyStyleInput.value = snapshot.controls.melodyStyle;
      if (melodyRegisterInput) melodyRegisterInput.value = snapshot.controls.melodyRegister;

      if (drumDensityInput) drumDensityInput.value = snapshot.controls.drumDensity;
      if (drumComplexityInput) drumComplexityInput.value = snapshot.controls.drumComplexity;
      if (drumFillsInput) drumFillsInput.value = snapshot.controls.drumFills;
      if (drumGhostInput) drumGhostInput.value = snapshot.controls.drumGhost;
      if (drumVelocityInput) drumVelocityInput.value = snapshot.controls.drumVelocity;
      if (drumStyleInput) drumStyleInput.value = snapshot.controls.drumStyle;

      songMode = !!snapshot.controls.songMode;
      document.body.classList.toggle("song-mode", songMode);
      if (songToggle) songToggle.textContent = songMode ? "¢hange" : "$ong";
      if (titleLeft && titleRight) {
        titleLeft.textContent = songMode ? "$ong" : "¢hange";
        titleRight.textContent = songMode ? "Machine" : "machine";
      }

      if (themeSlider) {
        themeSlider.value = snapshot.controls.themeValue || "0";
        const value = (parseInt(themeSlider.value, 10) || 0) / 100;
        applyThemeMix(value);
      }

      document.body.classList.toggle("blend-mode", snapshot.controls.blendMode);
      manualBlendEnabled = snapshot.controls.manualBlendEnabled;
      manualBlendGenres = snapshot.controls.manualBlendGenres.slice();
      if (snapshot.controls.blendMode) {
        syncBlendSelects(manualBlendGenres.length ? manualBlendGenres : [`${genreMain?.value || "core"}:${genreSub?.value || "base"}`]);
        updateManualBlendFromSelects(true);
      } else {
        syncBlendSelects([]);
      }

      chordMuted = snapshot.controls.mutes.chord;
      bassMuted = snapshot.controls.mutes.bass;
      melodyMuted = snapshot.controls.mutes.melody;
      drumMuted = snapshot.controls.mutes.drum;
      updateMuteButton(chordMute, chordMuted);
      updateMuteButton(bassMute, bassMuted);
      updateMuteButton(melodyMute, melodyMuted);
      updateMuteButton(drumMute, drumMuted);

      setTrackPlaybackMode("chord", snapshot.controls.loopModes.chord);
      setTrackPlaybackMode("bass", snapshot.controls.loopModes.bass);
      setTrackPlaybackMode("melody", snapshot.controls.loopModes.melody);
      setTrackPlaybackMode("drum", snapshot.controls.loopModes.drum);

      setPanelCollapsedState(chordPanel, chordCollapse, snapshot.controls.panelsCollapsed.chord);
      setPanelCollapsedState(bassPanel, bassCollapse, snapshot.controls.panelsCollapsed.bass);
      setPanelCollapsedState(melodyPanel, melodyCollapse, snapshot.controls.panelsCollapsed.melody);
      setPanelCollapsedState(drumPanel, drumCollapse, snapshot.controls.panelsCollapsed.drum);

      bassAutoRegenerate = snapshot.state.bassAutoRegenerate;
      melodyAutoRegenerate = snapshot.state.melodyAutoRegenerate;
      drumAutoRegenerate = snapshot.state.drumAutoRegenerate;
      bassSeedCounter = snapshot.state.bassSeedCounter;
      melodySeedCounter = snapshot.state.melodySeedCounter;
      drumSeedCounter = snapshot.state.drumSeedCounter;
      currentSeed = snapshot.state.currentSeed;
      currentKeyUsed = snapshot.state.currentKeyUsed;
      currentKeyLabel = snapshot.state.currentKeyLabel;
      currentBpm = snapshot.state.currentBpm;
      currentFileName = snapshot.state.currentFileName;

      applyChordRegenCycle({
        ...snapshot.cycle,
        chords: cloneChordArray(snapshot.cycle.chords),
        bass: cloneNoteArray(snapshot.cycle.bass),
        melody: cloneNoteArray(snapshot.cycle.melody),
        drums: cloneNoteArray(snapshot.cycle.drums),
        formSections: cloneFormArray(snapshot.cycle.formSections)
      }, false);

      setSelectionMode(snapshot.controls.selectionMode);
      clearSelection();
      snapshot.selection.chords.forEach(index => selectedChordIndices.add(index));
      snapshot.selection.bass.forEach(index => selectedBassIndices.add(index));
      snapshot.selection.melody.forEach(index => selectedMelodyIndices.add(index));
      snapshot.selection.drums.forEach(index => selectedDrumIndices.add(index));
      applySelectionStyles();

      updateReadouts();
      updateTrackGains();
      schedulePanelAlignment();
      suppressHistory = false;
      updateHistoryButtons();
    }

    function getBassProfile(genreKey, mainKey) {
      const tag = `${mainKey || ""} ${genreKey || ""}`.toLowerCase();
      const profile = {
        style: "root",
        densityBias: 0,
        movementBias: 0,
        subdivisionBias: 0,
        registerBias: 0,
        fillBias: 0
      };

      const setProfile = (overrides) => {
        Object.assign(profile, overrides);
      };

      if (/(bebop|hard-bop|swing|gypsy|manouche)/.test(tag)) {
        setProfile({ style: "walk", densityBias: 20, movementBias: 30, subdivisionBias: 10, registerBias: 2, fillBias: 20 });
      } else if (/(jazz|fusion)/.test(tag)) {
        setProfile({ style: "walk", densityBias: 15, movementBias: 25, subdivisionBias: 8, registerBias: 2, fillBias: 15 });
      } else if (/(blues)/.test(tag)) {
        setProfile({ style: "walk", densityBias: 10, movementBias: 20, subdivisionBias: 6, registerBias: 1, fillBias: 10 });
      } else if (/(funk)/.test(tag)) {
        setProfile({ style: "octave", densityBias: 15, movementBias: 18, subdivisionBias: 15, registerBias: 0, fillBias: 18 });
      } else if (/(neo-soul|soul|rnb|gospel)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 8, movementBias: 16, subdivisionBias: 6, registerBias: 0, fillBias: 12 });
      } else if (/(hip-hop|boom-bap|trap)/.test(tag)) {
        setProfile({ style: "root", densityBias: -5, movementBias: -15, subdivisionBias: -5, registerBias: -4, fillBias: -15 });
      } else if (/(edm|house|trance|dubstep)/.test(tag)) {
        setProfile({ style: "octave", densityBias: 8, movementBias: 6, subdivisionBias: 10, registerBias: -2, fillBias: 8 });
      } else if (/(rock|alt|indie|post-rock)/.test(tag)) {
        setProfile({ style: "octave", densityBias: 5, movementBias: -5, subdivisionBias: 0, registerBias: -1, fillBias: 0 });
      } else if (/(metal)/.test(tag)) {
        setProfile({ style: "root", densityBias: 12, movementBias: -20, subdivisionBias: 2, registerBias: -3, fillBias: -5 });
      } else if (/(punk)/.test(tag)) {
        setProfile({ style: "root", densityBias: 6, movementBias: -15, subdivisionBias: 0, registerBias: -2, fillBias: -5 });
      } else if (/(pop|synth-pop|dream-pop)/.test(tag)) {
        setProfile({ style: "root", densityBias: -2, movementBias: -10, subdivisionBias: 0, registerBias: -1, fillBias: -5 });
      } else if (/(reggae|ska)/.test(tag)) {
        setProfile({ style: "root", densityBias: -10, movementBias: -12, subdivisionBias: -5, registerBias: 0, fillBias: -8 });
      } else if (/(calypso)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 6, movementBias: 10, subdivisionBias: 8, registerBias: 0, fillBias: 8 });
      } else if (/(americana|country|folk)/.test(tag)) {
        setProfile({ style: "root", densityBias: -5, movementBias: -12, subdivisionBias: -5, registerBias: -1, fillBias: -8 });
      } else if (/(classical|baroque|romantic|impression|neoclassical|modern-classical|minimalism)/.test(tag)) {
        setProfile({ style: "arp", densityBias: -5, movementBias: 8, subdivisionBias: -5, registerBias: 1, fillBias: -5 });
      } else if (/(ambient|lofi)/.test(tag)) {
        setProfile({ style: "root", densityBias: -18, movementBias: -18, subdivisionBias: -12, registerBias: -1, fillBias: -20 });
      } else if (/(prog)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 12, movementBias: 22, subdivisionBias: 10, registerBias: 0, fillBias: 12 });
      }

      return profile;
    }

    function blendTrackProfiles(profiles, rng, fallbackStyle = "root") {
      if (!profiles.length) {
        return {
          style: fallbackStyle,
          densityBias: 0,
          movementBias: 0,
          subdivisionBias: 0,
          registerBias: 0,
          fillBias: 0
        };
      }
      const styles = profiles.map(profile => profile.style).filter(Boolean);
      const style = styles.length ? pick(styles, rng) : fallbackStyle;
      const average = (key) => {
        const sum = profiles.reduce((total, profile) => total + (profile[key] || 0), 0);
        return sum / profiles.length;
      };
      return {
        style,
        densityBias: average("densityBias"),
        movementBias: average("movementBias"),
        subdivisionBias: average("subdivisionBias"),
        registerBias: average("registerBias"),
        fillBias: average("fillBias")
      };
    }

    function getBassProfileBlend(genreKey, mainKey, rng) {
      if (!Array.isArray(genreKey)) {
        return getBassProfile(genreKey, mainKey);
      }
      const mainList = Array.isArray(mainKey) ? mainKey : [];
      const profiles = genreKey.map((key, index) => getBassProfile(key, mainList[index] || mainList[0] || ""));
      return blendTrackProfiles(profiles, rng, "root");
    }

    function chooseBassDurations(duration, densityPercent, subdivisionDensity, allowTriplets, rng) {
      const density = Math.max(0, Math.min(100, densityPercent)) / 100;
      const subdiv = Math.max(0, Math.min(100, subdivisionDensity)) / 100;
      let hits = 1;
      if (density > 0.35 && rng() < density) hits += 1;
      if (density > 0.6 && rng() < density) hits += 1;
      if (density > 0.85 && rng() < density) hits += 1;
      if (allowTriplets && subdiv > 0.65 && rng() < subdiv) {
        hits = Math.max(hits, 3);
      }
      hits = Math.max(1, Math.min(hits, Math.round(duration * 4)));
      const slice = duration / hits;
      return Array.from({ length: hits }, () => slice);
    }

    function getScaleOffsetsForQuality(quality) {
      const family = getQualityFamily(quality);
      if (family === "min") return [0, 2, 3, 5, 7, 8, 10];
      if (family === "dom") return [0, 2, 4, 5, 7, 9, 10];
      if (family === "dim") return [0, 2, 3, 5, 6, 8, 9, 11];
      if (family === "halfdim") return [0, 1, 3, 5, 6, 8, 10];
      if (family === "sus") return [0, 2, 5, 7, 9, 10];
      if (family === "power") return [0, 2, 4, 5, 7, 9, 11];
      return [0, 2, 4, 5, 7, 9, 11];
    }

    function buildScalePitches(rootPc, rangeMin, rangeMax, offsets) {
      const pcs = offsets.map(offset => (rootPc + offset) % 12);
      const pitches = [];
      for (let note = rangeMin; note <= rangeMax; note++) {
        if (pcs.includes(((note % 12) + 12) % 12)) {
          pitches.push(note);
        }
      }
      return pitches;
    }

    function pickNearestScaleNote(target, scalePitches) {
      if (!scalePitches.length) return null;
      let best = scalePitches[0];
      let bestDist = Math.abs(best - target);
      for (let i = 1; i < scalePitches.length; i++) {
        const dist = Math.abs(scalePitches[i] - target);
        if (dist < bestDist) {
          best = scalePitches[i];
          bestDist = dist;
        }
      }
      return best;
    }

    function pickScaleNoteNear(current, scalePitches, rng, movementPercent) {
      if (!scalePitches.length) return null;
      const baseWindow = 2 + Math.round((movementPercent / 100) * 6);
      const window = baseWindow + (rng() < 0.35 ? 1 : 0);
      const candidates = scalePitches.filter(note => Math.abs(note - current) <= window);
      return pick(candidates.length ? candidates : scalePitches, rng);
    }

    function pickChordToneNear(current, chordTones, rng, movementPercent) {
      if (!chordTones.length) return null;
      const baseWindow = 2 + Math.round((movementPercent / 100) * 5);
      const window = baseWindow + (rng() < 0.35 ? 1 : 0);
      const candidates = chordTones.filter(note => Math.abs(note - current) <= window);
      return pick(candidates.length ? candidates : chordTones, rng);
    }

    function pickBassPalette(colorPercent, rng) {
      const t = clampValue(colorPercent, 0, 100) / 100;
      if (t <= 0.5) {
        const mix = t / 0.5;
        return rng() < mix ? "chord" : "root";
      }
      const mix = (t - 0.5) / 0.5;
      return rng() < mix ? "scale" : "chord";
    }

    function filterAvoidMaj7(notes, rootPc) {
      return notes.filter(note => (((note % 12) + 12) % 12) !== ((rootPc + 11) % 12));
    }

    function applyBassFills(durations, fillChance, allowTriplets, rng) {
      const segments = durations.map(dur => ({ dur, fill: false }));
      if (!segments.length || fillChance <= 0) return segments;
      if (rng() >= fillChance) return segments;
      const intensity = Math.max(0, Math.min(1, fillChance));
      const maxSplits = intensity > 0.85 ? 2 : 1;
      let didSplit = false;
      for (let splitIndex = 0; splitIndex < maxSplits; splitIndex++) {
        const idx = segments.length - 1 - splitIndex;
        if (idx < 0) break;
        const segment = segments[idx];
        let splits = allowTriplets && rng() < 0.4 ? 3 : 2;
        if (intensity > 0.7 && rng() < intensity) {
          splits = allowTriplets && rng() < 0.5 ? 3 : 4;
        }
        const slice = segment.dur / splits;
        if (slice < 0.25) continue;
        const replacement = Array.from({ length: splits }, () => ({ dur: slice, fill: true }));
        segments.splice(idx, 1, ...replacement);
        didSplit = true;
      }
      if (!didSplit && segments.length) {
        segments[segments.length - 1].fill = true;
      }
      return segments;
    }

    function applySegmentRests(segments, restChance, rng, options = {}) {
      const chance = clampValue(restChance || 0, 0, 0.8);
      if (!segments.length || chance <= 0) return segments;
      const avoidFirst = options.avoidFirst !== false;
      const avoidLast = !!options.avoidLast;
      const minNotes = Math.max(1, options.minNotes || 1);
      let played = 0;
      const lastIndex = segments.length - 1;
      const output = segments.map((segment, index) => {
        if (segment.fill) {
          played += 1;
          return { ...segment, rest: false };
        }
        if ((avoidFirst && index === 0) || (avoidLast && index === lastIndex)) {
          played += 1;
          return { ...segment, rest: false };
        }
        const rest = rng() < chance;
        if (!rest) played += 1;
        return { ...segment, rest };
      });
      if (played < minNotes) {
        for (let i = 0; i < output.length; i += 1) {
          if (output[i].fill) continue;
          output[i].rest = false;
          played += 1;
          if (played >= minNotes) break;
        }
      }
      return output;
    }

    function generateBassLine({
      chords,
      seed,
      densityPercent,
      movementPercent,
      fillPercent,
      restPercent,
      colorPercent,
      subdivisionDensity,
      subdivisionMode,
      style,
      register,
      genre,
      mainGenre
    }) {
      if (!chords || !chords.length) return [];
      const genreSeed = Array.isArray(genre) ? genre.join("+") : (genre || "base");
      const rng = makeRng(`${seed}|bass|${genreSeed}`);
      const profile = getBassProfileBlend(genre, mainGenre, rng);
      const resolvedStyle = style === "auto" ? profile.style : style;
      const densityAdjusted = clampValue(densityPercent + profile.densityBias, 0, 100);
      const movementAdjusted = clampValue(movementPercent + profile.movementBias, 0, 100);
      const subdivisionAdjusted = clampValue(subdivisionDensity + profile.subdivisionBias, 0, 100);
      const registerAdjusted = clampValue(register + profile.registerBias, 24, 60);
      const fillAdjusted = clampValue((fillPercent || 0) + profile.fillBias, 0, 100);
      const restAdjusted = clampValue(restPercent ?? 50, 0, 100);
      const colorAdjusted = clampValue(colorPercent ?? 50, 0, 100);
      const fillChance = fillAdjusted / 100;
      const restChance = clampValue(restAdjusted / 100 * 0.75, 0, 0.75);
      const bassNotes = [];
      const rangeMin = Math.max(20, Math.min(60, registerAdjusted));
      const rangeMax = rangeMin + 12;
      let beatCursor = 0;

      chords.forEach((chord, index) => {
        const duration = chord.duration;
        const allowTriplets = subdivisionMode !== "even";
        const durations = chooseBassDurations(duration, densityAdjusted, subdivisionAdjusted, allowTriplets, rng);
        const segments = applyBassFills(durations, fillChance, allowTriplets, rng);
        const segmentsWithRests = applySegmentRests(
          segments,
          restChance,
          rng,
          { avoidFirst: restAdjusted < 75, minNotes: 1 }
        );
        const baseRoot = chord.notes[0] ?? 36;
        const quality = chord.quality || "maj";
        const rootPc = ((baseRoot % 12) + 12) % 12;
        const scaleOffsets = getScaleOffsetsForQuality(quality);
        const scalePitches = buildScalePitches(rootPc, rangeMin, rangeMax, scaleOffsets);
        const scaleNoMaj7 = filterAvoidMaj7(scalePitches, rootPc);
        const root = clampToRange(baseRoot - 12, rangeMin, rangeMax);
        const nextChord = chords[(index + 1) % chords.length];
        const nextRootRaw = nextChord && nextChord.notes ? nextChord.notes[0] : baseRoot;
        const targetRoot = clampToRange((nextRootRaw ?? baseRoot) - 12, rangeMin, rangeMax);
        const chordTones = Array.from(new Set(chord.notes.map(note => clampToRange(note - 12, rangeMin, rangeMax))));
        chordTones.sort((a, b) => a - b);
        const chordTonesNoMaj7 = filterAvoidMaj7(chordTones, rootPc);

        let current = root;
        segmentsWithRests.forEach((segment, hitIndex) => {
          if (segment.rest) {
            beatCursor += segment.dur;
            return;
          }
          const isLastHit = hitIndex === segmentsWithRests.length - 1;
          const isFill = segment.fill;
          let note = root;
          if (hitIndex === 0) {
            const palette = pickBassPalette(colorAdjusted, rng);
            if (palette === "root") {
              note = root;
            } else if (palette === "chord") {
              note = chordTonesNoMaj7.length ? pick(chordTonesNoMaj7, rng) : root;
            } else {
              if (chordTonesNoMaj7.length && rng() < 0.4) {
                note = pick(chordTonesNoMaj7, rng);
              } else if (scaleNoMaj7.length) {
                note = pick(scaleNoMaj7, rng);
              } else {
                note = root;
              }
            }
            note = clampToRange(note, rangeMin, rangeMax);
          } else if (isFill) {
            const approachTarget = isLastHit ? targetRoot : current;
            const approach = pickNearestScaleNote(approachTarget, scalePitches);
            if (approach !== null && (isLastHit || rng() < 0.45)) {
              note = approach;
            } else if (chordTones.length && rng() < 0.35) {
              note = pick(chordTones, rng);
            } else {
              const near = pickScaleNoteNear(current, scalePitches, rng, movementAdjusted);
              note = near !== null ? near : root;
            }
            note = clampToRange(note, rangeMin, rangeMax);
          } else if (resolvedStyle === "octave") {
            const octave = clampToRange(root + 12, rangeMin, rangeMax);
            if (hitIndex % 2 === 0) {
              note = root;
            } else {
              const palette = pickBassPalette(colorAdjusted, rng);
              if (palette === "chord") {
                const nonRoot = chordTones.filter(tone => tone !== root);
                note = nonRoot.length ? pick(nonRoot, rng) : octave;
              } else if (palette === "scale") {
                const near = pickScaleNoteNear(root, scalePitches, rng, movementAdjusted);
                note = near !== null ? near : octave;
              } else {
                note = octave;
              }
            }
          } else if (resolvedStyle === "walk") {
            if (hitIndex === 0) {
              note = root;
            } else if (rng() < movementAdjusted / 100) {
              const palette = pickBassPalette(colorAdjusted, rng);
              if (palette === "root") {
                note = root;
              } else if (palette === "chord") {
                const chordNote = pickChordToneNear(current, chordTones, rng, movementAdjusted);
                note = chordNote !== null ? chordNote : current;
              } else {
                const direction = targetRoot > current ? 1 : -1;
                const step = rng() < 0.6 ? 2 : 1;
                let candidate = current + direction * step;
                if (rng() < movementAdjusted / 100 * 0.25) {
                  candidate = targetRoot + (rng() < 0.5 ? -1 : 1);
                }
                note = clampToRange(candidate, rangeMin, rangeMax);
              }
            } else {
              note = current;
            }
          } else if (resolvedStyle === "arp") {
            const palette = pickBassPalette(colorAdjusted, rng);
            if (palette === "scale" && scalePitches.length) {
              note = scalePitches[hitIndex % scalePitches.length];
            } else if (chordTones.length) {
              note = chordTones[hitIndex % chordTones.length];
            } else {
              note = root;
            }
          } else {
            const palette = pickBassPalette(colorAdjusted, rng);
            if (palette === "root") {
              note = root;
            } else if (palette === "chord") {
              const chordNote = pickChordToneNear(current, chordTones, rng, movementAdjusted);
              note = chordNote !== null ? chordNote : root;
            } else {
              const near = pickScaleNoteNear(current, scalePitches, rng, movementAdjusted);
              note = near !== null ? near : root;
            }
          }

          bassNotes.push({
            note,
            startBeat: beatCursor,
            duration: segment.dur
          });
          current = note;
          beatCursor += segment.dur;
        });
      });

      return bassNotes;
    }

    function getMelodyProfile(genreKey, mainKey) {
      const tag = `${mainKey || ""} ${genreKey || ""}`.toLowerCase();
      const profile = {
        style: "step",
        densityBias: 10,
        movementBias: 18,
        subdivisionBias: 8,
        registerBias: 0,
        fillBias: 8
      };

      const setProfile = (overrides) => {
        Object.assign(profile, overrides);
      };

      if (/(bebop|hard-bop|swing|gypsy|manouche)/.test(tag)) {
        setProfile({ style: "step", densityBias: 18, movementBias: 24, subdivisionBias: 12, registerBias: 2, fillBias: 15 });
      } else if (/(jazz|fusion)/.test(tag)) {
        setProfile({ style: "step", densityBias: 12, movementBias: 20, subdivisionBias: 10, registerBias: 2, fillBias: 12 });
      } else if (/(pop|synth-pop|dream-pop)/.test(tag)) {
        setProfile({ style: "motif", densityBias: 8, movementBias: 10, subdivisionBias: 6, registerBias: 1, fillBias: 6 });
      } else if (/(rock|metal|punk|prog)/.test(tag)) {
        setProfile({ style: "leap", densityBias: 6, movementBias: 16, subdivisionBias: 6, registerBias: 0, fillBias: 6 });
      } else if (/(rnb|soul|neo-soul|funk|gospel)/.test(tag)) {
        setProfile({ style: "step", densityBias: 10, movementBias: 14, subdivisionBias: 8, registerBias: 1, fillBias: 10 });
      } else if (/(ambient|lofi)/.test(tag)) {
        setProfile({ style: "step", densityBias: -5, movementBias: -8, subdivisionBias: -8, registerBias: 0, fillBias: -10 });
      } else if (/(classical|baroque|romantic|impression|neoclassical)/.test(tag)) {
        setProfile({ style: "arp", densityBias: 4, movementBias: 12, subdivisionBias: 4, registerBias: 3, fillBias: 4 });
      }

      return profile;
    }

    function getMelodyProfileBlend(genreKey, mainKey, rng) {
      if (!Array.isArray(genreKey)) {
        return getMelodyProfile(genreKey, mainKey);
      }
      const mainList = Array.isArray(mainKey) ? mainKey : [];
      const profiles = genreKey.map((key, index) => getMelodyProfile(key, mainList[index] || mainList[0] || ""));
      return blendTrackProfiles(profiles, rng, "step");
    }

    function chooseMelodyDurations(duration, densityPercent, subdivisionDensity, allowTriplets, rng) {
      const density = Math.max(0, Math.min(100, densityPercent)) / 100;
      const subdiv = Math.max(0, Math.min(100, subdivisionDensity)) / 100;
      let hits = 1;
      if (density > 0.3 && rng() < density) hits += 1;
      if (density > 0.55 && rng() < density) hits += 1;
      if (density > 0.75 && rng() < density) hits += 2;
      if (density > 0.9 && rng() < density) hits += 2;
      if (allowTriplets && subdiv > 0.5 && rng() < subdiv) {
        hits = Math.max(hits, 3);
      }
      if (subdiv > 0.75 && rng() < subdiv) {
        hits = Math.max(hits, Math.round(duration * 6));
      }
      hits = Math.max(1, Math.min(hits, Math.round(duration * 8)));
      const slice = duration / hits;
      return Array.from({ length: hits }, () => slice);
    }

    function pickMelodyPalette(colorPercent, rng) {
      const t = clampValue(colorPercent, 0, 100) / 100;
      if (t <= 0.4) {
        const mix = t / 0.4;
        return rng() < mix ? "chord" : "root";
      }
      const mix = (t - 0.4) / 0.6;
      return rng() < mix ? "scale" : "chord";
    }

    function generateMelodyLine({
      chords,
      seed,
      densityPercent,
      movementPercent,
      fillPercent,
      restPercent,
      colorPercent,
      subdivisionDensity,
      subdivisionMode,
      style,
      register,
      genre,
      mainGenre
    }) {
      if (!chords || !chords.length) return [];
      const genreSeed = Array.isArray(genre) ? genre.join("+") : (genre || "base");
      const rng = makeRng(`${seed}|melody|${genreSeed}`);
      const profile = getMelodyProfileBlend(genre, mainGenre, rng);
      const resolvedStyle = style === "auto" ? profile.style : style;
      const densityAdjusted = clampValue(densityPercent + profile.densityBias, 0, 100);
      const movementAdjusted = clampValue(movementPercent + profile.movementBias, 0, 100);
      const subdivisionAdjusted = clampValue(subdivisionDensity + profile.subdivisionBias, 0, 100);
      const registerAdjusted = clampValue(register + profile.registerBias, 50, 90);
      const fillAdjusted = clampValue((fillPercent || 0) + profile.fillBias, 0, 100);
      const restAdjusted = clampValue(restPercent ?? 50, 0, 100);
      const colorAdjusted = clampValue(colorPercent ?? 50, 0, 100);
      const fillChance = fillAdjusted / 100;
      const restChance = clampValue(restAdjusted / 100 * 0.75, 0, 0.75);
      const melodyNotes = [];
      const rangeMin = Math.max(48, Math.min(84, registerAdjusted));
      const rangeMax = rangeMin + 24;
      let beatCursor = 0;
      let current = null;
      let motif = [];
      let motifIndex = 0;

      if (resolvedStyle === "motif") {
        const motifLength = 3 + Math.floor(rng() * 2);
        motif = Array.from({ length: motifLength }, () => {
          const step = rng() < 0.6 ? 2 : 3;
          return (rng() < 0.5 ? -1 : 1) * step;
        });
      }

      chords.forEach((chord, chordIndex) => {
        const duration = chord.duration;
        const allowTriplets = subdivisionMode !== "even";
        const durations = chooseMelodyDurations(duration, densityAdjusted, subdivisionAdjusted, allowTriplets, rng);
        const segments = applyBassFills(durations, fillChance, allowTriplets, rng);
        const segmentsWithRests = applySegmentRests(
          segments,
          restChance,
          rng,
          { avoidFirst: restAdjusted < 75, minNotes: 1 }
        );
        const baseRoot = chord.notes[0] ?? 60;
        const quality = chord.quality || "maj";
        const rootPc = ((baseRoot % 12) + 12) % 12;
        const scaleOffsets = getScaleOffsetsForQuality(quality);
        const scalePitches = buildScalePitches(rootPc, rangeMin, rangeMax, scaleOffsets);
        const root = clampToRange(baseRoot + 12, rangeMin, rangeMax);
        const chordTones = Array.from(new Set(chord.notes.map(note => clampToRange(note, rangeMin, rangeMax))));
        chordTones.sort((a, b) => a - b);

        if (current === null) {
          current = root;
        }

        segmentsWithRests.forEach((segment, hitIndex) => {
          if (segment.rest) {
            beatCursor += segment.dur;
            return;
          }
          let note = current ?? root;
          if (hitIndex === 0) {
            const palette = pickMelodyPalette(colorAdjusted, rng);
            if (palette === "root") {
              note = root;
            } else if (palette === "chord") {
              note = chordTones.length ? pick(chordTones, rng) : root;
            } else {
              if (chordTones.length && rng() < 0.4) {
                note = pick(chordTones, rng);
              } else if (scalePitches.length) {
                note = pick(scalePitches, rng);
              } else {
                note = root;
              }
            }
          } else if (resolvedStyle === "arp") {
            const palette = pickMelodyPalette(colorAdjusted, rng);
            if (palette === "scale" && scalePitches.length) {
              note = scalePitches[(hitIndex + chordIndex) % scalePitches.length];
            } else if (chordTones.length) {
              note = chordTones[(hitIndex + chordIndex) % chordTones.length];
            } else {
              note = root;
            }
          } else if (resolvedStyle === "leap") {
            const palette = pickMelodyPalette(colorAdjusted, rng);
            if (palette === "chord" && chordTones.length) {
              note = pickChordToneNear(current, chordTones, rng, movementAdjusted);
            } else {
              const leaps = scalePitches.filter(candidate => {
                const dist = Math.abs(candidate - current);
                return dist >= 3 && dist <= 9;
              });
              note = pick(leaps.length ? leaps : scalePitches, rng);
            }
          } else if (resolvedStyle === "motif" && motif.length) {
            const interval = motif[motifIndex % motif.length];
            motifIndex += 1;
            const target = (current ?? root) + interval;
            const approach = pickNearestScaleNote(target, scalePitches);
            note = approach !== null ? approach : current;
          } else {
            const palette = pickMelodyPalette(colorAdjusted, rng);
            if (palette === "chord") {
              const chordNote = pickChordToneNear(current, chordTones, rng, movementAdjusted);
              note = chordNote !== null ? chordNote : current;
            } else {
              const near = pickScaleNoteNear(current, scalePitches, rng, movementAdjusted);
              note = near !== null ? near : current;
            }
          }

          note = clampToRange(note ?? root, rangeMin, rangeMax);
          melodyNotes.push({
            note,
            startBeat: beatCursor,
            duration: segment.dur
          });
          current = note;
          beatCursor += segment.dur;
        });
      });

      return melodyNotes;
    }

    function resolveDrumStyle(mainGenre, subGenre, styleOverride) {
      if (styleOverride && styleOverride !== "auto") return styleOverride;
      const key = `${mainGenre || ""} ${subGenre || ""}`.toLowerCase();
      if (key.includes("jazz") || key.includes("bebop") || key.includes("fusion") || key.includes("gypsy")) return "jazz";
      if (key.includes("funk")) return "funk";
      if (key.includes("hip") || key.includes("hop") || key.includes("lofi")) return "hiphop";
      if (key.includes("blues")) return "blues";
      if (key.includes("latin") || key.includes("bossa") || key.includes("samba") || key.includes("calypso")) return "latin";
      if (key.includes("reggae") || key.includes("rega")) return "reggae";
      if (key.includes("electronic") || key.includes("dubstep") || key.includes("edm") || key.includes("house") || key.includes("techno")) return "electronic";
      if (key.includes("metal") || key.includes("punk") || key.includes("hardcore")) return "rock";
      if (key.includes("rock") || key.includes("prog") || key.includes("americana") || key.includes("country")) return "rock";
      if (key.includes("soul") || key.includes("rnb") || key.includes("neo-soul")) return "funk";
      return "pop";
    }

    function getDrumPatternPreset(subGenre, mainGenre, style, rng) {
      const sub = (subGenre || "").toLowerCase();
      const main = (mainGenre || "").toLowerCase();
      const preset = {
        stepsPerBar: 16,
        kick: [0, 8],
        snare: [4, 12],
        hat: [0, 2, 4, 6, 8, 10, 12, 14],
        ride: [],
        rim: [],
        clap: [],
        ghost: [],
        openHat: [],
        extraKick: [2, 6, 9, 13, 15],
        tomFill: [],
        hatNote: 42,
        velocities: {
          kick: 96,
          snare: 100,
          hat: 72,
          ride: 76,
          ghost: 58,
          rim: 70,
          clap: 88,
          openHat: 86
        }
      };

      const setSwing = () => {
        preset.stepsPerBar = 12;
        preset.hat = [];
        preset.ride = [0, 3, 4, 6, 9, 10];
        preset.hatNote = 51;
        preset.kick = [0, 6];
        preset.snare = [];
        preset.ghost = [4, 10];
        preset.extraKick = [2, 5, 8, 11];
      };

      if (sub.includes("bebop") || sub.includes("swing") || sub.includes("gypsy") || sub.includes("cool") || sub.includes("modal") || sub.includes("jazz")) {
        setSwing();
      } else if (sub.includes("fusion")) {
        preset.kick = [0, 7, 10, 13];
        preset.snare = [4, 12];
        preset.hat = [...Array(16).keys()];
        preset.extraKick = [2, 6, 9, 14];
      } else if (sub.includes("bossa")) {
        preset.kick = [0, 6, 8, 14];
        preset.snare = [12];
        preset.rim = [4, 12];
        preset.hat = [0, 4, 8, 12];
      } else if (sub.includes("samba") || sub.includes("latin-jazz") || sub.includes("latin")) {
        preset.kick = [0, 4, 8, 12];
        preset.snare = [3, 7, 11, 15];
        preset.hat = [0, 2, 4, 6, 8, 10, 12, 14];
        preset.extraKick = [5, 9, 13];
      } else if (sub.includes("lofi") || sub.includes("hip-hop") || sub.includes("hiphop")) {
        preset.kick = [0, 9, 11];
        preset.snare = [4, 12];
        preset.hat = [0, 4, 8, 12];
        preset.extraKick = [6, 14];
      } else if (sub.includes("funk") || sub.includes("neo-soul") || sub.includes("soul") || sub.includes("rnb")) {
        preset.kick = [0, 3, 7, 10, 12];
        preset.snare = [4, 12];
        preset.hat = [...Array(16).keys()];
        preset.extraKick = [2, 6, 9, 13, 15];
      } else if (sub.includes("blues")) {
        preset.stepsPerBar = 12;
        preset.kick = [0, 6];
        preset.snare = [3, 9];
        preset.hat = [0, 4, 6, 10];
        preset.extraKick = [2, 5, 8, 11];
      } else if (sub.includes("reggae") || sub.includes("rega")) {
        preset.kick = [8];
        preset.snare = [8];
        preset.hat = [2, 6, 10, 14];
        preset.extraKick = [0, 12];
      } else if (sub.includes("calypso")) {
        preset.kick = [0, 6, 10, 14];
        preset.snare = [4, 12];
        preset.rim = [2, 8];
        preset.hat = [0, 4, 8, 12];
      } else if (sub.includes("metal")) {
        preset.kick = [0, 2, 4, 6, 8, 10, 12, 14];
        preset.snare = [4, 12];
        preset.hat = [...Array(16).keys()];
        preset.extraKick = [1, 3, 5, 7, 9, 11, 13, 15];
      } else if (sub.includes("punk")) {
        preset.kick = [0, 8, 10, 12];
        preset.snare = [4, 12];
        preset.hat = [...Array(16).keys()];
      } else if (sub.includes("prog")) {
        preset.kick = [0, 5, 7, 11];
        preset.snare = [4, 12];
        preset.hat = [0, 2, 4, 6, 8, 10, 12, 14];
        preset.extraKick = [1, 3, 9, 13, 15];
        preset.tomFill = [12, 13, 14, 15];
      } else if (sub.includes("americana") || sub.includes("country") || sub.includes("folk")) {
        preset.kick = [0, 8];
        preset.snare = [4, 12];
        preset.hat = [0, 4, 8, 12];
      } else if (sub.includes("classical") || sub.includes("baroque") || sub.includes("neo")) {
        preset.kick = [0];
        preset.snare = [];
        preset.hat = [];
        preset.ride = [];
        preset.extraKick = [];
      } else if (style === "jazz") {
        setSwing();
      } else if (style === "funk") {
        preset.kick = [0, 3, 7, 10, 12];
        preset.snare = [4, 12];
        preset.hat = [...Array(16).keys()];
      } else if (style === "hiphop") {
        preset.kick = [0, 9, 11];
        preset.snare = [4, 12];
        preset.hat = [0, 4, 8, 12];
      } else if (style === "latin") {
        preset.kick = [0, 7, 10, 14];
        preset.snare = [4, 12];
        preset.hat = [0, 4, 8, 12];
      } else if (style === "reggae") {
        preset.kick = [8];
        preset.snare = [8];
        preset.hat = [2, 6, 10, 14];
      } else if (style === "electronic") {
        preset.kick = [0, 4, 8, 12];
        preset.snare = [4, 12];
        preset.hat = [0, 2, 4, 6, 8, 10, 12, 14];
        preset.extraKick = [2, 6, 10, 14];
      }

      if (main.includes("electronic") && rng() < 0.35) {
        preset.hat = [...Array(preset.stepsPerBar).keys()];
      }
      return preset;
    }

    function generateDrumPattern({
      bars,
      seed,
      densityPercent,
      complexityPercent,
      fillPercent,
      ghostPercent,
      velocityPercent,
      style,
      genre,
      mainGenre
    }) {
      const rng = makeRng(`${seed}-drums`);
      const genreList = Array.isArray(genre) ? genre.filter(Boolean) : [genre];
      const mainList = Array.isArray(mainGenre) ? mainGenre : [mainGenre];
      const density = Math.max(0, Math.min(100, densityPercent)) / 100;
      const complexity = Math.max(0, Math.min(100, complexityPercent)) / 100;
      const fills = Math.max(0, Math.min(100, fillPercent || 0)) / 100;
      const ghosts = Math.max(0, Math.min(100, ghostPercent || 0)) / 100;
      const velocityScale = Math.max(0, Math.min(1, (velocityPercent ?? 100) / 100));
      const events = [];
      const notes = {
        kick: 36,
        snare: 38,
        rim: 37,
        clap: 39,
        closedHat: 42,
        openHat: 46,
        ride: 51,
        crash: 49,
        tomLow: 45,
        tomMid: 47,
        tomHigh: 50
      };
      let stepBeat = 1;

      function pushHit(step, note, velocity, durSteps = 1, barIndex, seen) {
        const key = `${step}-${note}`;
        if (seen.has(key)) return;
        seen.add(key);
        const scaledVelocity = Math.max(1, Math.min(127, Math.round(velocity * velocityScale)));
        events.push({
          note,
          startBeat: barIndex * 4 + step * stepBeat,
          duration: durSteps * stepBeat,
          velocity: scaledVelocity
        });
      }

      function pickFillPattern(stepsPerBar, styleKey, subKey, rng, barIndex, fillSeedOffset = 0) {
        const key = `${styleKey || ""} ${subKey || ""}`.toLowerCase();
        const localRng = makeRng(`${seed}|fill-${barIndex}-${fillSeedOffset}-${styleKey || "auto"}-${subKey || "base"}`);
        const patterns = [];
        const endTriplet = [stepsPerBar - 3, stepsPerBar - 2, stepsPerBar - 1];
        const endQuad = [stepsPerBar - 4, stepsPerBar - 3, stepsPerBar - 2, stepsPerBar - 1];
        if (/(jazz|bebop|swing|fusion|gypsy|latin|bossa|samba)/.test(key)) {
          patterns.push(
            [stepsPerBar - 5, stepsPerBar - 4, stepsPerBar - 2],
            [stepsPerBar - 6, stepsPerBar - 4, stepsPerBar - 3, stepsPerBar - 1],
            [2, 5, 7, 10, 12, 15].filter(step => step < stepsPerBar)
          );
        } else if (/(funk|neo-soul|rnb|soul|gospel)/.test(key)) {
          patterns.push(
            [stepsPerBar - 6, stepsPerBar - 4, stepsPerBar - 1],
            [stepsPerBar - 7, stepsPerBar - 5, stepsPerBar - 3, stepsPerBar - 1],
            [3, 6, 9, 12, 14].filter(step => step < stepsPerBar)
          );
        } else if (/(hiphop|boom|trap|lofi)/.test(key)) {
          patterns.push(
            [stepsPerBar - 4, stepsPerBar - 2],
            [stepsPerBar - 5, stepsPerBar - 3, stepsPerBar - 1],
            [1, 4, 8, 11].filter(step => step < stepsPerBar)
          );
        } else if (/(rock|metal|punk|prog)/.test(key)) {
          patterns.push(
            endQuad,
            [stepsPerBar - 8, stepsPerBar - 6, stepsPerBar - 4, stepsPerBar - 2],
            [2, 4, 6, 8, 10, 12, 14].filter(step => step < stepsPerBar)
          );
        } else if (/(reggae|ska|dancehall|calypso)/.test(key)) {
          patterns.push(
            [stepsPerBar - 4, stepsPerBar - 2],
            [1, 5, 9, 13].filter(step => step < stepsPerBar)
          );
        } else if (/(electronic|edm|house|trance|dubstep)/.test(key)) {
          patterns.push(
            endQuad,
            [stepsPerBar - 8, stepsPerBar - 6, stepsPerBar - 3, stepsPerBar - 1],
            [1, 3, 5, 7, 9, 11, 13, 15].filter(step => step < stepsPerBar)
          );
        } else if (/(pop|indie|base|core)/.test(key)) {
          patterns.push(
            endQuad,
            [stepsPerBar - 6, stepsPerBar - 4, stepsPerBar - 2],
            [2, 6, 10, 14].filter(step => step < stepsPerBar),
            [1, 4, 7, 11, 15].filter(step => step < stepsPerBar)
          );
        } else {
          patterns.push(endTriplet, endQuad);
        }
        const randomCount = Math.max(3, Math.round(stepsPerBar * (0.2 + localRng() * 0.35)));
        const randomStart = Math.floor(localRng() * Math.max(1, stepsPerBar - randomCount + 1));
        const randomPattern = Array.from({ length: randomCount }, (_, index) => randomStart + index)
          .filter(step => step >= 0 && step < stepsPerBar && localRng() < 0.85);
        if (randomPattern.length >= 2) {
          patterns.push(randomPattern);
        }
        const filtered = patterns
          .map(pattern => pattern.filter(step => step >= 0 && step < stepsPerBar))
          .filter(pattern => pattern.length >= 2);
        if (filtered.length) {
          return filtered[Math.floor(localRng() * filtered.length)];
        }
        return endQuad.filter(step => step >= 0);
      }

      function buildFillSteps(stepsPerBar, styleKey, subKey, complexity, rng, barIndex, fillSeedOffset = 0) {
        const pattern = pickFillPattern(stepsPerBar, styleKey, subKey, rng, barIndex, fillSeedOffset);
        const density = 0.4 + complexity * 0.6;
        const pickChance = 0.55 + complexity * 0.35;
        const steps = pattern.filter(step => rng() < pickChance);
        const fillLen = Math.max(3, Math.round(stepsPerBar * (0.25 + complexity * 0.4)));
        const maxStart = Math.max(0, stepsPerBar - fillLen);
        const start = rng() < (0.45 + complexity * 0.35)
          ? maxStart
          : Math.floor(rng() * (maxStart + 1));
        const extra = Array.from({ length: fillLen }, (_, index) => start + index)
          .filter(step => step >= 0 && step < stepsPerBar && rng() < density);
        const combined = Array.from(new Set([...steps, ...extra]))
          .filter(step => step >= 0 && step < stepsPerBar)
          .sort((a, b) => a - b);
        return combined.length ? combined : pattern;
      }

      function generateUniqueFillSteps(stepsPerBar, styleKey, subKey, complexity, rng, barIndex, fillSeedOffset = 0) {
        const localRng = makeRng(`${seed}|fill-unique-${barIndex}-${fillSeedOffset}-${styleKey || "auto"}-${subKey || "base"}`);
        const count = Math.max(3, Math.round(stepsPerBar * (0.25 + complexity * 0.5)));
        const pool = Array.from({ length: stepsPerBar }, (_, index) => index);
        const picks = [];
        while (pool.length && picks.length < count) {
          const idx = Math.floor(localRng() * pool.length);
          picks.push(pool.splice(idx, 1)[0]);
        }
        const applySwing = localRng() < 0.45 + complexity * 0.2;
        const swung = picks.map(step => {
          if (!applySwing || stepsPerBar % 4 !== 0) return step;
          const offset = (step % 2 === 1 && localRng() < 0.6) ? 1 : 0;
          return Math.min(stepsPerBar - 1, step + offset);
        });
        const filtered = Array.from(new Set(swung)).sort((a, b) => a - b);
        return filtered.length >= 2 ? filtered : buildFillSteps(stepsPerBar, styleKey, subKey, complexity, rng, barIndex, fillSeedOffset);
      }

      for (let bar = 0; bar < bars; bar++) {
        const pickIndex = genreList.length ? Math.floor(rng() * genreList.length) : 0;
        const barGenre = genreList[pickIndex] || genre;
        const barMain = mainList[pickIndex] || mainList[0] || mainGenre || "";
        const resolvedStyle = resolveDrumStyle(barMain, barGenre, style);
        const preset = getDrumPatternPreset(barGenre, barMain, resolvedStyle, rng);
        const stepsPerBar = preset.stepsPerBar;
        stepBeat = 4 / stepsPerBar;
        const hatKeep = Math.min(1, 0.45 + density * 0.55);
        const hatSteps = (preset.hat || []).filter(step => rng() < hatKeep);
        const rideSteps = preset.ride || [];
        const kickSteps = preset.kick || [];
        const snareSteps = preset.snare || [];
        const rimSteps = preset.rim || [];
        const clapSteps = preset.clap || [];
        const ghostSteps = (preset.ghost && preset.ghost.length)
          ? preset.ghost
          : (ghosts > 0.25 ? [2, 6, 10, 14].filter(step => step < stepsPerBar) : []);
        const openHatSteps = preset.openHat || [];
        const extraKick = preset.extraKick || [];
        const tomFill = preset.tomFill || [];
        const seen = new Set();
        const hatNote = preset.hatNote || notes.closedHat;

        const densityScale = 0.35 + density * 0.65;
        const complexityScale = 0.2 + complexity * 0.8;
        const keepCore = 0.25 + densityScale * 0.35 + complexityScale * 0.4;
        const keepAlt = 0.2 + densityScale * 0.25 + complexityScale * 0.35;

        if (rideSteps.length) {
          rideSteps.forEach(step => {
            if (rng() < (hatKeep + 0.15) * densityScale) {
              pushHit(step, notes.ride, preset.velocities.ride, 1, bar, seen);
            }
          });
          [Math.round(stepsPerBar * 0.25), Math.round(stepsPerBar * 0.75)].forEach(step => {
            if (step >= 0 && step < stepsPerBar) {
              if (rng() < keepAlt) {
                pushHit(step, notes.closedHat, preset.velocities.hat, 1, bar, seen);
              }
            }
          });
        } else {
          hatSteps.forEach(step => {
            if (rng() < keepAlt) {
              pushHit(step, hatNote, preset.velocities.hat, 1, bar, seen);
            }
          });
        }

        kickSteps.forEach(step => {
          if (rng() < keepCore) {
            pushHit(step, notes.kick, preset.velocities.kick, 1, bar, seen);
          }
        });
        snareSteps.forEach(step => {
          if (rng() < keepCore) {
            pushHit(step, notes.snare, preset.velocities.snare, 1, bar, seen);
          }
        });
        rimSteps.forEach(step => {
          if (rng() < keepAlt) {
            pushHit(step, notes.rim, preset.velocities.rim, 1, bar, seen);
          }
        });
        clapSteps.forEach(step => {
          if (rng() < keepAlt) {
            pushHit(step, notes.clap, preset.velocities.clap, 1, bar, seen);
          }
        });

        extraKick.forEach(step => {
          if (rng() < densityScale * 0.45 * (0.4 + complexityScale)) {
            pushHit(step, notes.kick, Math.round(preset.velocities.kick * 0.85), 1, bar, seen);
          }
        });

        ghostSteps.forEach(step => {
          if (rng() < ghosts * (0.2 + complexityScale * 0.8)) {
            pushHit(step, notes.snare, preset.velocities.ghost, 1, bar, seen);
          }
        });

        if (ghosts > 0.5) {
          const hatGhostCandidates = stepsPerBar === 12
            ? [1, 2, 5, 7, 8, 11]
            : [1, 3, 5, 7, 9, 11, 13, 15];
          hatGhostCandidates.forEach(step => {
            if (step >= 0 && step < stepsPerBar && rng() < ghosts * 0.55) {
              pushHit(step, notes.closedHat, Math.round(preset.velocities.hat * 0.55), 1, bar, seen);
            }
          });
          if (ghosts > 0.85) {
            const kickGhosts = stepsPerBar === 12 ? [2, 5, 8, 11] : [2, 6, 10, 14];
            kickGhosts.forEach(step => {
              if (step >= 0 && step < stepsPerBar && rng() < ghosts * 0.35) {
                pushHit(step, notes.kick, Math.round(preset.velocities.kick * 0.5), 1, bar, seen);
              }
            });
          }
        }

        openHatSteps.forEach(step => {
          if (rng() < densityScale * 0.5 * (0.3 + complexityScale)) {
            pushHit(step, notes.openHat, preset.velocities.openHat, 2, bar, seen);
          }
        });

        if (!openHatSteps.length && density > 0.65 && rng() < densityScale) {
          const step = stepsPerBar - 2;
          if (step >= 0) {
            pushHit(step, notes.openHat, preset.velocities.openHat, 2, bar, seen);
          }
        }

        if (bar === 0 && rng() < 0.35 + density * 0.2) {
          pushHit(0, notes.crash, 92, Math.max(1, Math.round(stepsPerBar / 4)), bar, seen);
        }

        const fillEveryBar = fills >= 0.999;
        const isEndBar = bar >= bars - 1;
        const isPreEndBar = bar >= bars - 2;
        const baseFillChance = fills * (0.2 + complexity * 0.85);
        const midFillChance = fills * (0.12 + complexity * 0.6);
        const highBoost = fills >= 0.65 ? ((fills - 0.65) / 0.35) * 0.35 : 0;
        const endBoost = isPreEndBar ? (0.16 + complexity * 0.32) : 0;
        const barFillChance = clampValue((isEndBar ? baseFillChance : midFillChance) + endBoost + highBoost, 0, 0.98);
        const shouldFill = fillEveryBar || (fills > 0 && rng() < barFillChance);
        if (shouldFill) {
          const preferEnd = rng() < 0.5;
          const usePreset = tomFill.length && preferEnd && rng() < 0.6;
          const isCore = !resolvedStyle || resolvedStyle === "pop" || /base|core/.test(barGenre || "");
          const fillSteps = usePreset
            ? tomFill
            : (isCore && rng() < 0.7
              ? generateUniqueFillSteps(stepsPerBar, resolvedStyle, barGenre, complexity, rng, bar, fillPercent)
              : buildFillSteps(stepsPerBar, resolvedStyle, barGenre, complexity, rng, bar, fillPercent));
          const kit = (resolvedStyle === "jazz" || /jazz|latin|bossa|samba/.test(barGenre || ""))
            ? [notes.snare, notes.rim, notes.tomMid, notes.tomHigh]
            : [notes.tomLow, notes.tomMid, notes.tomHigh, notes.snare];
          const kitCycles = [
            kit,
            kit.slice().reverse(),
            [kit[1], kit[2], kit[0], kit[3]],
            [kit[2], kit[0], kit[3], kit[1]],
            [kit[3], kit[1], kit[2], kit[0]]
          ];
          const kitOrder = kitCycles[Math.floor(rng() * kitCycles.length)] || kit;
          fillSteps.forEach((step, index) => {
            if (step < 0 || step >= stepsPerBar) return;
            const tomNote = kitOrder[index % kitOrder.length] || kit[0];
            const vel = 74 + Math.round(complexity * 22) + (rng() < 0.35 ? 10 : 0);
            pushHit(step, tomNote, vel, 1, bar, seen);
          });
        }
      }

      return events;
    }

    function writeVarInt(value) {
      let buffer = value & 0x7f;
      const bytes = [];
      while ((value >>= 7)) {
        buffer <<= 8;
        buffer |= ((value & 0x7f) | 0x80);
      }
      while (true) {
        bytes.push(buffer & 0xff);
        if (buffer & 0x80) buffer >>= 8; else break;
      }
      return bytes;
    }

    function buildMidi(
      chords,
      bpm,
      bassNotes = [],
      melodyNotes = [],
      drumNotes = [],
      chordChannel = getChordChannel(),
      bassChannel = getBassChannel(),
      melodyChannel = getMelodyChannel(),
      drumChannel = getDrumChannel()
    ) {
      const ticksPerBeat = 480;
      const track = [];
      const events = [];

      function push(...bytes) { track.push(...bytes); }

      const tempo = Math.round(60000000 / bpm);
      events.push({ tick: 0, order: -3, bytes: [0xff, 0x58, 0x04, 0x04, 0x02, 0x18, 0x08] });
      events.push({ tick: 0, order: -2, bytes: [0xff, 0x51, 0x03, (tempo >> 16) & 0xff, (tempo >> 8) & 0xff, tempo & 0xff] });
      events.push({ tick: 0, order: -1, bytes: [0xc0 + chordChannel, 0x04] });
      events.push({ tick: 0, order: -1, bytes: [0xc0 + bassChannel, 0x32] });
      events.push({ tick: 0, order: -1, bytes: [0xc0 + melodyChannel, 0x50] });

      let tickCursor = 0;
      const beatSec = 60 / bpm;
      chords.forEach(chord => {
        const chordStart = tickCursor;
        const backingEvents = buildChordBackingEvents(chord, beatSec);
        backingEvents.forEach(event => {
          const startTick = chordStart + Math.max(0, Math.round(event.offset * ticksPerBeat));
          const durationTicks = Math.max(1, Math.round(event.duration * ticksPerBeat));
          event.notes.forEach(note => {
            events.push({ tick: startTick, order: 1, bytes: [0x90 + chordChannel, note, 92] });
          });
          event.notes.forEach(note => {
            events.push({ tick: startTick + durationTicks, order: 0, bytes: [0x80 + chordChannel, note, 0] });
          });
        });
        tickCursor += Math.max(1, Math.round(chord.duration * ticksPerBeat));
      });

      bassNotes.forEach(note => {
        const startTick = Math.max(0, Math.round(note.startBeat * ticksPerBeat));
        const durationTicks = Math.max(1, Math.round(note.duration * ticksPerBeat));
        events.push({ tick: startTick, order: 1, bytes: [0x90 + bassChannel, note.note, 84] });
        events.push({ tick: startTick + durationTicks, order: 0, bytes: [0x80 + bassChannel, note.note, 0] });
      });

      melodyNotes.forEach(note => {
        const startTick = Math.max(0, Math.round(note.startBeat * ticksPerBeat));
        const durationTicks = Math.max(1, Math.round(note.duration * ticksPerBeat));
        events.push({ tick: startTick, order: 1, bytes: [0x90 + melodyChannel, note.note, 96] });
        events.push({ tick: startTick + durationTicks, order: 0, bytes: [0x80 + melodyChannel, note.note, 0] });
      });

      drumNotes.forEach(hit => {
        const startTick = Math.max(0, Math.round(hit.startBeat * ticksPerBeat));
        const durationTicks = Math.max(1, Math.round(hit.duration * ticksPerBeat));
        const velocity = Math.max(1, Math.min(127, hit.velocity || 90));
        events.push({ tick: startTick, order: 1, bytes: [0x90 + drumChannel, hit.note, velocity] });
        events.push({ tick: startTick + durationTicks, order: 0, bytes: [0x80 + drumChannel, hit.note, 0] });
      });

      events.sort((a, b) => (a.tick - b.tick) || (a.order - b.order));
      let lastTick = 0;
      events.forEach(event => {
        const delta = event.tick - lastTick;
        lastTick = event.tick;
        push(...writeVarInt(delta), ...event.bytes);
      });

      push(...writeVarInt(0), 0xff, 0x2f, 0x00);

      const trackLength = track.length;
      const header = [
        0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06,
        0x00, 0x00, 0x00, 0x01, (ticksPerBeat >> 8) & 0xff, ticksPerBeat & 0xff
      ];
      const trackHeader = [
        0x4d, 0x54, 0x72, 0x6b,
        (trackLength >> 24) & 0xff,
        (trackLength >> 16) & 0xff,
        (trackLength >> 8) & 0xff,
        trackLength & 0xff
      ];

      return new Uint8Array([...header, ...trackHeader, ...track]);
    }

    function buildProgressionTokens(chords) {
      const tokens = [];
      let beatInBar = 0;
      const eps = 1e-6;

      chords.forEach((chord, index) => {
        tokens.push({ type: "chord", text: chord.name, index });
        beatInBar += chord.duration;
        if (beatInBar >= 4 - eps) {
          tokens.push({ type: "bar", text: " | " });
          beatInBar -= 4;
          if (beatInBar < eps) beatInBar = 0;
        } else {
          tokens.push({ type: "space", text: " " });
        }
      });

      if (tokens.length && tokens[tokens.length - 1].type !== "bar") {
        tokens.push({ type: "bar", text: " | " });
      }

      return tokens;
    }

    function formatProgressionTextFromTokens(tokens) {
      return tokens.map(token => token.text).join("").replace(/\s\|\s$/, "");
    }

    function renderProgressionHighlight(activeIndex) {
      if (!progressionHighlight) return;
      const html = chordTextTokens.map(token => {
        if (token.type === "chord") {
          if (token.index === activeIndex) {
            return `<mark>${token.text}</mark>`;
          }
          return token.text;
        }
        return token.text;
      }).join("");
      progressionHighlight.innerHTML = html.replace(/\s\|\s$/, "");
    }

    function renderBassTrack() {
      if (!bassTrack) return;
      bassTrack.innerHTML = "";
      bassClips = [];
      activeBassClips.clear();
      if (!currentBass || !currentBass.length) {
        bassTrack.style.height = "64px";
        return;
      }
      const notes = currentBass.map(note => note.note);
      const minNote = Math.min(...notes);
      const maxNote = Math.max(...notes);
      const laneCount = Math.max(3, Math.min(7, Math.round((maxNote - minNote) / 2) || 3));
      const laneHeight = 18;
      const padY = 6;
      const trackHeight = padY * 2 + laneHeight * laneCount;
      bassTrack.style.height = `${trackHeight}px`;
      currentBass.forEach((note, index) => {
        const clip = document.createElement("div");
        clip.className = "bass-clip";
        clip.style.left = `${note.startBeat * currentBeatPx}px`;
        clip.style.width = `${Math.max(currentBeatPx * 0.5, note.duration * currentBeatPx)}px`;
        let laneIndex = 0;
        if (maxNote > minNote) {
          const normalized = (maxNote - note.note) / (maxNote - minNote);
          laneIndex = Math.max(0, Math.min(laneCount - 1, Math.round(normalized * (laneCount - 1))));
        }
        clip.style.top = `${padY + laneIndex * laneHeight}px`;
        clip.textContent = noteLabelFromMidi(note.note);
        clip.addEventListener("click", (event) => {
          event.preventDefault();
          auditionBassNote(note.note, note.duration, note.startBeat, index);
        });
        bassTrack.appendChild(clip);
        bassClips.push({ el: clip, startBeat: note.startBeat, duration: note.duration, note: note.note });
      });
    }

    function renderMelodyTrack() {
      if (!melodyTrack) return;
      melodyTrack.innerHTML = "";
      melodyClips = [];
      activeMelodyClips.clear();
      if (!currentMelody || !currentMelody.length) {
        melodyTrack.style.height = "86px";
        return;
      }
      const notes = currentMelody.map(note => note.note);
      const minNote = Math.min(...notes);
      const maxNote = Math.max(...notes);
      const laneCount = Math.max(4, Math.min(9, Math.round((maxNote - minNote) / 2) || 4));
      const laneHeight = 20;
      const padY = 6;
      const trackHeight = padY * 2 + laneHeight * laneCount;
      melodyTrack.style.height = `${trackHeight}px`;
      currentMelody.forEach((note, index) => {
        const clip = document.createElement("div");
        clip.className = "melody-clip";
        clip.style.left = `${note.startBeat * currentBeatPx}px`;
        clip.style.width = `${Math.max(currentBeatPx * 0.4, note.duration * currentBeatPx)}px`;
        let laneIndex = 0;
        if (maxNote > minNote) {
          const normalized = (maxNote - note.note) / (maxNote - minNote);
          laneIndex = Math.max(0, Math.min(laneCount - 1, Math.round(normalized * (laneCount - 1))));
        }
        clip.style.top = `${padY + laneIndex * laneHeight}px`;
        clip.textContent = noteLabelFromMidi(note.note);
        clip.addEventListener("click", (event) => {
          event.preventDefault();
          auditionMelodyNote(note.note, note.duration, note.startBeat, index);
        });
        melodyTrack.appendChild(clip);
        melodyClips.push({ el: clip, startBeat: note.startBeat, duration: note.duration, note: note.note });
      });
    }

    function renderDrumTrack() {
      if (!drumTrack) return;
      drumTrack.innerHTML = "";
      drumClips = [];
      activeDrumClips.clear();
      updateDrumVelocityMax();
      if (!currentDrums || !currentDrums.length) {
        drumTrack.style.height = "64px";
        return;
      }
      const laneMap = new Map([
        [49, 0],
        [51, 1],
        [46, 2],
        [42, 3],
        [39, 4],
        [38, 5],
        [36, 6],
        [50, 7],
        [47, 8],
        [45, 9]
      ]);
      const laneCount = Math.max(7, Math.max(...currentDrums.map(hit => laneMap.get(hit.note) ?? 6)) + 1);
      const laneHeight = 14;
      const padY = 6;
      const trackHeight = padY * 2 + laneHeight * laneCount;
      drumTrack.style.height = `${trackHeight}px`;
      currentDrums.forEach((hit, index) => {
        const clip = document.createElement("div");
        clip.className = "drum-clip";
        clip.style.left = `${hit.startBeat * currentBeatPx}px`;
        clip.style.width = `${Math.max(currentBeatPx * 0.35, hit.duration * currentBeatPx)}px`;
        const laneIndex = laneMap.get(hit.note) ?? 6;
        clip.style.top = `${padY + laneIndex * laneHeight}px`;
        clip.textContent = drumLabelFromMidi(hit.note);
        clip.addEventListener("click", (event) => {
          event.preventDefault();
          auditionDrumHit(hit.note, hit.duration, hit.startBeat, index, hit.velocity);
        });
        drumTrack.appendChild(clip);
        drumClips.push({ el: clip, startBeat: hit.startBeat, duration: hit.duration, note: hit.note, velocity: hit.velocity });
      });
    }

    function rebuildMidi() {
      if (!currentChords.length) return;
      resolveBackingSettings();
      currentMidi = buildMidi(currentChords, currentBpm, currentBass, currentMelody, currentDrums);
      if (midiBlobUrl) {
        URL.revokeObjectURL(midiBlobUrl);
      }
      const midiBlob = new Blob([currentMidi], { type: "audio/midi" });
      midiBlobUrl = URL.createObjectURL(midiBlob);
    }

    function getBassSeedLabel(baseSeed, forceNew = false) {
      if (forceNew) {
        bassSeedCounter += 1;
        const rand = Math.random().toString(36).slice(2, 6);
        return `${baseSeed}|bass-${bassSeedCounter}-${rand}`;
      }
      return `${baseSeed}|bass-${bassSeedCounter}`;
    }

    function regenerateBass(forceNew = false) {
      if (!currentChords.length) return;
      const seedLabel = currentSeed || createRegenSeedLabel();
      const formComplexityValue = normalizePercent(formComplexityInput?.value, 0);
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const bassSeed = getBassSeedLabel(seedLabel, forceNew);
      const bassOptions = {
        chords: currentChords,
        seed: bassSeed,
        densityPercent: parseInt(bassDensityInput?.value, 10) || 0,
        movementPercent: parseInt(bassMovementInput?.value, 10) || 0,
        fillPercent: parseInt(bassFillsInput?.value, 10) || 0,
        restPercent: parseInt(bassRestsInput?.value, 10) || 0,
        colorPercent: parseInt(bassColorInput?.value, 10) || 0,
        subdivisionDensity: parseInt(bassSubdivisionDensityInput?.value, 10) || 0,
        subdivisionMode: bassSubdivisionInput?.value || "even",
        style: bassStyleInput?.value || "auto",
        register: parseInt(bassRegisterInput?.value, 10) || 36,
        genre: blendSubs || (bassGenreSub?.value || genreSub?.value || "base"),
        mainGenre: blendMains || (bassGenreMain?.value || genreMain?.value || ""),
        formComplexity: formComplexityValue
      };
      currentBass = (songMode && formEnabled && currentFormSections.length)
        ? generateBassLineWithForm({ ...bassOptions, sections: currentFormSections })
        : generateBassLine(bassOptions);
      bassAutoRegenerate = true;
      renderBassTrack();
      rebuildMidi();
    }

    function getMelodySeedLabel(baseSeed, forceNew = false) {
      if (forceNew) {
        melodySeedCounter += 1;
        const rand = Math.random().toString(36).slice(2, 6);
        return `${baseSeed}|melody-${melodySeedCounter}-${rand}`;
      }
      return `${baseSeed}|melody-${melodySeedCounter}`;
    }

    function regenerateMelody(forceNew = false) {
      if (!currentChords.length) return;
      const seedLabel = currentSeed || createRegenSeedLabel();
      const formComplexityValue = normalizePercent(formComplexityInput?.value, 0);
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const melodySeed = getMelodySeedLabel(seedLabel, forceNew);
      const melodyOptions = {
        chords: currentChords,
        seed: melodySeed,
        densityPercent: parseInt(melodyDensityInput?.value, 10) || 0,
        movementPercent: parseInt(melodyMovementInput?.value, 10) || 0,
        fillPercent: parseInt(melodyFillsInput?.value, 10) || 0,
        restPercent: parseInt(melodyRestsInput?.value, 10) || 0,
        colorPercent: parseInt(melodyColorInput?.value, 10) || 0,
        subdivisionDensity: parseInt(melodySubdivisionDensityInput?.value, 10) || 0,
        subdivisionMode: melodySubdivisionInput?.value || "even",
        style: melodyStyleInput?.value || "auto",
        register: parseInt(melodyRegisterInput?.value, 10) || 72,
        genre: blendSubs || (melodyGenreSub?.value || genreSub?.value || "base"),
        mainGenre: blendMains || (melodyGenreMain?.value || genreMain?.value || ""),
        formComplexity: formComplexityValue
      };
      currentMelody = (songMode && formEnabled && currentFormSections.length)
        ? generateMelodyLineWithForm({ ...melodyOptions, sections: currentFormSections })
        : generateMelodyLine(melodyOptions);
      melodyAutoRegenerate = true;
      renderMelodyTrack();
      rebuildMidi();
    }

    function getDrumSeedLabel(baseSeed, forceNew = false) {
      if (forceNew) {
        drumSeedCounter += 1;
        const rand = Math.random().toString(36).slice(2, 6);
        return `${baseSeed}|drum-${drumSeedCounter}-${rand}`;
      }
      return `${baseSeed}|drum-${drumSeedCounter}`;
    }

    function regenerateDrums(forceNew = false) {
      if (!currentChords.length) return;
      const seedLabel = currentSeed || createRegenSeedLabel();
      const formComplexityValue = normalizePercent(formComplexityInput?.value, 0);
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const drumSeed = getDrumSeedLabel(seedLabel, forceNew);
      const drumMain = blendMains || (drumGenreMain?.value || genreMain?.value || "");
      const drumSub = blendSubs || (drumGenreSub?.value || genreSub?.value || "base");
      const drumOptions = {
        bars: parseInt(barsInput?.value, 10) || 4,
        seed: drumSeed,
        densityPercent: parseInt(drumDensityInput?.value, 10) || 0,
        complexityPercent: parseInt(drumComplexityInput?.value, 10) || 0,
        fillPercent: parseInt(drumFillsInput?.value, 10) || 0,
        ghostPercent: parseInt(drumGhostInput?.value, 10) || 0,
        velocityPercent: parseInt(drumVelocityInput?.value, 10) || 100,
        style: drumStyleInput?.value || "auto",
        genre: drumSub,
        mainGenre: drumMain,
        formComplexity: formComplexityValue
      };
      currentDrums = (songMode && formEnabled && currentFormSections.length)
        ? generateDrumPatternWithForm({ ...drumOptions, sections: currentFormSections })
        : generateDrumPattern(drumOptions);
      drumAutoRegenerate = true;
      renderDrumTrack();
      rebuildMidi();
    }

    function sanitizeFileName(name) {
      const cleaned = name
        .toString()
        .trim()
        .replace(/\s+/g, "_")
        .replace(/[^a-zA-Z0-9_$-]/g, "");
      return cleaned.length ? cleaned : "change.machine";
    }

    function resetToDefaults() {
      stopPlayback();
      currentKeyUsed = "C";
      currentKeyLabel = "C";
      manualBlendGenres = [];
      manualBlendEnabled = false;
      currentSeed = createRegenSeedLabel();
      bassAutoRegenerate = false;
      bassSeedCounter = 0;
      melodyAutoRegenerate = false;
      melodySeedCounter = 0;
      drumAutoRegenerate = false;
      drumSeedCounter = 0;
      chordMuted = false;
      bassMuted = false;
      melodyMuted = false;
      drumMuted = false;
      updateMuteButton(chordMute, chordMuted);
      updateMuteButton(bassMute, bassMuted);
      updateMuteButton(melodyMute, melodyMuted);
      updateMuteButton(drumMute, drumMuted);
      if (keySelect) keySelect.value = "random";
      if (genreMain && genreSub) populateGenreSelects("core", "base");
      if (bassGenreMain && bassGenreSub && genreMain && genreSub) {
        populateGenreSelectsFor(bassGenreMain, bassGenreSub, genreMain.value, genreSub.value);
      }
      if (melodyGenreMain && melodyGenreSub && genreMain && genreSub) {
        populateGenreSelectsFor(melodyGenreMain, melodyGenreSub, genreMain.value, genreSub.value);
      }
      if (drumGenreMain && drumGenreSub) populateGenreSelectsFor(drumGenreMain, drumGenreSub, "core", "base");
      if (tempoInput) tempoInput.value = "75";
      if (tempoNumber) tempoNumber.value = "75";
      if (barsInput) barsInput.value = "4";
      if (formComplexityInput) formComplexityInput.value = "30";
      setFormEnabledState(false);
      if (densityInput) densityInput.value = "15";
      if (colorInput) colorInput.value = "50";
      if (modulationInput) modulationInput.value = "15";
      if (subdivisionDensityInput) subdivisionDensityInput.value = "20";
      if (subdivisionInput) subdivisionInput.value = "even";
      if (backingStyleInput) backingStyleInput.value = "blocks";
      if (backingCompInput) backingCompInput.value = "50";
      if (chordChannelSelect) chordChannelSelect.value = "1";
      if (bassChannelSelect) bassChannelSelect.value = "2";
      if (bassDensityInput) bassDensityInput.value = "55";
      if (bassMovementInput) bassMovementInput.value = "40";
      if (bassColorInput) bassColorInput.value = "50";
      if (bassFillsInput) bassFillsInput.value = "50";
      if (bassRestsInput) bassRestsInput.value = "50";
      if (bassSubdivisionDensityInput) bassSubdivisionDensityInput.value = "45";
      if (bassSubdivisionInput) bassSubdivisionInput.value = "even";
      if (bassStyleInput) bassStyleInput.value = "auto";
      if (bassRegisterInput) bassRegisterInput.value = "36";
      if (melodyChannelSelect) melodyChannelSelect.value = "3";
      if (melodyDensityInput) melodyDensityInput.value = "60";
      if (melodyMovementInput) melodyMovementInput.value = "55";
      if (melodyColorInput) melodyColorInput.value = "10";
      if (melodyFillsInput) melodyFillsInput.value = "45";
      if (melodyRestsInput) melodyRestsInput.value = "50";
      if (melodySubdivisionDensityInput) melodySubdivisionDensityInput.value = "55";
      if (melodySubdivisionInput) melodySubdivisionInput.value = "even";
      if (melodyStyleInput) melodyStyleInput.value = "auto";
      if (melodyRegisterInput) melodyRegisterInput.value = "72";
      if (drumDensityInput) drumDensityInput.value = "55";
      if (drumComplexityInput) drumComplexityInput.value = "45";
      if (drumFillsInput) drumFillsInput.value = "45";
      if (drumGhostInput) drumGhostInput.value = "40";
      if (drumVelocityInput) drumVelocityInput.value = "90";
      if (drumStyleInput) drumStyleInput.value = "auto";
      if (chordVolumeInput) chordVolumeInput.value = "100";
      if (bassVolumeInput) bassVolumeInput.value = "100";
      if (melodyVolumeInput) melodyVolumeInput.value = "100";
      if (drumVolumeInput) drumVolumeInput.value = "100";
      setTrackPlaybackMode("chord", "loop");
      setTrackPlaybackMode("bass", "loop");
      setTrackPlaybackMode("melody", "loop");
      setTrackPlaybackMode("drum", "loop");
      syncBlendSelects([]);
      updateTrackGains();
      if (midiEnabled) {
        midiEnabled = false;
        sendAllNotesOff();
        midiOutput = null;
        if (midiInput) {
          midiInput.onmidimessage = null;
          midiInput = null;
        }
        externalBpm = null;
        lastClockTime = null;
        clockSmoothing = null;
        tempoInput.disabled = false;
        if (tempoNumber) tempoNumber.disabled = false;
        if (midiVelocity) {
          midiVelocity.disabled = true;
          midiVelocity.value = "60";
          midiVelocityValue.textContent = "60";
        }
        midiToggle.textContent = "MIDI Out";
        document.body.classList.remove("midi-on");
        closeRouteModal();
      } else if (midiVelocity) {
        midiVelocity.value = "60";
        midiVelocityValue.textContent = "60";
      }
      if (themeSlider) {
        themeSlider.value = "0";
        applyThemeMix(0);
      }
      if (songMode) {
        setSongMode(false);
      }
      resolveBackingSettings();
      updateBackingCompVisibility(backingStyleInput?.value);
      updateReadouts();
      render();
    }

    const keySelect = document.getElementById("keySelect");
    const genreMain = document.getElementById("genreMain");
    const genreSub = document.getElementById("genreSub");
    const blendToggle = document.getElementById("blendToggle");
    const blendAdd = document.getElementById("blendAdd");
    const blendSelects = document.getElementById("blendSelects");
    const tempoInput = document.getElementById("tempo");
    const tempoReadout = document.getElementById("tempoReadout");
    const tempoNumber = document.getElementById("tempoNumber");
    const chordLoopButton = document.getElementById("chordLoopMode");
    const bassLoopButton = document.getElementById("bassLoopMode");
    const melodyLoopButton = document.getElementById("melodyLoopMode");
    const drumLoopButton = document.getElementById("drumLoopMode");
    const barsInput = document.getElementById("bars");
    const formToggle = document.getElementById("formToggle");
    const formComplexityInput = document.getElementById("formComplexity");
    const formComplexityReadout = document.getElementById("formComplexityReadout");
    const densityInput = document.getElementById("density");
    const colorInput = document.getElementById("color");
    const modulationInput = document.getElementById("modulation");
    const subdivisionDensityInput = document.getElementById("subdivisionDensity");
    const subdivisionInput = document.getElementById("subdivision");
    const backingStyleInput = document.getElementById("backingStyle");
    const backingCompWrap = document.getElementById("backingCompWrap");
    const backingCompInput = document.getElementById("backingComp");
    const backingCompReadout = document.getElementById("backingCompReadout");
    const themeSlider = document.getElementById("themeSlider");
    const midiToggle = document.getElementById("midiToggle");
    const midiRoute = document.getElementById("midiRoute");
    const routeModal = document.getElementById("routeModal");
    const routeClose = document.getElementById("routeClose");
    const midiOutSelect = document.getElementById("midiOutSelect");
    const midiInSelect = document.getElementById("midiInSelect");
    const midiVelocity = document.getElementById("midiVelocity");
    const midiVelocityValue = document.getElementById("midiVelocityValue");
    const randomSettings = document.getElementById("randomSettings");
    const helpButton = document.getElementById("helpButton");
    const helpModal = document.getElementById("helpModal");
    const helpClose = document.getElementById("helpClose");
    const helpText = document.getElementById("helpText");
    const resetAll = document.getElementById("resetAll");
    const barsReadout = document.getElementById("barsReadout");
    const densityReadout = document.getElementById("densityReadout");
    const colorReadout = document.getElementById("colorReadout");
    const modulationReadout = document.getElementById("modulationReadout");
    const subdivisionDensityReadout = document.getElementById("subdivisionDensityReadout");
    const chordPanel = document.getElementById("chordPanel");
    const chordCollapse = document.getElementById("chordCollapse");
    const chordMute = document.getElementById("chordMute");
    const bassPanel = document.getElementById("bassPanel");
    const bassGenerate = document.getElementById("bassGenerate");
    const bassCollapse = document.getElementById("bassCollapse");
    const bassMute = document.getElementById("bassMute");
    const bassDensityInput = document.getElementById("bassDensity");
    const bassDensityReadout = document.getElementById("bassDensityReadout");
    const bassMovementInput = document.getElementById("bassMovement");
    const bassMovementReadout = document.getElementById("bassMovementReadout");
    const bassColorInput = document.getElementById("bassColor");
    const bassColorReadout = document.getElementById("bassColorReadout");
    const bassFillsInput = document.getElementById("bassFills");
    const bassFillsReadout = document.getElementById("bassFillsReadout");
    const bassRestsInput = document.getElementById("bassRests");
    const bassRestsReadout = document.getElementById("bassRestsReadout");
    const bassSubdivisionDensityInput = document.getElementById("bassSubdivisionDensity");
    const bassSubdivisionDensityReadout = document.getElementById("bassSubdivisionDensityReadout");
    const bassSubdivisionInput = document.getElementById("bassSubdivision");
    const chordChannelSelect = document.getElementById("chordChannel");
    const bassChannelSelect = document.getElementById("bassChannel");
    const bassGenreMain = document.getElementById("bassGenreMain");
    const bassGenreSub = document.getElementById("bassGenreSub");
    const bassStyleInput = document.getElementById("bassStyle");
    const bassRegisterInput = document.getElementById("bassRegister");
    const bassRegisterReadout = document.getElementById("bassRegisterReadout");
    const bassRandom = document.getElementById("bassRandom");
    const chordVolumeInput = document.getElementById("chordVolume");
    const bassVolumeInput = document.getElementById("bassVolume");
    const melodyVolumeInput = document.getElementById("melodyVolume");
    const drumVolumeInput = document.getElementById("drumVolume");
    const melodyPanel = document.getElementById("melodyPanel");
    const melodyGenerate = document.getElementById("melodyGenerate");
    const melodyCollapse = document.getElementById("melodyCollapse");
    const melodyMute = document.getElementById("melodyMute");
    const drumPanel = document.getElementById("drumPanel");
    const drumGenerate = document.getElementById("drumGenerate");
    const drumCollapse = document.getElementById("drumCollapse");
    const drumMute = document.getElementById("drumMute");
    const drumGenreMain = document.getElementById("drumGenreMain");
    const drumGenreSub = document.getElementById("drumGenreSub");
    const melodyDensityInput = document.getElementById("melodyDensity");
    const melodyDensityReadout = document.getElementById("melodyDensityReadout");
    const melodyMovementInput = document.getElementById("melodyMovement");
    const melodyMovementReadout = document.getElementById("melodyMovementReadout");
    const melodyColorInput = document.getElementById("melodyColor");
    const melodyColorReadout = document.getElementById("melodyColorReadout");
    const melodyFillsInput = document.getElementById("melodyFills");
    const melodyFillsReadout = document.getElementById("melodyFillsReadout");
    const melodyRestsInput = document.getElementById("melodyRests");
    const melodyRestsReadout = document.getElementById("melodyRestsReadout");
    const melodySubdivisionDensityInput = document.getElementById("melodySubdivisionDensity");
    const melodySubdivisionDensityReadout = document.getElementById("melodySubdivisionDensityReadout");
    const melodySubdivisionInput = document.getElementById("melodySubdivision");
    const melodyChannelSelect = document.getElementById("melodyChannel");
    const melodyGenreMain = document.getElementById("melodyGenreMain");
    const melodyGenreSub = document.getElementById("melodyGenreSub");
    const melodyStyleInput = document.getElementById("melodyStyle");
    const melodyRegisterInput = document.getElementById("melodyRegister");
    const melodyRegisterReadout = document.getElementById("melodyRegisterReadout");
    const melodyRandom = document.getElementById("melodyRandom");
    const drumDensityInput = document.getElementById("drumDensity");
    const drumDensityReadout = document.getElementById("drumDensityReadout");
    const drumComplexityInput = document.getElementById("drumComplexity");
    const drumComplexityReadout = document.getElementById("drumComplexityReadout");
    const drumFillsInput = document.getElementById("drumFills");
    const drumFillsReadout = document.getElementById("drumFillsReadout");
    const drumGhostInput = document.getElementById("drumGhost");
    const drumGhostReadout = document.getElementById("drumGhostReadout");
    const drumVelocityInput = document.getElementById("drumVelocity");
    const drumVelocityReadout = document.getElementById("drumVelocityReadout");
    const drumStyleInput = document.getElementById("drumStyle");
    const drumRandom = document.getElementById("drumRandom");
    const timelineView = document.getElementById("timelineView");
    const ruler = document.getElementById("ruler");
    const track = document.getElementById("track");
    const bassTrack = document.getElementById("bassTrack");
    const melodyTrack = document.getElementById("melodyTrack");
    const drumTrack = document.getElementById("drumTrack");
    const formLane = document.getElementById("formLane");
    const selectToggle = document.getElementById("selectToggle");
    const timelineScroll = document.getElementById("timelineScroll");
    const progressionText = document.getElementById("progressionText");
    const progressionHighlight = document.getElementById("progressionHighlight");
    const copyProgression = document.getElementById("copyProgression");
    const playButton = document.getElementById("play");
    const generateButton = document.getElementById("generate");
    const mainActions = document.getElementById("mainActions");
    const oscilloscope = document.getElementById("oscilloscope");
    const footer = document.getElementById("footer");
    const songToggle = document.getElementById("songToggle");
    const titleLeft = document.getElementById("titleLeft");
    const titleRight = document.getElementById("titleRight");
    const undoButton = document.getElementById("undoButton");
    const redoButton = document.getElementById("redoButton");

    const randomOption = document.createElement("option");
    randomOption.value = "random";
    randomOption.textContent = "Random";
    keySelect.appendChild(randomOption);

    noteNames.forEach(name => {
      const option = document.createElement("option");
      option.value = name;
      option.textContent = name;
      keySelect.appendChild(option);
    });
    keySelect.value = "random";

    function populateChannelSelect(select, defaultValue) {
      if (!select) return;
      select.innerHTML = "";
      for (let i = 1; i <= 16; i++) {
        const option = document.createElement("option");
        option.value = String(i);
        option.textContent = String(i);
        select.appendChild(option);
      }
      select.value = String(defaultValue);
    }

    populateChannelSelect(chordChannelSelect, 1);
    populateChannelSelect(bassChannelSelect, 2);
    populateChannelSelect(melodyChannelSelect, 3);

    const genreCatalog = {
      core: {
        label: "Core",
        sub: {
          base: "Base",
          jazz: "Jazz",
          lofi: "Lo-fi",
          ambient: "Ambient"
        }
      },
      jazz: {
        label: "Jazz",
        sub: {
          jazz: "Jazz",
          bebop: "Bebop",
          "hard-bop": "Hard-bop",
          "cool-jazz": "Cool jazz",
          "modal-jazz": "Modal jazz",
          fusion: "Fusion",
          swing: "Swing",
          lofi: "Lo-fi",
          bossa: "Bossa nova",
          "latin-jazz": "Latin jazz",
          samba: "Samba",
          "gypsy-jazz": "Gypsy (manouche)"
        }
      },
      classical: {
        label: "Classical",
        sub: {
          baroque: "Baroque",
          classical: "Classical",
          romantic: "Romantic",
          impressionist: "Impressionist",
          "modern-classical": "Modern classical",
          neoclassical: "Neoclassical",
          minimalism: "Minimalism"
        }
      },
      rock: {
        label: "Rock",
        sub: {
          rock: "Rock",
          metal: "Metal",
          punk: "Punk",
          prog: "Prog",
          "post-rock": "Post-rock",
          indie: "Indie"
        }
      },
      soul: {
        label: "Soul / R&B",
        sub: {
          rnb: "R&B",
          soul: "Soul",
          "neo-soul": "Neo-soul",
          funk: "Funk",
          gospel: "Gospel"
        }
      },
      pop: {
        label: "Pop",
        sub: {
          pop: "Pop",
          "synth-pop": "Synth-pop",
          "indie-pop": "Indie pop",
          "dream-pop": "Dream pop"
        }
      },
      blues: {
        label: "Blues",
        sub: {
          blues: "Blues",
          "chicago-blues": "Chicago blues",
          "delta-blues": "Delta blues",
          "minor-blues": "Minor blues"
        }
      },
      caribbean: {
        label: "Caribbean",
        sub: {
          reggae: "Reggae",
          calypso: "Calypso",
          ska: "Ska",
          dancehall: "Dancehall"
        }
      },
      folk: {
        label: "Folk / Americana",
        sub: {
          folk: "Folk",
          americana: "Americana",
          country: "Country"
        }
      },
      electronic: {
        label: "Electronic",
        sub: {
          edm: "EDM",
          house: "House",
          downtempo: "Downtempo",
          trance: "Trance",
          dubstep: "Dubstep"
        }
      },
      hiphop: {
        label: "Hip-hop",
        sub: {
          "hip-hop": "Hip-hop",
          "boom-bap": "Boom bap",
          trap: "Trap",
          "lofi-hiphop": "Lo-fi hip-hop"
        }
      }
    };

    function populateSubgenresFor(mainKey, subSelect, preferredSub) {
      if (!subSelect) return;
      const group = genreCatalog[mainKey] || genreCatalog.core;
      subSelect.innerHTML = "";
      const keys = Object.keys(group.sub);
      keys.forEach(key => {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = group.sub[key];
        subSelect.appendChild(option);
      });
      if (preferredSub && group.sub[preferredSub]) {
        subSelect.value = preferredSub;
      } else {
        subSelect.value = keys[0];
      }
    }

    function populateGenreSelectsFor(mainSelect, subSelect, preferredMain, preferredSub) {
      if (!mainSelect || !subSelect) return;
      mainSelect.innerHTML = "";
      Object.keys(genreCatalog).forEach(key => {
        const option = document.createElement("option");
        option.value = key;
        option.textContent = genreCatalog[key].label;
        mainSelect.appendChild(option);
      });
      const mainValue = preferredMain && genreCatalog[preferredMain] ? preferredMain : "core";
      mainSelect.value = mainValue;
      populateSubgenresFor(mainValue, subSelect, preferredSub || "base");
    }

    function populateGenreSelects(preferredMain, preferredSub) {
      populateGenreSelectsFor(genreMain, genreSub, preferredMain, preferredSub);
    }

    function populateSubgenres(mainKey, preferredSub) {
      populateSubgenresFor(mainKey, genreSub, preferredSub);
    }

    populateGenreSelects("core", "base");
    populateGenreSelectsFor(drumGenreMain, drumGenreSub, "core", "base");
    if (bassGenreMain && bassGenreSub && genreMain && genreSub) {
      populateGenreSelectsFor(bassGenreMain, bassGenreSub, genreMain.value, genreSub.value);
    }
    if (melodyGenreMain && melodyGenreSub && genreMain && genreSub) {
      populateGenreSelectsFor(melodyGenreMain, melodyGenreSub, genreMain.value, genreSub.value);
    }
    function buildGenreLookup() {
      const subToMain = {};
      const labelToSub = {};
      Object.keys(genreCatalog).forEach(mainKey => {
        const sub = genreCatalog[mainKey].sub;
        Object.keys(sub).forEach(subKey => {
          subToMain[subKey] = mainKey;
          labelToSub[sub[subKey].toLowerCase()] = subKey;
        });
      });
      return { subToMain, labelToSub };
    }

    const genreLookup = buildGenreLookup();

    function getSubGenreLabel(subKey) {
      const main = genreLookup.subToMain[subKey];
      if (main && genreCatalog[main] && genreCatalog[main].sub[subKey]) {
        return genreCatalog[main].sub[subKey];
      }
      return subKey;
    }

    function populateBackingStyles() {
      if (!backingStyleInput) return;
      const current = backingStyleInput.value || "blocks";
      backingStyleInput.innerHTML = "";
      const baseOptions = [
        { value: "auto", label: "Auto (genre)" },
        { value: "random", label: "Random (style)" },
        { value: "blocks", label: "Blocks (sustain)" },
        { value: "rake", label: "Raked / Strum" },
        { value: "arp-up", label: "Arp Up" },
        { value: "arp-down", label: "Arp Down" },
        { value: "arp-updown", label: "Arp Up/Down" },
        { value: "arp-alt", label: "Arp Alternate" },
        { value: "chop", label: "Chopped" },
        { value: "stabs", label: "Short Stabs" },
        { value: "genre-comp", label: "Genre Comp (current)" }
      ];
      baseOptions.forEach(optionDef => {
        const option = document.createElement("option");
        option.value = optionDef.value;
        option.textContent = optionDef.label;
        backingStyleInput.appendChild(option);
      });

      const group = document.createElement("optgroup");
      group.label = "Comp Styles";
      Object.keys(genreCatalog).forEach(mainKey => {
        const sub = genreCatalog[mainKey].sub;
        Object.keys(sub).forEach(subKey => {
          const option = document.createElement("option");
          option.value = `comp:${mainKey}:${subKey}`;
          option.textContent = `Comp: ${sub[subKey]} (${genreCatalog[mainKey].label})`;
          group.appendChild(option);
        });
      });
      backingStyleInput.appendChild(group);

      const hasCurrent = Array.from(backingStyleInput.options).some(option => option.value === current);
      backingStyleInput.value = hasCurrent ? current : "blocks";
      updateBackingCompVisibility(backingStyleInput.value);
    }

    function getActiveBlend() {
      if (manualBlendEnabled && manualBlendGenres.length) {
        return {
          subs: manualBlendGenres.map(value => {
            const parts = value.split(":");
            return parts[1] || value;
          }),
          mains: manualBlendGenres.map(value => {
            const parts = value.split(":");
            return parts[0] || genreLookup.subToMain[value] || "";
          })
        };
      }
      return null;
    }

    function getAutoBackingStyle(mainKey, subKey) {
      const key = (subKey || "").toLowerCase();
      const main = (mainKey || "").toLowerCase();
      if (["reggae", "ska", "dancehall", "calypso"].includes(key)) return "chop";
      if (["funk", "neo-soul", "rnb", "soul", "gospel"].includes(key)) return "chop";
      if (["bossa", "latin-jazz", "samba"].includes(key)) return "arp-up";
      if (["baroque", "classical", "romantic", "impressionist", "modern-classical", "neoclassical", "minimalism"].includes(key)) {
        return "arp-updown";
      }
      if (["bebop", "hard-bop", "cool-jazz", "modal-jazz", "swing", "jazz", "fusion", "gypsy-jazz"].includes(key)) {
        return "genre-comp";
      }
      if (["blues", "chicago-blues", "delta-blues", "minor-blues"].includes(key)) return "genre-comp";
      if (["rock", "metal", "punk", "prog", "post-rock", "indie"].includes(key)) return "stabs";
      if (["pop", "synth-pop", "indie-pop", "dream-pop"].includes(key)) return "stabs";
      if (["hip-hop", "boom-bap", "trap", "lofi-hiphop"].includes(key)) return "stabs";
      if (["edm", "house", "downtempo", "trance", "dubstep"].includes(key)) return "chop";
      if (main === "jazz") return "genre-comp";
      if (main === "core" || key === "base") return "genre-comp";
      if (main === "classical") return "arp-updown";
      if (main === "rock" || main === "pop" || main === "hiphop") return "stabs";
      return "blocks";
    }

    function getGenreCompPattern(mainKey, subKey) {
      const key = (subKey || "").toLowerCase();
      const main = (mainKey || "").toLowerCase();
      const patterns = {
        base: { steps: [0, 2], duration: 0.4 },
        ambient: { steps: [0], duration: 1.6 },
        lofi: { steps: [0, 2.5], duration: 0.6 },
        jazz: { steps: [0, 1.5, 2.5, 3.5], duration: 0.35 },
        bebop: { steps: [0, 1.5, 2.5, 3.75], duration: 0.28 },
        "hard-bop": { steps: [0, 1.5, 2.5, 3.25], duration: 0.3 },
        "cool-jazz": { steps: [0, 2, 3.5], duration: 0.4 },
        "modal-jazz": { steps: [0, 1.5, 2.5, 3.5], duration: 0.34 },
        swing: { steps: [0, 1.5, 2.5, 3.5], duration: 0.34 },
        fusion: { steps: [0, 1.5, 2.5, 3], duration: 0.3 },
        "gypsy-jazz": { steps: [0, 1.5, 2.5, 3.5], duration: 0.22 },
        bossa: { steps: [0, 1.5, 2, 3.5], duration: 0.28 },
        "latin-jazz": { steps: [0, 1.5, 2, 3.5], duration: 0.26 },
        samba: { steps: [0, 1.5, 2.5, 3.5], duration: 0.22 },
        reggae: { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.18 },
        ska: { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.18 },
        dancehall: { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.2 },
        calypso: { steps: [0, 1.5, 2.5, 3.5], duration: 0.22 },
        funk: { steps: [0, 1.5, 2.75, 3.5], duration: 0.24 },
        "neo-soul": { steps: [0.25, 1.75, 2.75, 3.5], duration: 0.28 },
        rnb: { steps: [0, 1.5, 2.5, 3.5], duration: 0.3 },
        soul: { steps: [0, 1.5, 2.5, 3.5], duration: 0.3 },
        gospel: { steps: [0, 1.5, 2.5, 3.5], duration: 0.32 },
        blues: { steps: [0, 2, 3.5], duration: 0.32 },
        "chicago-blues": { steps: [0, 2, 3.5], duration: 0.32 },
        "delta-blues": { steps: [0, 2, 3.5], duration: 0.32 },
        "minor-blues": { steps: [0, 2, 3.5], duration: 0.32 },
        rock: { steps: [0, 2], duration: 0.45 },
        metal: { steps: [0, 2], duration: 0.42 },
        punk: { steps: [0, 1, 2, 3], duration: 0.26 },
        prog: { steps: [0, 1.5, 2.5, 3], duration: 0.28 },
        "post-rock": { steps: [0], duration: 0.8 },
        indie: { steps: [0, 2], duration: 0.45 },
        pop: { steps: [0, 2], duration: 0.35 },
        "synth-pop": { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.22 },
        "indie-pop": { steps: [0, 2], duration: 0.35 },
        "dream-pop": { steps: [0], duration: 0.8 },
        folk: { steps: [0, 2], duration: 0.42 },
        americana: { steps: [0, 2], duration: 0.42 },
        country: { steps: [0, 2], duration: 0.4 },
        "hip-hop": { steps: [0, 2], duration: 0.4 },
        "boom-bap": { steps: [0, 2], duration: 0.4 },
        trap: { steps: [0, 2.5], duration: 0.32 },
        "lofi-hiphop": { steps: [0, 2], duration: 0.55 },
        edm: { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.2 },
        house: { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.2 },
        downtempo: { steps: [0, 2, 3.5], duration: 0.42 },
        trance: { steps: [0.5, 1.5, 2.5, 3.5], duration: 0.22 },
        dubstep: { steps: [0, 2.5], duration: 0.24 },
        baroque: { steps: [0, 1, 2, 3], duration: 0.3 },
        classical: { steps: [0, 1, 2, 3], duration: 0.32 },
        romantic: { steps: [0, 1, 2, 3], duration: 0.34 },
        impressionist: { steps: [0, 1.5, 2.5, 3.5], duration: 0.35 },
        "modern-classical": { steps: [0, 1, 2.5, 3.5], duration: 0.3 },
        neoclassical: { steps: [0, 1, 2, 3], duration: 0.3 },
        minimalism: { steps: [0, 2], duration: 0.5 }
      };
      if (patterns[key]) return patterns[key];
      if (patterns[main]) return patterns[main];
      return { steps: [0, 2], duration: 0.35 };
    }

    function resolveBackingSettings() {
      const selection = backingStyleInput?.value || "blocks";
      if (selection.startsWith("comp:")) {
        const parts = selection.split(":");
        const mainKey = parts[1] || genreMain?.value || "";
        const subKey = parts[2] || genreSub?.value || "";
        currentBackingGenre = { main: mainKey, sub: subKey };
        currentBackingStyle = "genre-comp";
        return;
      }
      const blend = getActiveBlend();
      const blendSubs = blend && blend.subs && blend.subs.length ? blend.subs : null;
      const blendPick = blendSubs ? blendSubs[0] : null;
      const mainKey = blendPick ? genreLookup.subToMain[blendPick] || genreMain?.value || "" : (genreMain?.value || "");
      const subKey = blendPick || (genreSub?.value || "");
      currentBackingGenre = { main: mainKey, sub: subKey };
      if (selection === "auto") {
        currentBackingStyle = getAutoBackingStyle(mainKey, subKey);
      } else if (selection === "random") {
        if (!randomBackingStyle) {
          randomBackingStyle = pickRandomBackingStyle();
        }
        currentBackingStyle = randomBackingStyle;
      } else {
        currentBackingStyle = selection;
      }
    }

    function isCompBackingSelection(value) {
      if (!value) return false;
      return value === "genre-comp" || value.startsWith("comp:");
    }

    function getBackingGenreFromSelection(selection) {
      const value = selection || backingStyleInput?.value || "";
      if (value.startsWith("comp:")) {
        const parts = value.split(":");
        return {
          main: parts[1] || genreMain?.value || "",
          sub: parts[2] || genreSub?.value || ""
        };
      }
      const blend = getActiveBlend();
      const blendSubs = blend && blend.subs && blend.subs.length ? blend.subs : null;
      const blendPick = blendSubs ? blendSubs[0] : null;
      const mainKey = blendPick ? genreLookup.subToMain[blendPick] || genreMain?.value || "" : (genreMain?.value || "");
      const subKey = blendPick || (genreSub?.value || "");
      return { main: mainKey, sub: subKey };
    }

    function updateBackingCompVisibility(value) {
      if (!backingCompWrap) return;
      const selection = value || backingStyleInput?.value || "";
      let show = false;
      if (selection === "auto" || selection === "random") {
        show = true;
      } else if (selection.startsWith("arp")) {
        show = true;
      } else if (isCompBackingSelection(selection)) {
        show = true;
      }
      backingCompWrap.classList.toggle("hidden", !show);
    }

    function pickRandomBackingStyle() {
      const options = ["blocks", "rake", "arp-up", "arp-down", "arp-updown", "arp-alt", "chop", "stabs", "genre-comp"];
      return options[Math.floor(Math.random() * options.length)] || "blocks";
    }

    function getBackingComplexity() {
      if (!backingCompInput) return 50;
      const value = parseInt(backingCompInput.value, 10);
      if (Number.isNaN(value)) return 50;
      return Math.max(0, Math.min(100, value));
    }

    function buildChordBackingEvents(chord, beatSec, styleOverride = null, genreOverride = null) {
      let style = styleOverride || currentBackingStyle || "blocks";
      const genre = genreOverride || currentBackingGenre;
      if (style === "auto") {
        style = getAutoBackingStyle(genre?.main, genre?.sub);
      }
      const duration = Math.max(0.05, chord.duration);
      const notes = (chord.notes || []).slice();
      if (!notes.length) return [];
      const asc = notes.slice().sort((a, b) => a - b);
      const desc = asc.slice().reverse();
      const events = [];
      const pushEvent = (offset, dur, noteList) => {
        if (!noteList || !noteList.length) return;
        if (offset >= duration) return;
        const end = Math.min(duration, offset + dur);
        const safeDur = Math.max(0.05, end - offset);
        events.push({ offset, duration: safeDur, notes: noteList });
      };
      const addPatternSteps = (steps, hitDur) => {
        const bars = Math.max(1, Math.ceil(duration / 4));
        for (let bar = 0; bar < bars; bar++) {
          const barStart = bar * 4;
          steps.forEach(step => {
            const start = barStart + step;
            if (start < duration) {
              pushEvent(start, hitDur, notes);
            }
          });
        }
      };

      if (style === "blocks") {
        pushEvent(0, duration, notes);
        return events;
      }

      if (style === "rake") {
        const strumSec = 0.03;
        const offsetBeat = Math.min(0.15, strumSec / Math.max(beatSec, 0.001));
        asc.forEach((note, index) => {
          const offset = index * offsetBeat;
          pushEvent(offset, Math.max(duration - offset, offsetBeat * 1.5), [note]);
        });
        return events;
      }

      if (style.startsWith("arp")) {
        const complexity = getBackingComplexity() / 100;
        const baseStep = duration >= 2 ? 0.5 : 0.25;
        const baseCount = Math.max(2, Math.round(duration / baseStep));
        const targetCount = Math.max(2, Math.round(baseCount * (1 + complexity * 0.8)));
        const stepsCount = Math.min(32, targetCount);
        const step = duration / stepsCount;
        const gate = Math.max(0.45, Math.min(0.95, 0.95 - complexity * 0.35));
        let sequence = asc;
        if (style === "arp-down") sequence = desc;
        if (style === "arp-updown") {
          sequence = asc.concat(asc.slice(1, -1).reverse());
        }
        if (style === "arp-alt") {
          const alt = [];
          let left = 0;
          let right = asc.length - 1;
          while (left <= right) {
            alt.push(asc[left]);
            if (right !== left) alt.push(asc[right]);
            left += 1;
            right -= 1;
          }
          sequence = alt;
        }
        let index = 0;
        for (let t = 0; t < duration - 1e-4; t += step) {
          const note = sequence[index % sequence.length];
          pushEvent(t, Math.min(step * gate, duration - t), [note]);
          index += 1;
        }
        return events;
      }

      if (style === "chop") {
        const hitDur = Math.min(0.25, duration * 0.6);
        const steps = [0.5, 1.5, 2.5, 3.5];
        addPatternSteps(steps, hitDur);
        if (!events.length) pushEvent(0, Math.min(duration, 0.3), notes);
        return events;
      }

      if (style === "stabs") {
        const hitDur = Math.min(0.35, duration * 0.7);
        const steps = [0, 1, 2, 3];
        addPatternSteps(steps, hitDur);
        if (!events.length) pushEvent(0, Math.min(duration, 0.35), notes);
        return events;
      }

      if (style === "genre-comp") {
        const pattern = getGenreCompPattern(genre?.main, genre?.sub);
        const complexity = getBackingComplexity() / 100;
        let steps = pattern.steps.slice();
        if (complexity > 0.35) {
          const extras = steps.map(step => step + 0.25).filter(step => step < 4);
          steps = Array.from(new Set(steps.concat(extras))).sort((a, b) => a - b);
        }
        if (complexity > 0.7) {
          const extras = steps.map(step => step + 0.5).filter(step => step < 4);
          steps = Array.from(new Set(steps.concat(extras))).sort((a, b) => a - b);
        }
        const durScale = Math.max(0.7, 1 - complexity * 0.25);
        const hitDur = Math.min(pattern.duration * durScale, duration * 0.8);
        addPatternSteps(steps, hitDur);
        if (!events.length) pushEvent(0, Math.min(duration, 0.4), notes);
        return events;
      }

      pushEvent(0, duration, notes);
      return events;
    }

    function playChordBacking(chord, startTime, beatSec) {
      const events = buildChordBackingEvents(chord, beatSec);
      events.forEach(event => {
        playChordAtTime(event.notes, startTime + event.offset * beatSec, event.duration * beatSec);
      });
    }

    function scheduleMidiChordBacking(chord, startMs, beatSec, allowWhenStopped = false) {
      if (!midiOutput || chordMuted) return;
      const events = buildChordBackingEvents(chord, beatSec);
      const durationMs = Math.max(0, chord.duration * beatSec * 1000);
      const onId = setTimeout(() => {
        if (chordMuted || (!isPlaying && !allowWhenStopped)) return;
        sendChordPanic();
        const velocity = getMidiVelocity();
        events.forEach(event => {
          const eventOnId = setTimeout(() => {
            if (chordMuted || (!isPlaying && !allowWhenStopped)) return;
            const channel = getChordChannel();
            event.notes.forEach(note => sendChordNoteOn(note, velocity, channel));
            const offId = setTimeout(() => {
              event.notes.forEach(note => sendChordNoteOffOnChannel(note, channel));
            }, Math.max(0, event.duration * beatSec * 1000));
            playTimers.push(offId);
          }, Math.max(0, event.offset * beatSec * 1000));
          playTimers.push(eventOnId);
        });
      }, Math.max(0, startMs));
      playTimers.push(onId);
      const endPanicId = setTimeout(() => {
        sendChordPanic();
      }, Math.max(0, startMs + Math.max(0, durationMs - 2)));
      playTimers.push(endPanicId);
    }

    function buildBlendSelect(selectedValue) {
      const select = document.createElement("select");
      select.className = "blend-select";
      Object.keys(genreCatalog).forEach(mainKey => {
        const sub = genreCatalog[mainKey].sub;
        Object.keys(sub).forEach(subKey => {
          const option = document.createElement("option");
          option.value = `${mainKey}:${subKey}`;
          option.textContent = `${sub[subKey]} (${genreCatalog[mainKey].label})`;
          select.appendChild(option);
        });
      });
      if (selectedValue) {
        select.value = selectedValue;
      }
      select.addEventListener("change", () => {
        updateManualBlendFromSelects();
      });
      return select;
    }

    function updateManualBlendFromSelects(forceEnable = false) {
      if (!blendSelects) return;
      const values = Array.from(blendSelects.querySelectorAll("select"))
        .map(select => select.value)
        .filter(Boolean);
      const seen = new Set();
      manualBlendGenres = values.filter(value => {
        if (seen.has(value)) return false;
        seen.add(value);
        return true;
      });
      const body = document.body;
      const blendActive = (body && body.classList.contains("blend-mode")) || forceEnable;
      manualBlendEnabled = blendActive && manualBlendGenres.length > 0;
    }

    function syncBlendSelects(values) {
      if (!blendSelects) return;
      blendSelects.innerHTML = "";
      const list = values && values.length ? values.slice(0, 4) : [];
      if (!list.length) {
        list.push("");
      }
      list.forEach(value => {
        const select = buildBlendSelect(value);
        blendSelects.appendChild(select);
      });
      updateManualBlendFromSelects();
    }

    let oscStrokeColor = "rgba(67, 255, 180, 1)";
    let oscShadowColor = "rgba(67, 255, 180, 0.5)";
    let oscMidColor = "rgba(67, 255, 180, 0.2)";
    let oscFillColor = "rgba(0, 0, 0, 0)";

    function updateThemeColors() {
      const root = getComputedStyle(document.documentElement);
      const glowRgb = root.getPropertyValue("--glow-rgb").trim() || "67, 255, 180";
      oscStrokeColor = `rgba(${glowRgb}, 1)`;
      oscShadowColor = `rgba(${glowRgb}, 0.5)`;
      oscMidColor = `rgba(${glowRgb}, 0.2)`;
      oscFillColor = "rgba(0, 0, 0, 0)";
    }

    const themes = [
      {
        name: "Neo Green",
        vars: {
          "--bg": "#0a0f0c",
          "--bg-2": "#0f2a1e",
          "--bg-3": "#050806",
          "--grid-rgb": "82, 255, 171",
          "--text": "#c9ffe7",
          "--muted": "#7fe6c1",
          "--muted-rgb": "127, 230, 193",
          "--glow": "#43ffb4",
          "--glow-rgb": "67, 255, 180",
          "--accent": "#ffb84a",
          "--accent-rgb": "255, 184, 74",
          "--border-rgb": "110, 255, 198",
          "--panel-border-rgb": "103, 255, 190",
          "--panel": "rgba(7, 18, 14, 0.85)",
          "--scanline": "rgba(10, 26, 20, 0.35)",
          "--input-bg": "#040b08",
          "--timeline-bg": "rgba(4, 10, 8, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(7, 32, 20, 0.9), rgba(8, 64, 40, 0.9))"
        }
      },
      {
        name: "Amber CRT",
        vars: {
          "--bg": "#1a1208",
          "--bg-2": "#2a1b0f",
          "--bg-3": "#0b0704",
          "--grid-rgb": "255, 196, 120",
          "--text": "#ffe8c6",
          "--muted": "#f0c998",
          "--muted-rgb": "240, 201, 152",
          "--glow": "#ffb347",
          "--glow-rgb": "255, 179, 71",
          "--accent": "#4ad1ff",
          "--accent-rgb": "74, 209, 255",
          "--border-rgb": "255, 199, 128",
          "--panel-border-rgb": "255, 190, 120",
          "--panel": "rgba(24, 14, 8, 0.88)",
          "--scanline": "rgba(30, 18, 10, 0.4)",
          "--input-bg": "#140c06",
          "--timeline-bg": "rgba(18, 11, 6, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(60, 32, 12, 0.9), rgba(90, 45, 16, 0.9))"
        }
      },
      {
        name: "Ice Blue",
        vars: {
          "--bg": "#07131c",
          "--bg-2": "#0b2433",
          "--bg-3": "#04070c",
          "--grid-rgb": "120, 200, 255",
          "--text": "#d8f4ff",
          "--muted": "#9ad5e8",
          "--muted-rgb": "154, 213, 232",
          "--glow": "#78d8ff",
          "--glow-rgb": "120, 216, 255",
          "--accent": "#ffb4d6",
          "--accent-rgb": "255, 180, 214",
          "--border-rgb": "130, 214, 255",
          "--panel-border-rgb": "120, 200, 240",
          "--panel": "rgba(8, 18, 26, 0.88)",
          "--scanline": "rgba(7, 20, 30, 0.35)",
          "--input-bg": "#061019",
          "--timeline-bg": "rgba(6, 14, 22, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(10, 40, 60, 0.9), rgba(12, 70, 96, 0.9))"
        }
      },
      {
        name: "Violet Flux",
        vars: {
          "--bg": "#11081e",
          "--bg-2": "#2a1240",
          "--bg-3": "#07050c",
          "--grid-rgb": "190, 140, 255",
          "--text": "#f1ddff",
          "--muted": "#c9a8e8",
          "--muted-rgb": "201, 168, 232",
          "--glow": "#d08bff",
          "--glow-rgb": "208, 139, 255",
          "--accent": "#5cffc8",
          "--accent-rgb": "92, 255, 200",
          "--border-rgb": "190, 150, 255",
          "--panel-border-rgb": "180, 140, 240",
          "--panel": "rgba(20, 10, 30, 0.88)",
          "--scanline": "rgba(20, 10, 30, 0.35)",
          "--input-bg": "#0d0614",
          "--timeline-bg": "rgba(12, 7, 18, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(38, 16, 70, 0.9), rgba(68, 28, 110, 0.9))"
        }
      },
      {
        name: "Crimson Night",
        vars: {
          "--bg": "#1a0a0c",
          "--bg-2": "#3a1216",
          "--bg-3": "#070304",
          "--grid-rgb": "255, 120, 120",
          "--text": "#ffe6e1",
          "--muted": "#f0b2a8",
          "--muted-rgb": "240, 178, 168",
          "--glow": "#ff6b6b",
          "--glow-rgb": "255, 107, 107",
          "--accent": "#ffd166",
          "--accent-rgb": "255, 209, 102",
          "--border-rgb": "255, 140, 140",
          "--panel-border-rgb": "255, 120, 120",
          "--panel": "rgba(24, 8, 10, 0.88)",
          "--scanline": "rgba(30, 10, 12, 0.4)",
          "--input-bg": "#140608",
          "--timeline-bg": "rgba(16, 7, 9, 0.65)",
          "--button-bg": "linear-gradient(120deg, rgba(60, 16, 22, 0.9), rgba(96, 24, 32, 0.9))"
        }
      }
    ];

    function parseRgb(value, fallback) {
      if (!value) return fallback;
      if (value.trim().startsWith("rgba")) {
        const match = value.match(/rgba\\(([^)]+)\\)/i);
        if (match) value = match[1];
      }
      if (value.includes(",")) {
        const parts = value.split(",").map(part => parseFloat(part.trim()));
        if (parts.length >= 3 && parts.every(num => Number.isFinite(num))) {
          return [parts[0], parts[1], parts[2]];
        }
      }
      return fallback;
    }

    function parseHex(value, fallback) {
      if (!value) return fallback;
      const hex = value.trim().replace("#", "");
      if (hex.length === 6) {
        const r = parseInt(hex.slice(0, 2), 16);
        const g = parseInt(hex.slice(2, 4), 16);
        const b = parseInt(hex.slice(4, 6), 16);
        if ([r, g, b].every(num => Number.isFinite(num))) {
          return [r, g, b];
        }
      }
      return fallback;
    }

    function mixValue(a, b, t) {
      return a + (b - a) * t;
    }

    function mixRgb(a, b, t) {
      return [
        Math.round(mixValue(a[0], b[0], t)),
        Math.round(mixValue(a[1], b[1], t)),
        Math.round(mixValue(a[2], b[2], t))
      ];
    }

    function toRgbString(rgb) {
      return `${rgb[0]}, ${rgb[1]}, ${rgb[2]}`;
    }

    function toHex(rgb) {
      return `#${rgb.map(channel => Math.max(0, Math.min(255, channel)).toString(16).padStart(2, "0")).join("")}`;
    }

    function parseRgba(value, fallback) {
      const match = value.match(/rgba\\(([^)]+)\\)/i);
      if (!match) return fallback;
      const parts = match[1].split(",").map(part => part.trim());
      if (parts.length < 4) return fallback;
      const rgb = parseRgb(parts.slice(0, 3).join(","), fallback.rgb);
      const alpha = Number.parseFloat(parts[3]);
      return { rgb, alpha: Number.isFinite(alpha) ? alpha : fallback.alpha };
    }

    function mixRgba(a, b, t) {
      const rgb = mixRgb(a.rgb, b.rgb, t);
      const alpha = mixValue(a.alpha, b.alpha, t);
      return { rgb, alpha };
    }

    function toRgbaString(value) {
      return `rgba(${value.rgb[0]}, ${value.rgb[1]}, ${value.rgb[2]}, ${value.alpha.toFixed(2)})`;
    }

    function parseLinearGradient(value, fallback) {
      const match = value.match(/linear-gradient\\([^,]+,\\s*(rgba\\([^\\)]+\\))\\s*,\\s*(rgba\\([^\\)]+\\))\\s*\\)/i);
      if (!match) return fallback;
      return {
        start: parseRgba(match[1], fallback.start),
        end: parseRgba(match[2], fallback.end)
      };
    }

    function mixLinearGradient(a, b, t, angle) {
      const start = mixRgba(a.start, b.start, t);
      const end = mixRgba(a.end, b.end, t);
      return `linear-gradient(${angle}, ${toRgbaString(start)}, ${toRgbaString(end)})`;
    }

    function applyThemeMix(value) {
      if (!themes.length) return;
      const maxIndex = themes.length - 1;
      const clamped = Math.max(0, Math.min(maxIndex, value));
      const baseIndex = Math.floor(clamped);
      const nextIndex = Math.min(maxIndex, baseIndex + 1);
      const t = clamped - baseIndex;
      const base = themes[baseIndex].vars;
      const next = themes[nextIndex].vars;
      const root = document.documentElement;

      const bg = toHex(mixRgb(parseHex(base["--bg"], [10, 15, 12]), parseHex(next["--bg"], [10, 15, 12]), t));
      const bg2 = toHex(mixRgb(parseHex(base["--bg-2"], [15, 42, 30]), parseHex(next["--bg-2"], [15, 42, 30]), t));
      const bg3 = toHex(mixRgb(parseHex(base["--bg-3"], [5, 8, 6]), parseHex(next["--bg-3"], [5, 8, 6]), t));
      const text = toHex(mixRgb(parseHex(base["--text"], [201, 255, 231]), parseHex(next["--text"], [201, 255, 231]), t));
      const muted = toHex(mixRgb(parseHex(base["--muted"], [127, 230, 193]), parseHex(next["--muted"], [127, 230, 193]), t));
      const glow = toHex(mixRgb(parseHex(base["--glow"], [67, 255, 180]), parseHex(next["--glow"], [67, 255, 180]), t));
      const accent = toHex(mixRgb(parseHex(base["--accent"], [255, 184, 74]), parseHex(next["--accent"], [255, 184, 74]), t));
      const gridRgb = mixRgb(parseRgb(base["--grid-rgb"], [82, 255, 171]), parseRgb(next["--grid-rgb"], [82, 255, 171]), t);
      const mutedRgb = mixRgb(parseRgb(base["--muted-rgb"], [127, 230, 193]), parseRgb(next["--muted-rgb"], [127, 230, 193]), t);
      const glowRgb = mixRgb(parseRgb(base["--glow-rgb"], [67, 255, 180]), parseRgb(next["--glow-rgb"], [67, 255, 180]), t);
      const accentRgb = mixRgb(parseRgb(base["--accent-rgb"], [255, 184, 74]), parseRgb(next["--accent-rgb"], [255, 184, 74]), t);
      const borderRgb = mixRgb(parseRgb(base["--border-rgb"], [110, 255, 198]), parseRgb(next["--border-rgb"], [110, 255, 198]), t);
      const panelBorderRgb = mixRgb(parseRgb(base["--panel-border-rgb"], [103, 255, 190]), parseRgb(next["--panel-border-rgb"], [103, 255, 190]), t);

      const panel = toRgbaString(mixRgba(
        parseRgba(base["--panel"], { rgb: [7, 18, 14], alpha: 0.85 }),
        parseRgba(next["--panel"], { rgb: [7, 18, 14], alpha: 0.85 }),
        t
      ));
      const scanline = toRgbaString(mixRgba(
        parseRgba(base["--scanline"], { rgb: [10, 26, 20], alpha: 0.35 }),
        parseRgba(next["--scanline"], { rgb: [10, 26, 20], alpha: 0.35 }),
        t
      ));

      const inputBg = toHex(mixRgb(parseHex(base["--input-bg"], [4, 11, 8]), parseHex(next["--input-bg"], [4, 11, 8]), t));
      const timelineBg = toRgbaString(mixRgba(
        parseRgba(base["--timeline-bg"], { rgb: [4, 10, 8], alpha: 0.65 }),
        parseRgba(next["--timeline-bg"], { rgb: [4, 10, 8], alpha: 0.65 }),
        t
      ));
      const buttonBg = mixLinearGradient(
        parseLinearGradient(base["--button-bg"], {
          start: { rgb: [7, 32, 20], alpha: 0.9 },
          end: { rgb: [8, 64, 40], alpha: 0.9 }
        }),
        parseLinearGradient(next["--button-bg"], {
          start: { rgb: [7, 32, 20], alpha: 0.9 },
          end: { rgb: [8, 64, 40], alpha: 0.9 }
        }),
        t,
        "120deg"
      );

      root.style.setProperty("--bg", bg);
      root.style.setProperty("--bg-2", bg2);
      root.style.setProperty("--bg-3", bg3);
      root.style.setProperty("--text", text);
      root.style.setProperty("--muted", muted);
      root.style.setProperty("--glow", glow);
      root.style.setProperty("--accent", accent);
      root.style.setProperty("--grid-rgb", toRgbString(gridRgb));
      root.style.setProperty("--muted-rgb", toRgbString(mutedRgb));
      root.style.setProperty("--glow-rgb", toRgbString(glowRgb));
      root.style.setProperty("--accent-rgb", toRgbString(accentRgb));
      root.style.setProperty("--border-rgb", toRgbString(borderRgb));
      root.style.setProperty("--panel-border-rgb", toRgbString(panelBorderRgb));
      root.style.setProperty("--panel", panel);
      root.style.setProperty("--scanline", scanline);
      root.style.setProperty("--input-bg", inputBg);
      root.style.setProperty("--timeline-bg", timelineBg);
      root.style.setProperty("--button-bg", buttonBg);
      updateThemeColors();
    }

    let currentMidi = null;
    let midiBlobUrl = null;
    let currentChords = [];
    let currentBass = [];
    let currentMelody = [];
    let currentDrums = [];
    let chordTextTokens = [];
    let chordStarts = [];
    let chordClips = [];
    let bassClips = [];
    let activeBassClips = new Set();
    let melodyClips = [];
    let activeMelodyClips = new Set();
    let drumClips = [];
    let activeDrumClips = new Set();
    let currentChordIndex = -1;
    let currentFileName = "change.machine.mid";
    let currentBpm = 110;
    let currentBeatPx = 34;
    let bassAutoRegenerate = false;
    let bassSeedCounter = 0;
    let melodyAutoRegenerate = false;
    let melodySeedCounter = 0;
    let drumAutoRegenerate = false;
    let drumSeedCounter = 0;
    let currentSeed = createRegenSeedLabel();
    let currentBackingStyle = "blocks";
    let randomBackingStyle = null;
    let currentBackingGenre = { main: "", sub: "" };
    let isPlaying = false;
    let playTimers = [];
    let audioContext = null;
    let masterGain = null;
    let chordBusGain = null;
    let bassBusGain = null;
    let melodyBusGain = null;
    let drumBusGain = null;
    let analyser = null;
    let oscData = null;
    let oscCtx = null;
    let oscAnimId = null;
    let drumNoiseBuffer = null;
    const activeOscillators = new Set();
    const DEFAULT_GAIN = 0.18;
    let midiAccess = null;
    let midiOutput = null;
    let midiEnabled = false;
    let midiInput = null;
    let preferredOutputId = null;
    let preferredInputId = null;
    let externalBpm = null;
    let lastClockTime = null;
    let clockSmoothing = null;
    const activeChordNotes = new Map();
    const activeBassNotes = new Map();
    const activeMelodyNotes = new Map();
    const activeDrumNotes = new Map();
    let chordNoteCounter = 0;
    let songMode = false;
    let chordMuted = false;
    let bassMuted = false;
    let melodyMuted = false;
    let drumMuted = false;
    let alignRaf = null;
    let suppressPanelAlignment = false;
    let chordPlaybackMode = "loop";
    let bassPlaybackMode = "loop";
    let melodyPlaybackMode = "loop";
    let drumPlaybackMode = "loop";
    let selectionMode = false;
    let selectionBox = null;
    let selectionStart = null;
    const selectedChordIndices = new Set();
    const selectedBassIndices = new Set();
    const selectedMelodyIndices = new Set();
    const selectedDrumIndices = new Set();
    let currentKeyUsed = "C";
    let currentKeyLabel = "C";
    let pendingCycle = null;
    let pendingCycleSignature = "";
    let pendingCycleTimer = null;
    let currentDrumMaxVelocity = 127;
    let manualBlendGenres = [];
    let manualBlendEnabled = false;
    let formEnabled = false;
    let currentFormSections = [];
    let timelineScrollAnim = null;
    let timelineScrollAnimStart = 0;
    let timelineScrollFrom = 0;
    let timelineScrollTo = 0;
    let playheadRaf = null;
    let playheadStartMs = 0;
    let playheadStartBeat = 0;
    let playheadBeatSec = 0;
    let playheadTotalBeats = 0;
    let suppressHistory = false;
    const historyStack = [];
    let historyIndex = -1;
    const HISTORY_LIMIT = 20;
    syncBlendSelects([]);
    setFormEnabledState(false);
    populateBackingStyles();

    function getMidiVelocity() {
      if (!midiVelocity) return 96;
      const value = Number(midiVelocity.value);
      if (Number.isNaN(value)) return 96;
      return Math.max(1, Math.min(127, value));
    }

    function updateDrumVelocityMax() {
      if (!currentDrums || !currentDrums.length) {
        currentDrumMaxVelocity = 127;
        return;
      }
      let max = 1;
      currentDrums.forEach(hit => {
        if (!hit) return;
        const vel = Math.max(1, Math.min(127, hit.velocity || 1));
        if (vel > max) max = vel;
      });
      currentDrumMaxVelocity = Math.max(1, max);
    }

    function getDrumVelocityCap() {
      if (!drumVelocityInput) return 96;
      const value = Number(drumVelocityInput.value);
      if (Number.isNaN(value)) return 96;
      return Math.max(1, Math.min(127, Math.round((value / 100) * 127)));
    }

    function scaleDrumVelocity(base) {
      const baseVel = Math.max(1, Math.min(127, base || 1));
      const max = currentDrumMaxVelocity || 127;
      const normalized = max > 0 ? Math.max(0, Math.min(1, baseVel / max)) : 0;
      const cap = getDrumVelocityCap();
      return Math.max(1, Math.min(127, Math.round(normalized * cap)));
    }

    function getChordChannel() {
      if (!chordChannelSelect) return 0;
      const value = parseInt(chordChannelSelect.value, 10);
      if (Number.isNaN(value)) return 0;
      return Math.max(0, Math.min(15, value - 1));
    }

    function getBassChannel() {
      if (!bassChannelSelect) return 1;
      const value = parseInt(bassChannelSelect.value, 10);
      if (Number.isNaN(value)) return 1;
      return Math.max(0, Math.min(15, value - 1));
    }

    function getMelodyChannel() {
      if (!melodyChannelSelect) return 2;
      const value = parseInt(melodyChannelSelect.value, 10);
      if (Number.isNaN(value)) return 2;
      return Math.max(0, Math.min(15, value - 1));
    }

    function getDrumChannel() {
      return 3;
    }

    function ensureAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = audioContext.createGain();
        masterGain.gain.value = midiEnabled ? 0 : DEFAULT_GAIN;
        chordBusGain = audioContext.createGain();
        bassBusGain = audioContext.createGain();
        melodyBusGain = audioContext.createGain();
        drumBusGain = audioContext.createGain();
        chordBusGain.connect(masterGain);
        bassBusGain.connect(masterGain);
        melodyBusGain.connect(masterGain);
        drumBusGain.connect(masterGain);
        updateTrackGains();
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.4;
        oscData = new Uint8Array(analyser.fftSize);
        masterGain.connect(analyser);
        analyser.connect(audioContext.destination);
        startOscilloscope();
      }
      if (audioContext.state === "suspended") {
        audioContext.resume();
      }
    }

    function getTrackGainValue(input) {
      if (!input) return 1;
      const value = parseFloat(input.value);
      if (Number.isNaN(value)) return 1;
      return Math.max(0, Math.min(1, value / 100));
    }

    function setTrackPlaybackMode(track, mode) {
      const value = mode === "regen" ? "regen" : "loop";
      if (track === "chord") {
        chordPlaybackMode = value;
        if (chordLoopButton) chordLoopButton.textContent = value === "loop" ? "Loop" : "Regen";
        if (value === "loop") {
          clearPendingCycle();
        }
      } else if (track === "bass") {
        bassPlaybackMode = value;
        if (bassLoopButton) bassLoopButton.textContent = value === "loop" ? "Loop" : "Regen";
      } else if (track === "melody") {
        melodyPlaybackMode = value;
        if (melodyLoopButton) melodyLoopButton.textContent = value === "loop" ? "Loop" : "Regen";
      } else if (track === "drum") {
        drumPlaybackMode = value;
        if (drumLoopButton) drumLoopButton.textContent = value === "loop" ? "Loop" : "Regen";
      }
    }

    function updateTrackGains() {
      if (!audioContext) return;
      if (chordBusGain) {
        const value = chordMuted ? 0 : getTrackGainValue(chordVolumeInput);
        chordBusGain.gain.setValueAtTime(value, audioContext.currentTime);
      }
      if (bassBusGain) {
        const value = bassMuted ? 0 : getTrackGainValue(bassVolumeInput);
        bassBusGain.gain.setValueAtTime(value, audioContext.currentTime);
      }
      if (melodyBusGain) {
        const value = melodyMuted ? 0 : getTrackGainValue(melodyVolumeInput);
        melodyBusGain.gain.setValueAtTime(value, audioContext.currentTime);
      }
      if (drumBusGain) {
        const value = drumMuted ? 0 : getTrackGainValue(drumVolumeInput);
        drumBusGain.gain.setValueAtTime(value, audioContext.currentTime);
      }
    }

    function handleMidiMessage(event) {
      const status = event.data[0];
      if (status === 0xF8) {
        const now = performance.now();
        if (lastClockTime) {
          const delta = now - lastClockTime;
          if (delta > 0) {
            const bpm = 60000 / (delta * 24);
            const clamped = Math.max(20, Math.min(300, bpm));
            clockSmoothing = clockSmoothing === null ? clamped : (clockSmoothing * 0.8 + clamped * 0.2);
            externalBpm = clockSmoothing;
            if (midiEnabled) {
              tempoInput.disabled = true;
              if (tempoNumber) tempoNumber.disabled = true;
              if (tempoNumber && document.activeElement !== tempoNumber) {
                tempoNumber.value = externalBpm.toFixed(1);
              }
              if (tempoReadout) {
                tempoReadout.textContent = `EXT ${externalBpm.toFixed(1)} BPM`;
              }
            }
          }
        }
        lastClockTime = now;
      } else if (status === 0xFA || status === 0xFC) {
        lastClockTime = null;
        externalBpm = null;
        clockSmoothing = null;
        if (midiEnabled) {
          tempoInput.disabled = false;
          if (tempoNumber) tempoNumber.disabled = false;
          updateReadouts();
        }
      }
    }

    async function ensureMidi() {
      if (!midiEnabled) return;
      if (!navigator.requestMIDIAccess) {
        return;
      }
      if (!midiAccess) {
        try {
          midiAccess = await navigator.requestMIDIAccess({ sysex: false });
          midiAccess.onstatechange = () => {
            populateMidiOutputs();
          };
        } catch (err) {
          return;
        }
      }
      populateMidiOutputs();
    }

    function populateMidiOutputs() {
      const outputs = midiAccess ? Array.from(midiAccess.outputs.values()) : [];
      let selectedOut = preferredOutputId
        ? outputs.find(output => output.id === preferredOutputId)
        : null;
      if (!selectedOut) {
        selectedOut = outputs.find(output =>
          (output.name || "").toLowerCase().includes("logic pro virtual in")
        ) || outputs[0] || null;
      }
      midiOutput = selectedOut;
      if (midiOutput) {
        preferredOutputId = midiOutput.id;
      }

      const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];
      let selectedIn = preferredInputId
        ? inputs.find(input => input.id === preferredInputId)
        : null;
      if (!selectedIn) {
        selectedIn = inputs.find(input =>
          (input.name || "").toLowerCase().includes("logic pro virtual out")
        ) || inputs[0] || null;
      }
      if (midiInput && midiInput !== selectedIn) {
        midiInput.onmidimessage = null;
      }
      midiInput = selectedIn || null;
      if (midiInput) {
        preferredInputId = midiInput.id;
      }
      if (midiInput) {
        midiInput.onmidimessage = handleMidiMessage;
      }
      refreshMidiRouteOptions();
    }

    function sendChordNoteOn(note, velocity = 96, channelOverride = null) {
      if (!midiEnabled || !midiOutput) return;
      const channel = channelOverride !== null ? channelOverride : getChordChannel();
      const id = chordNoteCounter + 1;
      chordNoteCounter = id;
      midiOutput.send([0x90 + channel, note, velocity]);
      activeChordNotes.set(note, { channel, id });
      return id;
    }

    function sendChordNoteOff(note, noteId = null) {
      if (!midiEnabled || !midiOutput) return;
      const entry = activeChordNotes.get(note);
      if (noteId !== null && (!entry || entry.id !== noteId)) return;
      const resolved = entry && entry.channel !== undefined ? entry.channel : getChordChannel();
      midiOutput.send([0x80 + resolved, note, 0]);
      activeChordNotes.delete(note);
    }

    function sendChordNoteOffOnChannel(note, channel) {
      if (!midiEnabled || !midiOutput) return;
      const resolved = channel ?? getChordChannel();
      midiOutput.send([0x80 + resolved, note, 0]);
    }

    function sendBassNoteOn(note, velocity = 96) {
      if (!midiEnabled || !midiOutput) return;
      const channel = getBassChannel();
      midiOutput.send([0x90 + channel, note, velocity]);
      activeBassNotes.set(note, channel);
    }

    function sendBassNoteOff(note) {
      if (!midiEnabled || !midiOutput) return;
      const channel = activeBassNotes.get(note);
      const resolved = channel === undefined ? getBassChannel() : channel;
      midiOutput.send([0x80 + resolved, note, 0]);
      activeBassNotes.delete(note);
    }

    function sendMelodyNoteOn(note, velocity = 96) {
      if (!midiEnabled || !midiOutput) return;
      const channel = getMelodyChannel();
      midiOutput.send([0x90 + channel, note, velocity]);
      activeMelodyNotes.set(note, channel);
    }

    function sendMelodyNoteOff(note) {
      if (!midiEnabled || !midiOutput) return;
      const channel = activeMelodyNotes.get(note);
      const resolved = channel === undefined ? getMelodyChannel() : channel;
      midiOutput.send([0x80 + resolved, note, 0]);
      activeMelodyNotes.delete(note);
    }

    function sendDrumNoteOn(note, velocity = 96) {
      if (!midiEnabled || !midiOutput) return;
      const channel = getDrumChannel();
      midiOutput.send([0x90 + channel, note, velocity]);
      activeDrumNotes.set(note, channel);
    }

    function sendDrumNoteOff(note) {
      if (!midiEnabled || !midiOutput) return;
      const channel = activeDrumNotes.get(note);
      const resolved = channel === undefined ? getDrumChannel() : channel;
      midiOutput.send([0x80 + resolved, note, 0]);
      activeDrumNotes.delete(note);
    }

    function sendChordPanic() {
      if (!midiEnabled || !midiOutput) {
        activeChordNotes.clear();
        return;
      }
      const channel = getChordChannel();
      activeChordNotes.forEach((entry, note) => {
        const resolved = entry && entry.channel !== undefined ? entry.channel : channel;
        midiOutput.send([0x80 + resolved, note, 0]);
      });
      midiOutput.send([0xB0 + channel, 64, 0]);
      midiOutput.send([0xB0 + channel, 123, 0]);
      midiOutput.send([0xB0 + channel, 120, 0]);
      activeChordNotes.clear();
    }

    function sendAllNotesOff() {
      if (!midiEnabled || !midiOutput) {
        activeChordNotes.clear();
        activeBassNotes.clear();
        activeMelodyNotes.clear();
        activeDrumNotes.clear();
        return;
      }
      const channels = new Set();
      activeChordNotes.forEach((entry, note) => {
        const resolved = entry && entry.channel !== undefined ? entry.channel : getChordChannel();
        midiOutput.send([0x80 + resolved, note, 0]);
        channels.add(resolved);
      });
      activeBassNotes.forEach((channel, note) => {
        midiOutput.send([0x80 + channel, note, 0]);
        channels.add(channel);
      });
      activeMelodyNotes.forEach((channel, note) => {
        midiOutput.send([0x80 + channel, note, 0]);
        channels.add(channel);
      });
      activeDrumNotes.forEach((channel, note) => {
        midiOutput.send([0x80 + channel, note, 0]);
        channels.add(channel);
      });
      channels.add(getChordChannel());
      channels.add(getBassChannel());
      channels.add(getMelodyChannel());
      channels.add(getDrumChannel());
      channels.forEach(channel => {
        midiOutput.send([0xB0 + channel, 64, 0]);
        midiOutput.send([0xB0 + channel, 123, 0]);
        midiOutput.send([0xB0 + channel, 120, 0]);
      });
      activeChordNotes.clear();
      activeBassNotes.clear();
      activeMelodyNotes.clear();
      activeDrumNotes.clear();
    }

    function sendGlobalAllNotesOff() {
      if (!midiEnabled || !midiOutput) return;
      for (let channel = 0; channel < 16; channel += 1) {
        midiOutput.send([0xB0 + channel, 64, 0]);  // sustain off
        midiOutput.send([0xB0 + channel, 123, 0]); // all notes off
        midiOutput.send([0xB0 + channel, 120, 0]); // all sound off
        midiOutput.send([0xB0 + channel, 121, 0]); // reset all controllers
      }
    }


    function scheduleMidiChord(notes, startMs, durationMs, allowWhenStopped = false) {
      if (!midiOutput || chordMuted) return;
      const onId = setTimeout(() => {
        if (chordMuted || (!isPlaying && !allowWhenStopped)) return;
        sendChordPanic();
        const velocity = getMidiVelocity();
        const noteIds = new Map();
        notes.forEach(note => {
          const id = sendChordNoteOn(note, velocity);
          noteIds.set(note, id);
        });
        const offId = setTimeout(() => {
          notes.forEach(note => sendChordNoteOff(note, noteIds.get(note) ?? null));
        }, Math.max(0, durationMs));
        playTimers.push(offId);
      }, Math.max(0, startMs));
      playTimers.push(onId);
    }

    function scheduleMidiBass(note, startMs, durationMs) {
      if (!midiOutput || bassMuted) return;
      const onId = setTimeout(() => {
        if (bassMuted || !isPlaying) return;
        const velocity = Math.max(1, Math.round(getMidiVelocity() * 0.85));
        sendBassNoteOn(note, velocity);
      }, Math.max(0, startMs));
      const offId = setTimeout(() => {
        sendBassNoteOff(note);
      }, Math.max(0, startMs + durationMs));
      playTimers.push(onId, offId);
    }

    function scheduleMidiMelody(note, startMs, durationMs) {
      if (!midiOutput || melodyMuted) return;
      const onId = setTimeout(() => {
        if (melodyMuted || !isPlaying) return;
        const velocity = Math.max(1, Math.round(getMidiVelocity() * 0.9));
        sendMelodyNoteOn(note, velocity);
      }, Math.max(0, startMs));
      const offId = setTimeout(() => {
        sendMelodyNoteOff(note);
      }, Math.max(0, startMs + durationMs));
      playTimers.push(onId, offId);
    }

    function scheduleMidiDrum(note, startMs, durationMs, velocity = 90) {
      if (!midiOutput || drumMuted) return;
      const onId = setTimeout(() => {
        if (drumMuted || !isPlaying) return;
        const base = Math.max(1, Math.min(127, velocity));
        const vel = scaleDrumVelocity(base);
        sendDrumNoteOn(note, vel);
      }, Math.max(0, startMs));
      const offId = setTimeout(() => {
        sendDrumNoteOff(note);
      }, Math.max(0, startMs + durationMs));
      playTimers.push(onId, offId);
    }

    function refreshMidiRouteOptions() {
      if (!midiOutSelect || !midiInSelect) return;
      const outputs = midiAccess ? Array.from(midiAccess.outputs.values()) : [];
      const inputs = midiAccess ? Array.from(midiAccess.inputs.values()) : [];

      midiOutSelect.innerHTML = "";
      if (!outputs.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "No MIDI outputs";
        midiOutSelect.appendChild(option);
        midiOutSelect.disabled = true;
      } else {
        outputs.forEach(output => {
          const option = document.createElement("option");
          option.value = output.id;
          option.textContent = output.name || output.id;
          if (midiOutput && output.id === midiOutput.id) {
            option.selected = true;
          }
          midiOutSelect.appendChild(option);
        });
        midiOutSelect.disabled = false;
      }

      midiInSelect.innerHTML = "";
      if (!inputs.length) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "No MIDI inputs";
        midiInSelect.appendChild(option);
        midiInSelect.disabled = true;
      } else {
        inputs.forEach(input => {
          const option = document.createElement("option");
          option.value = input.id;
          option.textContent = input.name || input.id;
          if (midiInput && input.id === midiInput.id) {
            option.selected = true;
          }
          midiInSelect.appendChild(option);
        });
        midiInSelect.disabled = false;
      }
    }

    function resizeOscilloscope() {
      if (!oscilloscope) return;
      const dpr = window.devicePixelRatio || 1;
      const rect = oscilloscope.getBoundingClientRect();
      oscilloscope.width = Math.max(1, Math.floor(rect.width * dpr));
      oscilloscope.height = Math.max(1, Math.floor(rect.height * dpr));
      oscCtx = oscilloscope.getContext("2d");
      oscCtx.setTransform(1, 0, 0, 1, 0, 0);
      oscCtx.scale(dpr, dpr);
    }

    function startOscilloscope() {
      if (!oscilloscope || !analyser) return;
      resizeOscilloscope();
      if (oscAnimId) cancelAnimationFrame(oscAnimId);

      const draw = () => {
        oscAnimId = requestAnimationFrame(draw);
        if (!oscCtx) return;
        const width = oscilloscope.clientWidth;
        const height = oscilloscope.clientHeight;
        oscCtx.clearRect(0, 0, width, height);
        oscCtx.fillStyle = oscFillColor;
        oscCtx.fillRect(0, 0, width, height);

        analyser.getByteTimeDomainData(oscData);
        oscCtx.lineWidth = 2.4;
        oscCtx.strokeStyle = oscStrokeColor;
        oscCtx.shadowBlur = 12;
        oscCtx.shadowColor = oscShadowColor;
        oscCtx.beginPath();

        const sliceWidth = width / (oscData.length - 1);
        let x = 0;
        for (let i = 0; i < oscData.length; i++) {
          const v = oscData[i] / 128.0;
          const centered = (v - 1) * 2.6;
          const y = height / 2 + centered * (height / 2);
          if (i === 0) {
            oscCtx.moveTo(x, y);
          } else {
            oscCtx.lineTo(x, y);
          }
          x += sliceWidth;
        }
        oscCtx.lineTo(width, height / 2);
        oscCtx.stroke();

        oscCtx.shadowBlur = 0;
        oscCtx.strokeStyle = oscMidColor;
        oscCtx.beginPath();
        oscCtx.moveTo(0, height / 2);
        oscCtx.lineTo(width, height / 2);
        oscCtx.stroke();
      };

      draw();
    }

    function midiToFreq(note) {
      return 440 * Math.pow(2, (note - 69) / 12);
    }

    function playChordAtTime(notes, startTime, durationSec) {
      if (chordMuted) return;
      const attack = 0.02;
      const release = Math.max(0.05, durationSec * 0.35);
      notes.forEach(note => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "sine";
        osc.frequency.value = midiToFreq(note);
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.18, startTime + attack);
        gain.gain.linearRampToValueAtTime(0.0001, Math.max(startTime + attack + 0.01, startTime + durationSec - release));
        gain.gain.linearRampToValueAtTime(0, startTime + durationSec);
        osc.connect(gain);
        gain.connect(chordBusGain || masterGain);
        activeOscillators.add(osc);
        osc.onended = () => {
          activeOscillators.delete(osc);
        };
        osc.start(startTime);
        osc.stop(startTime + durationSec + 0.02);
      });
    }

    function playBassNoteAtTime(note, startTime, durationSec) {
      if (bassMuted) return;
      const attack = 0.01;
      const release = Math.max(0.08, durationSec * 0.4);
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = "triangle";
      osc.frequency.value = midiToFreq(note);
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(0.18, startTime + attack);
      gain.gain.linearRampToValueAtTime(0.0001, Math.max(startTime + attack + 0.01, startTime + durationSec - release));
      gain.gain.linearRampToValueAtTime(0, startTime + durationSec);
      osc.connect(gain);
      gain.connect(bassBusGain || masterGain);
      activeOscillators.add(osc);
      osc.onended = () => {
        activeOscillators.delete(osc);
      };
      osc.start(startTime);
      osc.stop(startTime + durationSec + 0.03);
    }

    function playMelodyNoteAtTime(note, startTime, durationSec) {
      if (melodyMuted) return;
      const attack = 0.015;
      const release = Math.max(0.06, durationSec * 0.35);
      const osc = audioContext.createOscillator();
      const gain = audioContext.createGain();
      osc.type = "sawtooth";
      osc.frequency.value = midiToFreq(note);
      gain.gain.setValueAtTime(0, startTime);
      gain.gain.linearRampToValueAtTime(0.12, startTime + attack);
      gain.gain.linearRampToValueAtTime(0.0001, Math.max(startTime + attack + 0.01, startTime + durationSec - release));
      gain.gain.linearRampToValueAtTime(0, startTime + durationSec);
      osc.connect(gain);
      gain.connect(melodyBusGain || masterGain);
      activeOscillators.add(osc);
      osc.onended = () => {
        activeOscillators.delete(osc);
      };
      osc.start(startTime);
      osc.stop(startTime + durationSec + 0.03);
    }

    function getNoiseBuffer() {
      if (drumNoiseBuffer) return drumNoiseBuffer;
      const length = audioContext.sampleRate;
      const buffer = audioContext.createBuffer(1, length, audioContext.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      drumNoiseBuffer = buffer;
      return buffer;
    }

    function playNoiseBurst(startTime, durationSec, filterType, cutoff, gainLevel) {
      const source = audioContext.createBufferSource();
      const filter = audioContext.createBiquadFilter();
      const gain = audioContext.createGain();
      source.buffer = getNoiseBuffer();
      filter.type = filterType;
      filter.frequency.setValueAtTime(cutoff, startTime);
      gain.gain.setValueAtTime(0.0001, startTime);
      gain.gain.exponentialRampToValueAtTime(gainLevel, startTime + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, startTime + durationSec);
      source.connect(filter);
      filter.connect(gain);
      gain.connect(drumBusGain || masterGain);
      activeOscillators.add(source);
      source.onended = () => {
        activeOscillators.delete(source);
      };
      source.start(startTime);
      source.stop(startTime + durationSec + 0.02);
    }

    function playDrumHitAtTime(note, startTime, durationSec, velocity = 90) {
      if (drumMuted) return;
      if (velocity <= 0) return;
      const vel = Math.max(0.02, Math.min(1, velocity / 127));
      if (note === 36) {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(120, startTime);
        osc.frequency.exponentialRampToValueAtTime(50, startTime + 0.2);
        gain.gain.setValueAtTime(0.0001, startTime);
        gain.gain.exponentialRampToValueAtTime(0.35 * vel, startTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.3);
        osc.connect(gain);
        gain.connect(drumBusGain || masterGain);
        activeOscillators.add(osc);
        osc.onended = () => {
          activeOscillators.delete(osc);
        };
        osc.start(startTime);
        osc.stop(startTime + 0.35);
        return;
      }

      if (note === 38 || note === 39 || note === 37) {
        playNoiseBurst(startTime, 0.18, "bandpass", 1800, 0.32 * vel);
        return;
      }

      if (note === 42 || note === 46) {
        playNoiseBurst(startTime, 0.12, "highpass", 6000, 0.18 * vel);
        return;
      }

      if (note === 49 || note === 51) {
        playNoiseBurst(startTime, 0.35, "highpass", 5000, 0.22 * vel);
        return;
      }

      if (note === 45 || note === 47 || note === 50) {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        const base = note === 45 ? 130 : note === 47 ? 160 : 190;
        osc.type = "triangle";
        osc.frequency.setValueAtTime(base, startTime);
        osc.frequency.exponentialRampToValueAtTime(base * 0.85, startTime + 0.2);
        gain.gain.setValueAtTime(0.0001, startTime);
        gain.gain.exponentialRampToValueAtTime(0.25 * vel, startTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.25);
        osc.connect(gain);
        gain.connect(drumBusGain || masterGain);
        activeOscillators.add(osc);
        osc.onended = () => {
          activeOscillators.delete(osc);
        };
        osc.start(startTime);
        osc.stop(startTime + 0.28);
      }
    }

    function clearTimers() {
      playTimers.forEach(id => clearTimeout(id));
      playTimers = [];
    }

    function setActiveChord(index) {
      if (currentChordIndex >= 0 && chordClips[currentChordIndex]) {
        chordClips[currentChordIndex].classList.remove("active");
      }
      currentChordIndex = index;
      if (currentChordIndex >= 0 && chordClips[currentChordIndex]) {
        const clip = chordClips[currentChordIndex];
        clip.classList.add("active");
        if (!isPlaying) {
          scrollTimelineToClip(clip, false, false);
        }
      }
      renderProgressionHighlight(currentChordIndex);
    }

    function scrollTimelineToBeat(beat) {
      if (!timelineView) return;
      const viewWidth = timelineView.clientWidth || 0;
      const targetLeft = beat * currentBeatPx - viewWidth * 0.5;
      setTimelineScroll(targetLeft, isPlaying);
    }

    function updateTimelineScrollToBeat(beat) {
      if (!timelineView) return;
      const viewWidth = timelineView.clientWidth || 0;
      const maxScroll = Math.max(0, timelineView.scrollWidth - viewWidth);
      const targetLeft = beat * currentBeatPx - viewWidth * 0.5;
      const clamped = Math.max(0, Math.min(maxScroll, targetLeft));
      timelineView.scrollLeft = clamped;
      timelineScroll.value = String(timelineView.scrollLeft);
    }

    function stopPlaybackScroll() {
      if (playheadRaf) {
        cancelAnimationFrame(playheadRaf);
        playheadRaf = null;
      }
    }

    function startPlaybackScroll(startBeat, totalBeats, beatSec) {
      stopPlaybackScroll();
      playheadStartMs = performance.now();
      playheadStartBeat = startBeat;
      playheadBeatSec = beatSec;
      playheadTotalBeats = totalBeats;
      const tick = (now) => {
        if (!isPlaying) {
          stopPlaybackScroll();
          return;
        }
        const elapsed = Math.max(0, (now - playheadStartMs) / 1000);
        let beat = playheadStartBeat + elapsed / playheadBeatSec;
        if (beat > playheadTotalBeats) {
          beat = playheadTotalBeats;
        }
        updateTimelineScrollToBeat(beat);
        playheadRaf = requestAnimationFrame(tick);
      };
      playheadRaf = requestAnimationFrame(tick);
    }

    function setTimelineScroll(targetLeft, smooth) {
      if (!timelineView) return;
      const viewWidth = timelineView.clientWidth || 0;
      const maxScroll = Math.max(0, timelineView.scrollWidth - viewWidth);
      const clamped = Math.max(0, Math.min(maxScroll, targetLeft));
      if (!smooth) {
        if (timelineScrollAnim) {
          cancelAnimationFrame(timelineScrollAnim);
          timelineScrollAnim = null;
        }
        timelineView.scrollLeft = clamped;
        timelineScroll.value = String(timelineView.scrollLeft);
        return;
      }
      timelineScrollFrom = timelineView.scrollLeft;
      timelineScrollTo = clamped;
      timelineScrollAnimStart = performance.now();
      if (timelineScrollAnim) {
        cancelAnimationFrame(timelineScrollAnim);
      }
      const duration = 260;
      const step = (now) => {
        const t = Math.min(1, (now - timelineScrollAnimStart) / duration);
        const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
        const value = timelineScrollFrom + (timelineScrollTo - timelineScrollFrom) * eased;
        timelineView.scrollLeft = value;
        timelineScroll.value = String(timelineView.scrollLeft);
        if (t < 1) {
          timelineScrollAnim = requestAnimationFrame(step);
        } else {
          timelineScrollAnim = null;
        }
      };
      timelineScrollAnim = requestAnimationFrame(step);
    }

    function scrollTimelineToClip(clip, center = false, smooth = false) {
      if (!clip || !timelineView) return;
      const clipLeft = clip.offsetLeft;
      const clipRight = clipLeft + clip.offsetWidth;
      const viewLeft = timelineView.scrollLeft;
      const viewWidth = timelineView.clientWidth || 0;
      const viewRight = viewLeft + viewWidth;
      if (center) {
        const targetLeft = clipLeft + clip.offsetWidth / 2 - viewWidth / 2;
        setTimelineScroll(targetLeft, smooth);
        return;
      }
      if (clipRight > viewRight || clipLeft < viewLeft) {
        const targetLeft = clipLeft - 16;
        setTimelineScroll(targetLeft, smooth);
      }
    }

    function findChordIndexAtBeat(beat) {
      if (!chordStarts.length) return 0;
      for (let i = chordStarts.length - 1; i >= 0; i--) {
        if (beat >= chordStarts[i] - 1e-6) return i;
      }
      return 0;
    }

    function clearBassHighlights() {
      if (!bassClips.length) return;
      bassClips.forEach(item => {
        if (item && item.el) {
          item.el.classList.remove("active");
        }
      });
      activeBassClips.clear();
    }

    function setBassClipActive(index, active) {
      const item = bassClips[index];
      if (!item || !item.el) return;
      if (active) {
        item.el.classList.add("active");
        activeBassClips.add(index);
      } else {
        item.el.classList.remove("active");
        activeBassClips.delete(index);
      }
    }

    function clearSelection() {
      selectedChordIndices.clear();
      selectedBassIndices.clear();
      selectedMelodyIndices.clear();
      selectedDrumIndices.clear();
      chordClips.forEach((clip) => {
        if (clip) clip.classList.remove("selected");
      });
      bassClips.forEach((item) => {
        if (item && item.el) item.el.classList.remove("selected");
      });
      melodyClips.forEach((item) => {
        if (item && item.el) item.el.classList.remove("selected");
      });
      drumClips.forEach((item) => {
        if (item && item.el) item.el.classList.remove("selected");
      });
    }

    function pruneSelectionSets() {
      selectedChordIndices.forEach(index => {
        if (index < 0 || index >= chordClips.length) selectedChordIndices.delete(index);
      });
      selectedBassIndices.forEach(index => {
        if (index < 0 || index >= bassClips.length) selectedBassIndices.delete(index);
      });
      selectedMelodyIndices.forEach(index => {
        if (index < 0 || index >= melodyClips.length) selectedMelodyIndices.delete(index);
      });
      selectedDrumIndices.forEach(index => {
        if (index < 0 || index >= drumClips.length) selectedDrumIndices.delete(index);
      });
    }

    function applySelectionStyles() {
      chordClips.forEach((clip, index) => {
        if (!clip) return;
        clip.classList.toggle("selected", selectedChordIndices.has(index));
      });
      bassClips.forEach((item, index) => {
        if (!item || !item.el) return;
        item.el.classList.toggle("selected", selectedBassIndices.has(index));
      });
      melodyClips.forEach((item, index) => {
        if (!item || !item.el) return;
        item.el.classList.toggle("selected", selectedMelodyIndices.has(index));
      });
      drumClips.forEach((item, index) => {
        if (!item || !item.el) return;
        item.el.classList.toggle("selected", selectedDrumIndices.has(index));
      });
    }

    function setSelectionMode(active) {
      selectionMode = active;
      if (selectToggle) {
        selectToggle.textContent = selectionMode ? "Selecting" : "Select";
      }
    }

    function rectsIntersect(a, b) {
      return !(a.right < b.left || a.left > b.right || a.bottom < b.top || a.top > b.bottom);
    }

    function updateSelectionFromBox() {
      if (!selectionBox) return;
      const boxRect = selectionBox.getBoundingClientRect();
      clearSelection();
      chordClips.forEach((clip, index) => {
        if (!clip) return;
        const clipRect = clip.getBoundingClientRect();
        if (rectsIntersect(boxRect, clipRect)) {
          clip.classList.add("selected");
          selectedChordIndices.add(index);
        }
      });
      bassClips.forEach((item, index) => {
        if (!item || !item.el) return;
        const clipRect = item.el.getBoundingClientRect();
        if (rectsIntersect(boxRect, clipRect)) {
          item.el.classList.add("selected");
          selectedBassIndices.add(index);
        }
      });
      melodyClips.forEach((item, index) => {
        if (!item || !item.el) return;
        const clipRect = item.el.getBoundingClientRect();
        if (rectsIntersect(boxRect, clipRect)) {
          item.el.classList.add("selected");
          selectedMelodyIndices.add(index);
        }
      });
      drumClips.forEach((item, index) => {
        if (!item || !item.el) return;
        const clipRect = item.el.getBoundingClientRect();
        if (rectsIntersect(boxRect, clipRect)) {
          item.el.classList.add("selected");
          selectedDrumIndices.add(index);
        }
      });
    }

    function clearMelodyHighlights() {
      if (!melodyClips.length) return;
      melodyClips.forEach(item => {
        if (item && item.el) {
          item.el.classList.remove("active");
        }
      });
      activeMelodyClips.clear();
    }

    function setMelodyClipActive(index, active) {
      const item = melodyClips[index];
      if (!item || !item.el) return;
      if (active) {
        item.el.classList.add("active");
        activeMelodyClips.add(index);
      } else {
        item.el.classList.remove("active");
        activeMelodyClips.delete(index);
      }
    }

    function clearDrumHighlights() {
      if (!drumClips.length) return;
      drumClips.forEach(item => {
        if (item && item.el) {
          item.el.classList.remove("active");
        }
      });
      activeDrumClips.clear();
    }

    function setDrumClipActive(index, active) {
      const item = drumClips[index];
      if (!item || !item.el) return;
      if (active) {
        item.el.classList.add("active");
        activeDrumClips.add(index);
      } else {
        item.el.classList.remove("active");
        activeDrumClips.delete(index);
      }
    }

    function auditionChordByIndex(index) {
      if (!currentChords.length || !currentChords[index]) return;
      stopPlayback();
      setActiveChord(index);
      scrollTimelineToBeat(chordStarts[index] || 0);
      ensureAudio();
      restoreMasterGain();
      ensureMidi();
      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      const chord = currentChords[index];
      if (!chordMuted) {
        playChordBacking(chord, audioContext.currentTime, beatSec);
      }
      if (midiEnabled && !chordMuted) {
        scheduleMidiChordBacking(chord, 0, beatSec, true);
      }
    }

    function auditionBassNote(note, duration, startBeat, clipIndex) {
      if (!currentChords.length) return;
      stopPlayback();
      const chordIndex = findChordIndexAtBeat(startBeat);
      setActiveChord(chordIndex);
      clearBassHighlights();
      if (clipIndex !== null && clipIndex !== undefined) {
        setBassClipActive(clipIndex, true);
      }
      ensureAudio();
      restoreMasterGain();
      ensureMidi();
      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      if (!bassMuted) {
        playBassNoteAtTime(note, audioContext.currentTime, duration * beatSec);
      }
      if (midiEnabled && !bassMuted) {
        const velocity = Math.max(1, Math.round(getMidiVelocity() * 0.85));
        sendBassNoteOn(note, velocity);
        const offId = setTimeout(() => {
          sendBassNoteOff(note);
          if (clipIndex !== null && clipIndex !== undefined) {
            setBassClipActive(clipIndex, false);
          }
        }, duration * beatSec * 1000);
        playTimers.push(offId);
      }
      scrollTimelineToBeat(startBeat);
    }

    function auditionMelodyNote(note, duration, startBeat, clipIndex) {
      if (!currentChords.length) return;
      stopPlayback();
      const chordIndex = findChordIndexAtBeat(startBeat);
      setActiveChord(chordIndex);
      clearMelodyHighlights();
      if (clipIndex !== null && clipIndex !== undefined) {
        setMelodyClipActive(clipIndex, true);
      }
      ensureAudio();
      restoreMasterGain();
      ensureMidi();
      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      if (!melodyMuted) {
        playMelodyNoteAtTime(note, audioContext.currentTime, duration * beatSec);
      }
      if (midiEnabled && !melodyMuted) {
        const velocity = Math.max(1, Math.round(getMidiVelocity() * 0.9));
        sendMelodyNoteOn(note, velocity);
        const offId = setTimeout(() => {
          sendMelodyNoteOff(note);
          if (clipIndex !== null && clipIndex !== undefined) {
            setMelodyClipActive(clipIndex, false);
          }
        }, duration * beatSec * 1000);
        playTimers.push(offId);
      }
      scrollTimelineToBeat(startBeat);
    }

    function auditionDrumHit(note, duration, startBeat, clipIndex, velocity = 90) {
      if (!currentChords.length) return;
      stopPlayback();
      const chordIndex = findChordIndexAtBeat(startBeat);
      setActiveChord(chordIndex);
      clearDrumHighlights();
      if (clipIndex !== null && clipIndex !== undefined) {
        setDrumClipActive(clipIndex, true);
      }
      ensureAudio();
      restoreMasterGain();
      ensureMidi();
      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      if (!drumMuted) {
        const vel = scaleDrumVelocity(velocity);
        playDrumHitAtTime(note, audioContext.currentTime, duration * beatSec, vel);
      }
      if (midiEnabled && !drumMuted) {
        const base = Math.max(1, Math.min(127, velocity));
        const vel = scaleDrumVelocity(base);
        sendDrumNoteOn(note, vel);
        const offId = setTimeout(() => {
          sendDrumNoteOff(note);
          if (clipIndex !== null && clipIndex !== undefined) {
            setDrumClipActive(clipIndex, false);
          }
        }, duration * beatSec * 1000);
        playTimers.push(offId);
      }
      scrollTimelineToBeat(startBeat);
    }

    function updateChordClips() {
      chordClips.forEach((clip, index) => {
        if (!clip || !currentChords[index]) return;
        clip.innerHTML = `<div class="clip-title">${currentChords[index].name}</div>`;
      });
      chordTextTokens = buildProgressionTokens(currentChords);
      progressionText.value = formatProgressionTextFromTokens(chordTextTokens);
      renderProgressionHighlight(currentChordIndex);
    }

    function regenerateSelectedChords() {
      if (!selectedChordIndices.size) {
        render(createRegenSeedLabel());
        return;
      }
      const seedLabel = currentSeed || createRegenSeedLabel();
      const newSeed = `${seedLabel}|chordsel-${createRegenSeedLabel().replace("change-", "")}`;
      const bars = parseInt(barsInput.value, 10);
      const densityPercent = Math.max(0, Math.min(100, parseInt(densityInput.value, 10) || 0));
      const colorPercent = Math.max(0, Math.min(100, parseInt(colorInput.value, 10) || 0));
      const modulationPercent = Math.max(0, Math.min(100, parseInt(modulationInput.value, 10) || 0));
      const subdivision = subdivisionInput.value;
      const subdivisionDensity = Math.max(0, Math.min(100, parseInt(subdivisionDensityInput.value, 10) || 0)) / 100;
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const genre = blendSubs || (genreSub ? genreSub.value : "base");
      const key = currentKeyUsed || keySelect.value || "C";
      const freshChords = generateProgression({
        bars,
        key,
        densityPercent,
        seed: newSeed,
        subdivision,
        subdivisionDensity,
        genre,
        modulationPercent,
        colorPercent
      });
      selectedChordIndices.forEach((index) => {
        if (!currentChords[index] || !freshChords[index]) return;
        currentChords[index].name = freshChords[index].name;
        currentChords[index].notes = freshChords[index].notes;
        currentChords[index].quality = freshChords[index].quality;
      });
      updateChordClips();
      pruneSelectionSets();
      applySelectionStyles();
      rebuildMidi();
    }

    function regenerateSelectedBass() {
      if (!selectedBassIndices.size) {
        regenerateBass(true);
        return;
      }
      const seedLabel = currentSeed || createRegenSeedLabel();
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const bassSeed = getBassSeedLabel(seedLabel, true);
      const freshBass = generateBassLine({
        chords: currentChords,
        seed: bassSeed,
        densityPercent: parseInt(bassDensityInput?.value, 10) || 0,
        movementPercent: parseInt(bassMovementInput?.value, 10) || 0,
        fillPercent: parseInt(bassFillsInput?.value, 10) || 0,
        restPercent: parseInt(bassRestsInput?.value, 10) || 0,
        colorPercent: parseInt(bassColorInput?.value, 10) || 0,
        subdivisionDensity: parseInt(bassSubdivisionDensityInput?.value, 10) || 0,
        subdivisionMode: bassSubdivisionInput?.value || "even",
        style: bassStyleInput?.value || "auto",
        register: parseInt(bassRegisterInput?.value, 10) || 36,
        genre: blendSubs || (bassGenreSub?.value || genreSub?.value || "base"),
        mainGenre: blendMains || (bassGenreMain?.value || genreMain?.value || "")
      });
      selectedBassIndices.forEach((index) => {
        if (!currentBass[index] || !freshBass[index]) return;
        currentBass[index].note = freshBass[index].note;
      });
      renderBassTrack();
      pruneSelectionSets();
      applySelectionStyles();
      rebuildMidi();
    }

    function regenerateSelectedMelody() {
      if (!selectedMelodyIndices.size) {
        regenerateMelody(true);
        return;
      }
      const seedLabel = currentSeed || createRegenSeedLabel();
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const melodySeed = getMelodySeedLabel(seedLabel, true);
      const freshMelody = generateMelodyLine({
        chords: currentChords,
        seed: melodySeed,
        densityPercent: parseInt(melodyDensityInput?.value, 10) || 0,
        movementPercent: parseInt(melodyMovementInput?.value, 10) || 0,
        fillPercent: parseInt(melodyFillsInput?.value, 10) || 0,
        restPercent: parseInt(melodyRestsInput?.value, 10) || 0,
        colorPercent: parseInt(melodyColorInput?.value, 10) || 0,
        subdivisionDensity: parseInt(melodySubdivisionDensityInput?.value, 10) || 0,
        subdivisionMode: melodySubdivisionInput?.value || "even",
        style: melodyStyleInput?.value || "auto",
        register: parseInt(melodyRegisterInput?.value, 10) || 72,
        genre: blendSubs || (melodyGenreSub?.value || genreSub?.value || "base"),
        mainGenre: blendMains || (melodyGenreMain?.value || genreMain?.value || "")
      });
      selectedMelodyIndices.forEach((index) => {
        if (!currentMelody[index] || !freshMelody[index]) return;
        currentMelody[index].note = freshMelody[index].note;
      });
      renderMelodyTrack();
      pruneSelectionSets();
      applySelectionStyles();
      rebuildMidi();
    }

    function regenerateSelectedDrums() {
      if (!selectedDrumIndices.size) {
        regenerateDrums(true);
        return;
      }
      const seedLabel = currentSeed || createRegenSeedLabel();
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const drumSeed = getDrumSeedLabel(seedLabel, true);
      const drumMain = blendMains || (drumGenreMain?.value || genreMain?.value || "");
      const drumSub = blendSubs || (drumGenreSub?.value || genreSub?.value || "base");
      const resolvedStyle = resolveDrumStyle(
        Array.isArray(drumMain) ? drumMain[0] : drumMain,
        Array.isArray(drumSub) ? drumSub[0] : drumSub,
        drumStyleInput?.value || "auto"
      );
      const notePoolByStyle = {
        jazz: [51, 42, 36, 38, 37],
        funk: [36, 38, 42, 46, 39],
        hiphop: [36, 38, 42, 46, 39],
        blues: [36, 38, 42, 46],
        latin: [36, 38, 37, 42, 46],
        reggae: [36, 38, 42],
        electronic: [36, 38, 42, 46, 49],
        rock: [36, 38, 42, 46, 49, 51],
        pop: [36, 38, 42, 46, 49]
      };
      const notePool = notePoolByStyle[resolvedStyle] || notePoolByStyle.pop;
      let freshDrums = generateDrumPattern({
        bars: parseInt(barsInput?.value, 10) || 4,
        seed: drumSeed,
        densityPercent: parseInt(drumDensityInput?.value, 10) || 0,
        complexityPercent: parseInt(drumComplexityInput?.value, 10) || 0,
        fillPercent: parseInt(drumFillsInput?.value, 10) || 0,
        ghostPercent: parseInt(drumGhostInput?.value, 10) || 0,
        velocityPercent: parseInt(drumVelocityInput?.value, 10) || 100,
        style: drumStyleInput?.value || "auto",
        genre: drumSub,
        mainGenre: drumMain
      });
      const rng = makeRng(`${drumSeed}-select`);
      selectedDrumIndices.forEach((index) => {
        const existing = currentDrums[index];
        if (!existing) return;
        const barIndex = Math.floor(existing.startBeat / 4);
        const candidates = freshDrums.filter(hit => Math.floor(hit.startBeat / 4) === barIndex);
        let candidate = candidates.length
          ? candidates[Math.floor(rng() * candidates.length)]
          : freshDrums[Math.floor(rng() * freshDrums.length)];
        if (!candidate) return;
        let newNote = candidate.note;
        let newVelocity = candidate.velocity;
        if (newNote === existing.note && Math.abs((newVelocity ?? 0) - (existing.velocity ?? 0)) < 2) {
          const alternatives = notePool.filter(note => note !== existing.note);
          if (alternatives.length) {
            newNote = alternatives[Math.floor(rng() * alternatives.length)];
          }
          newVelocity = Math.max(1, Math.min(127, (existing.velocity || 90) + (rng() < 0.5 ? -12 : 12)));
        }
        existing.note = newNote;
        existing.velocity = newVelocity;
      });
      drumAutoRegenerate = true;
      renderDrumTrack();
      pruneSelectionSets();
      applySelectionStyles();
      rebuildMidi();
    }

    function stopPlayback() {
      clearPendingCycle();
      clearTimers();
      stopPlaybackScroll();
      clearBassHighlights();
      clearMelodyHighlights();
      clearDrumHighlights();
      document.body.classList.remove("playing");
      if (!isPlaying) {
        sendAllNotesOff();
        sendGlobalAllNotesOff();
        return;
      }
      isPlaying = false;
      playButton.textContent = "Play";
      if (audioContext && masterGain) {
        const now = audioContext.currentTime;
        masterGain.gain.cancelScheduledValues(now);
        masterGain.gain.setTargetAtTime(0, now, 0.015);
      }
      activeOscillators.forEach(osc => {
        try {
          osc.stop();
        } catch (err) {
          // Ignore if already stopped.
        }
      });
      activeOscillators.clear();
      sendAllNotesOff();
      sendGlobalAllNotesOff();
    }

    function restoreMasterGain() {
      if (audioContext && masterGain) {
        masterGain.gain.cancelScheduledValues(audioContext.currentTime);
        masterGain.gain.setValueAtTime(midiEnabled ? 0 : DEFAULT_GAIN, audioContext.currentTime);
      }
    }

    function startPlayback(startIndex) {
      if (!currentChords.length) return;
      const restarting = isPlaying;
      if (restarting) {
        sendAllNotesOff();
      }
      ensureAudio();
      ensureMidi();
      resolveBackingSettings();
      isPlaying = true;
      playButton.textContent = "Stop";
      document.body.classList.add("playing");
      clearTimers();

      const bpm = getPlaybackBpm();
      const beatSec = 60 / bpm;
      const safeStart = ((startIndex % currentChords.length) + currentChords.length) % currentChords.length;
      let cursor = 0;
      const startBeat = chordStarts[safeStart] || 0;
      const totalBeats = currentChords.reduce((sum, chord) => sum + chord.duration, 0);

      setActiveChord(safeStart);
      clearBassHighlights();
      clearMelodyHighlights();
      clearDrumHighlights();
      restoreMasterGain();
      if (midiEnabled) {
        ensureMidi();
      }
      startPlaybackScroll(startBeat, totalBeats, beatSec);

      const baseMs = performance.now();
      for (let i = safeStart; i < currentChords.length; i++) {
        const chord = currentChords[i];
        const startTime = audioContext.currentTime + cursor * beatSec;
        playChordBacking(chord, startTime, beatSec);
        if (midiEnabled) {
          scheduleMidiChordBacking(
            chord,
            (baseMs + cursor * beatSec * 1000) - performance.now(),
            beatSec,
            false
          );
        }
        const timerId = setTimeout(() => {
          setActiveChord(i);
        }, Math.max(0, cursor * beatSec * 1000));
        playTimers.push(timerId);
        cursor += chord.duration;
      }

      if (currentBass.length) {
        const baseMs = performance.now();
        currentBass.forEach((note, index) => {
          if (note.startBeat < startBeat) return;
          const offsetBeat = note.startBeat - startBeat;
          const startTime = audioContext.currentTime + offsetBeat * beatSec;
          playBassNoteAtTime(note.note, startTime, note.duration * beatSec);
          if (midiEnabled) {
            scheduleMidiBass(note.note, (baseMs + offsetBeat * beatSec * 1000) - performance.now(), note.duration * beatSec * 1000);
          }
          const onId = setTimeout(() => {
            setBassClipActive(index, true);
          }, Math.max(0, offsetBeat * beatSec * 1000));
          const offId = setTimeout(() => {
            setBassClipActive(index, false);
          }, Math.max(0, offsetBeat * beatSec * 1000 + note.duration * beatSec * 1000));
          playTimers.push(onId, offId);
        });
      }

      if (currentMelody.length) {
        const baseMs = performance.now();
        currentMelody.forEach((note, index) => {
          if (note.startBeat < startBeat) return;
          const offsetBeat = note.startBeat - startBeat;
          const startTime = audioContext.currentTime + offsetBeat * beatSec;
          playMelodyNoteAtTime(note.note, startTime, note.duration * beatSec);
          if (midiEnabled) {
            scheduleMidiMelody(note.note, (baseMs + offsetBeat * beatSec * 1000) - performance.now(), note.duration * beatSec * 1000);
          }
          const onId = setTimeout(() => {
            setMelodyClipActive(index, true);
          }, Math.max(0, offsetBeat * beatSec * 1000));
          const offId = setTimeout(() => {
            setMelodyClipActive(index, false);
          }, Math.max(0, offsetBeat * beatSec * 1000 + note.duration * beatSec * 1000));
          playTimers.push(onId, offId);
        });
      }

      if (currentDrums.length) {
        const baseMs = performance.now();
        currentDrums.forEach((hit, index) => {
          if (hit.startBeat < startBeat) return;
          const offsetBeat = hit.startBeat - startBeat;
          const startDelayMs = Math.max(0, offsetBeat * beatSec * 1000);
          if (midiEnabled) {
            scheduleMidiDrum(
              hit.note,
              (baseMs + startDelayMs) - performance.now(),
              hit.duration * beatSec * 1000,
              hit.velocity || 90
            );
          }
          const onId = setTimeout(() => {
            const vel = scaleDrumVelocity(hit.velocity || 90);
            playDrumHitAtTime(hit.note, audioContext.currentTime, hit.duration * beatSec, vel);
            setDrumClipActive(index, true);
          }, startDelayMs);
          const offId = setTimeout(() => {
            setDrumClipActive(index, false);
          }, Math.max(0, startDelayMs + hit.duration * beatSec * 1000));
          playTimers.push(onId, offId);
        });
      }

      scheduleChordRegenPrefetch(cursor, beatSec);

      const endTimer = setTimeout(() => {
        if (!isPlaying) return;
        if (chordPlaybackMode === "regen") {
          const signature = getSettingsSignature();
          let cycle = pendingCycle && pendingCycleSignature === signature
            ? pendingCycle
            : null;
          if (!cycle) {
            const seedLabel = createRegenSeedLabel();
            cycle = prepareChordRegenCycle(seedLabel, currentSeed);
          }
          const keepAlign = songMode
            && chordPanel?.classList.contains("collapsed")
            && bassPanel?.classList.contains("collapsed")
            && melodyPanel?.classList.contains("collapsed")
            && drumPanel?.classList.contains("collapsed");
          if (keepAlign) {
            suppressPanelAlignment = true;
          }
          applyChordRegenCycle(cycle, true);
          clearPendingCycle();
          if (keepAlign) {
            suppressPanelAlignment = false;
          }
        } else {
          if (songMode && bassPlaybackMode === "regen") {
            regenerateBass(true);
          }
          if (songMode && melodyPlaybackMode === "regen") {
            regenerateMelody(true);
          }
          if (songMode && drumPlaybackMode === "regen") {
            regenerateDrums(true);
          }
        }
        startPlayback(0);
      }, cursor * beatSec * 1000);
      playTimers.push(endTimer);
    }

    function updateReadouts() {
      barsReadout.textContent = `${barsInput.value} bars`;
      if (formComplexityReadout && formComplexityInput) {
        formComplexityReadout.textContent = `${formComplexityInput.value}%`;
      }
      densityReadout.textContent = `${densityInput.value}%`;
      colorReadout.textContent = `${colorInput.value}%`;
      modulationReadout.textContent = `${modulationInput.value}%`;
      subdivisionDensityReadout.textContent = `${subdivisionDensityInput.value}%`;
      if (backingCompReadout && backingCompInput) {
        backingCompReadout.textContent = `${backingCompInput.value}%`;
      }
      if (bassDensityReadout && bassDensityInput) {
        bassDensityReadout.textContent = `${bassDensityInput.value}%`;
      }
      if (bassMovementReadout && bassMovementInput) {
        bassMovementReadout.textContent = `${bassMovementInput.value}%`;
      }
      if (bassColorReadout && bassColorInput) {
        bassColorReadout.textContent = `${bassColorInput.value}%`;
      }
      if (bassFillsReadout && bassFillsInput) {
        bassFillsReadout.textContent = `${bassFillsInput.value}%`;
      }
      if (bassRestsReadout && bassRestsInput) {
        bassRestsReadout.textContent = `${bassRestsInput.value}%`;
      }
      if (bassSubdivisionDensityReadout && bassSubdivisionDensityInput) {
        bassSubdivisionDensityReadout.textContent = `${bassSubdivisionDensityInput.value}%`;
      }
      if (bassRegisterReadout && bassRegisterInput) {
        bassRegisterReadout.textContent = noteLabelFromMidi(parseInt(bassRegisterInput.value, 10) || 36);
      }
      if (melodyDensityReadout && melodyDensityInput) {
        melodyDensityReadout.textContent = `${melodyDensityInput.value}%`;
      }
      if (melodyMovementReadout && melodyMovementInput) {
        melodyMovementReadout.textContent = `${melodyMovementInput.value}%`;
      }
      if (melodyColorReadout && melodyColorInput) {
        melodyColorReadout.textContent = `${melodyColorInput.value}%`;
      }
      if (melodyFillsReadout && melodyFillsInput) {
        melodyFillsReadout.textContent = `${melodyFillsInput.value}%`;
      }
      if (melodyRestsReadout && melodyRestsInput) {
        melodyRestsReadout.textContent = `${melodyRestsInput.value}%`;
      }
      if (melodySubdivisionDensityReadout && melodySubdivisionDensityInput) {
        melodySubdivisionDensityReadout.textContent = `${melodySubdivisionDensityInput.value}%`;
      }
      if (melodyRegisterReadout && melodyRegisterInput) {
        melodyRegisterReadout.textContent = noteLabelFromMidi(parseInt(melodyRegisterInput.value, 10) || 72);
      }
      if (drumDensityReadout && drumDensityInput) {
        drumDensityReadout.textContent = `${drumDensityInput.value}%`;
      }
      if (drumComplexityReadout && drumComplexityInput) {
        drumComplexityReadout.textContent = `${drumComplexityInput.value}%`;
      }
      if (drumFillsReadout && drumFillsInput) {
        drumFillsReadout.textContent = `${drumFillsInput.value}%`;
      }
      if (drumGhostReadout && drumGhostInput) {
        drumGhostReadout.textContent = `${drumGhostInput.value}%`;
      }
      if (drumVelocityReadout && drumVelocityInput) {
        drumVelocityReadout.textContent = `${drumVelocityInput.value}%`;
      }
      if (tempoNumber && document.activeElement !== tempoNumber) {
        if (midiEnabled && externalBpm) {
          tempoNumber.value = externalBpm.toFixed(1);
        } else {
          tempoNumber.value = tempoInput.value;
        }
      }
      if (tempoReadout) {
        if (midiEnabled) {
          tempoReadout.textContent = externalBpm
            ? `EXT ${externalBpm.toFixed(1)} BPM`
            : `INT ${tempoNumber ? tempoNumber.value : tempoInput.value} BPM`;
        } else {
          tempoReadout.textContent = `${tempoNumber ? tempoNumber.value : tempoInput.value} BPM`;
        }
      }
    }

    function getPlaybackBpm() {
      if (midiEnabled && externalBpm) {
        return externalBpm;
      }
      const source = tempoNumber ? tempoNumber.value : tempoInput.value;
      const parsed = parseFloat(source);
      const fallback = parseFloat(tempoInput.value);
      const value = Number.isFinite(parsed) ? parsed : (Number.isFinite(fallback) ? fallback : 110);
      return Math.max(40, Math.min(200, value));
    }

    function clampTempoValue(value) {
      const min = tempoInput ? parseFloat(tempoInput.min) || 40 : 40;
      const max = tempoInput ? parseFloat(tempoInput.max) || 200 : 200;
      return Math.max(min, Math.min(max, value));
    }

    function applyTempoValue(rawValue, syncNumber = true) {
      if (!tempoInput) return;
      const parsed = parseFloat(rawValue);
      if (!Number.isFinite(parsed)) return;
      const next = clampTempoValue(parsed);
      tempoInput.value = String(next);
      if (tempoNumber && (syncNumber || document.activeElement !== tempoNumber)) {
        tempoNumber.value = String(next);
      }
      updateReadouts();
      if (isPlaying && (!midiEnabled || !externalBpm)) {
        const resumeIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
        stopPlayback();
        startPlayback(resumeIndex);
      }
    }

    function handleTempoTyping(rawValue, event) {
      if (event && event.data === ".") return;
      const clean = rawValue.trim();
      if (!clean) return;
      if (!/^\d+(\.\d*)?$/.test(clean)) return;
      if (clean.endsWith(".")) return;
      const parsed = parseFloat(clean);
      if (!Number.isFinite(parsed)) return;
      const min = tempoInput ? parseFloat(tempoInput.min) || 40 : 40;
      const max = tempoInput ? parseFloat(tempoInput.max) || 200 : 200;
      if (parsed >= min && parsed <= max) {
        applyTempoValue(parsed, false);
      }
    }

    function getSettingsSignature() {
      const signature = {
        seed: currentSeed || "",
        key: keySelect?.value || "",
        bars: barsInput?.value || "",
        formOn: formEnabled,
        formComplexity: formComplexityInput?.value || "",
        density: densityInput?.value || "",
        color: colorInput?.value || "",
        modulation: modulationInput?.value || "",
        subdivision: subdivisionInput?.value || "",
        subdivisionDensity: subdivisionDensityInput?.value || "",
        backingStyle: backingStyleInput?.value || "blocks",
        backingComp: backingCompInput?.value || "",
        tempo: (tempoNumber?.value || tempoInput?.value) || "",
        genreMain: genreMain?.value || "",
        genreSub: genreSub?.value || "",
        blendManual: manualBlendEnabled,
        blendList: manualBlendGenres.join("|"),
        bass: {
          on: bassAutoRegenerate,
          density: bassDensityInput?.value || "",
          movement: bassMovementInput?.value || "",
          color: bassColorInput?.value || "",
          fills: bassFillsInput?.value || "",
          rests: bassRestsInput?.value || "",
          subdivision: bassSubdivisionInput?.value || "",
          subdivisionDensity: bassSubdivisionDensityInput?.value || "",
          style: bassStyleInput?.value || "",
          register: bassRegisterInput?.value || "",
          genreMain: bassGenreMain?.value || "",
          genreSub: bassGenreSub?.value || ""
        },
        melody: {
          on: melodyAutoRegenerate,
          density: melodyDensityInput?.value || "",
          movement: melodyMovementInput?.value || "",
          color: melodyColorInput?.value || "",
          fills: melodyFillsInput?.value || "",
          rests: melodyRestsInput?.value || "",
          subdivision: melodySubdivisionInput?.value || "",
          subdivisionDensity: melodySubdivisionDensityInput?.value || "",
          style: melodyStyleInput?.value || "",
          register: melodyRegisterInput?.value || "",
          genreMain: melodyGenreMain?.value || "",
          genreSub: melodyGenreSub?.value || ""
        },
        drums: {
          on: drumAutoRegenerate,
          density: drumDensityInput?.value || "",
          complexity: drumComplexityInput?.value || "",
          fills: drumFillsInput?.value || "",
          ghost: drumGhostInput?.value || "",
          velocity: drumVelocityInput?.value || "",
          style: drumStyleInput?.value || "",
          genreMain: drumGenreMain?.value || "",
          genreSub: drumGenreSub?.value || ""
        },
        playbackModes: {
          chord: chordPlaybackMode,
          bass: bassPlaybackMode,
          melody: melodyPlaybackMode,
          drum: drumPlaybackMode
        },
        midiEnabled
      };
      return JSON.stringify(signature);
    }

    function createRegenSeedLabel() {
      const rand = Math.random().toString(36).slice(2, 8);
      return `change-${rand}`;
    }

    function buildSeedLabelWithCounter(baseSeed, counter, type, forceNew = false) {
      if (forceNew) {
        const rand = Math.random().toString(36).slice(2, 6);
        return {
          seed: `${baseSeed}|${type}-${counter + 1}-${rand}`,
          counter: counter + 1
        };
      }
      return { seed: `${baseSeed}|${type}-${counter}`, counter };
    }

    function prepareChordRegenCycle(seedLabel, previousSeed) {
      let bars = parseInt(barsInput.value, 10);
      if (formEnabled && (!Number.isFinite(bars) || bars < 8)) {
        bars = 8;
        if (barsInput) barsInput.value = "8";
      }
      const formComplexityValue = normalizePercent(formComplexityInput?.value, 0);
      const densityPercent = Math.max(0, Math.min(100, parseInt(densityInput.value, 10) || 0));
      const colorPercent = Math.max(0, Math.min(100, parseInt(colorInput.value, 10) || 0));
      const modulationPercent = Math.max(0, Math.min(100, parseInt(modulationInput.value, 10) || 0));
      const subdivision = subdivisionInput.value;
      const subdivisionDensity = Math.max(0, Math.min(100, parseInt(subdivisionDensityInput.value, 10) || 0)) / 100;
      const bpm = getPlaybackBpm();
      const seedBlend = getActiveBlend();
      const blendSubs = seedBlend && seedBlend.subs && seedBlend.subs.length ? seedBlend.subs : null;
      const blendMains = seedBlend && seedBlend.mains && seedBlend.mains.length ? seedBlend.mains : null;
      const genre = blendSubs || (genreSub ? genreSub.value : "base");
      const genreLabel = blendSubs
        ? blendSubs.map(getSubGenreLabel).join(" + ")
        : ((genreMain && genreSub && genreCatalog[genreMain.value] && genreCatalog[genreMain.value].sub[genreSub.value])
          ? genreCatalog[genreMain.value].sub[genreSub.value]
          : genre);
      const keyChoice = keySelect.value;
      let key = keyChoice;
      let keyLabel = keyChoice;
      if (keyChoice === "random") {
        const keyRng = makeRng(`${seedLabel}-key`);
        key = noteNames[Math.floor(keyRng() * noteNames.length)];
        keyLabel = `random → ${key}`;
      }
      const chords = generateProgression({
        bars,
        key,
        densityPercent,
        seed: seedLabel,
        subdivision,
        subdivisionDensity,
        genre,
        modulationPercent,
        colorPercent,
        formEnabled,
        formComplexity: formComplexityValue
      });
      const formSections = (formEnabled && currentFormSections.length)
        ? currentFormSections.map(section => ({ ...section }))
        : [];

      let nextBassCounter = bassSeedCounter;
      let nextMelodyCounter = melodySeedCounter;
      let nextDrumCounter = drumSeedCounter;
      if (previousSeed && previousSeed !== seedLabel) {
        nextBassCounter = 0;
        nextMelodyCounter = 0;
        nextDrumCounter = 0;
      }

      let bass = [];
      if (bassAutoRegenerate) {
        const bassGenre = blendSubs || (bassGenreSub?.value || genreSub?.value || "base");
        const bassMainGenre = blendMains || (bassGenreMain?.value || genreMain?.value || "");
        const seedInfo = buildSeedLabelWithCounter(seedLabel, nextBassCounter, "bass", false);
        nextBassCounter = seedInfo.counter;
        const bassOptions = {
          chords,
          seed: seedInfo.seed,
          densityPercent: parseInt(bassDensityInput?.value, 10) || 0,
          movementPercent: parseInt(bassMovementInput?.value, 10) || 0,
          fillPercent: parseInt(bassFillsInput?.value, 10) || 0,
          restPercent: parseInt(bassRestsInput?.value, 10) || 0,
          colorPercent: parseInt(bassColorInput?.value, 10) || 0,
          subdivisionDensity: parseInt(bassSubdivisionDensityInput?.value, 10) || 0,
          subdivisionMode: bassSubdivisionInput?.value || "even",
          style: bassStyleInput?.value || "auto",
          register: parseInt(bassRegisterInput?.value, 10) || 36,
          genre: bassGenre,
          mainGenre: bassMainGenre,
          formComplexity: formComplexityValue
        };
        bass = (songMode && formSections.length)
          ? generateBassLineWithForm({ ...bassOptions, sections: formSections })
          : generateBassLine(bassOptions);
      }

      let melody = [];
      if (melodyAutoRegenerate) {
        const melodyGenre = blendSubs || (melodyGenreSub?.value || genreSub?.value || "base");
        const melodyMainGenre = blendMains || (melodyGenreMain?.value || genreMain?.value || "");
        const seedInfo = buildSeedLabelWithCounter(seedLabel, nextMelodyCounter, "melody", false);
        nextMelodyCounter = seedInfo.counter;
        const melodyOptions = {
          chords,
          seed: seedInfo.seed,
          densityPercent: parseInt(melodyDensityInput?.value, 10) || 0,
          movementPercent: parseInt(melodyMovementInput?.value, 10) || 0,
          fillPercent: parseInt(melodyFillsInput?.value, 10) || 0,
          restPercent: parseInt(melodyRestsInput?.value, 10) || 0,
          colorPercent: parseInt(melodyColorInput?.value, 10) || 0,
          subdivisionDensity: parseInt(melodySubdivisionDensityInput?.value, 10) || 0,
          subdivisionMode: melodySubdivisionInput?.value || "even",
          style: melodyStyleInput?.value || "auto",
          register: parseInt(melodyRegisterInput?.value, 10) || 72,
          genre: melodyGenre,
          mainGenre: melodyMainGenre,
          formComplexity: formComplexityValue
        };
        melody = (songMode && formSections.length)
          ? generateMelodyLineWithForm({ ...melodyOptions, sections: formSections })
          : generateMelodyLine(melodyOptions);
      }

      let drums = [];
      if (drumAutoRegenerate) {
        const seedInfo = buildSeedLabelWithCounter(seedLabel, nextDrumCounter, "drum", false);
        nextDrumCounter = seedInfo.counter;
        const drumMain = blendMains || (drumGenreMain?.value || genreMain?.value || "");
        const drumSub = blendSubs || (drumGenreSub?.value || genreSub?.value || "base");
        const drumOptions = {
          bars,
          seed: seedInfo.seed,
          densityPercent: parseInt(drumDensityInput?.value, 10) || 0,
          complexityPercent: parseInt(drumComplexityInput?.value, 10) || 0,
          fillPercent: parseInt(drumFillsInput?.value, 10) || 0,
          ghostPercent: parseInt(drumGhostInput?.value, 10) || 0,
          velocityPercent: parseInt(drumVelocityInput?.value, 10) || 100,
          style: drumStyleInput?.value || "auto",
          genre: drumSub,
          mainGenre: drumMain,
          formComplexity: formComplexityValue
        };
        drums = (songMode && formSections.length)
          ? generateDrumPatternWithForm({ ...drumOptions, sections: formSections })
          : generateDrumPattern(drumOptions);
      }

      return {
        seedLabel,
        bars,
        bpm,
        key,
        keyLabel,
        genreLabel,
        densityPercent,
        colorPercent,
        modulationPercent,
        subdivision,
        subdivisionDensity,
        chords,
        bass,
        melody,
        drums,
        formSections,
        formComplexity: formComplexityValue,
        counters: {
          bass: nextBassCounter,
          melody: nextMelodyCounter,
          drum: nextDrumCounter
        }
      };
    }

    function applyChordRegenCycle(cycle, markSeedRandom = false) {
      if (!cycle) return;
      currentBpm = cycle.bpm;
      currentKeyUsed = cycle.key;
      currentKeyLabel = cycle.keyLabel;
      bassSeedCounter = cycle.counters?.bass ?? bassSeedCounter;
      melodySeedCounter = cycle.counters?.melody ?? melodySeedCounter;
      drumSeedCounter = cycle.counters?.drum ?? drumSeedCounter;
      currentChords = cycle.chords;
      currentBass = cycle.bass || [];
      currentMelody = cycle.melody || [];
      currentDrums = cycle.drums || [];
      currentFormSections = cycle.formSections || [];
      currentSeed = cycle.seedLabel;
      currentFileName = `${sanitizeFileName(cycle.seedLabel)}.mid`;
      rebuildMidi();

      ruler.innerHTML = "";
      track.innerHTML = "";
      timelineView.scrollLeft = 0;

      const totalBeats = cycle.chords.reduce((sum, chord) => sum + chord.duration, 0);
      const beatPx = 34;
      currentBeatPx = beatPx;
      const totalWidth = Math.max(Math.round(totalBeats * beatPx), timelineView.clientWidth - 2) + 16;
      timelineView.style.setProperty("--beat-px", `${beatPx}px`);
      timelineView.style.setProperty("--bar-px", `${beatPx * 4}px`);
      ruler.style.width = `${totalWidth}px`;
      track.style.width = `${totalWidth}px`;
      if (bassTrack) {
        bassTrack.style.width = `${totalWidth}px`;
      }
      if (melodyTrack) {
        melodyTrack.style.width = `${totalWidth}px`;
      }
      if (drumTrack) {
        drumTrack.style.width = `${totalWidth}px`;
      }
      if (formLane) {
        formLane.style.width = `${totalWidth}px`;
      }
      const maxScroll = Math.max(0, timelineView.scrollWidth - timelineView.clientWidth);
      timelineScroll.max = String(maxScroll);
      timelineScroll.value = "0";

      for (let bar = 0; bar < cycle.bars; bar++) {
        const label = document.createElement("div");
        label.className = "bar-label";
        label.style.left = `${bar * 4 * beatPx + 6}px`;
        label.textContent = `Bar ${bar + 1}`;
        ruler.appendChild(label);
      }
      renderFormLane(cycle.formSections, cycle.bars, beatPx);

      let beatCursor = 0;
      chordStarts = [];
      chordClips = [];
      bassClips = [];
      melodyClips = [];
      drumClips = [];
      currentChordIndex = -1;

      cycle.chords.forEach((chord, index) => {
        const clip = document.createElement("div");
        clip.className = "clip";
        clip.style.left = `${beatCursor * beatPx}px`;
        clip.style.width = `${Math.max(beatPx * 0.6, chord.duration * beatPx)}px`;
        clip.innerHTML = `<div class="clip-title">${chord.name}</div>`;
        clip.addEventListener("click", (event) => {
          event.preventDefault();
          auditionChordByIndex(index);
        });
        track.appendChild(clip);
        chordStarts.push(beatCursor);
        chordClips.push(clip);
        beatCursor += chord.duration;
      });

      renderBassTrack();
      renderMelodyTrack();
      renderDrumTrack();
      clearSelection();
      schedulePanelAlignment();

      chordTextTokens = buildProgressionTokens(cycle.chords);
      progressionText.value = formatProgressionTextFromTokens(chordTextTokens);
      renderProgressionHighlight(currentChordIndex);
      const subdivisionLabel = cycle.subdivision === "mixed" ? "even+triplet" : "even";
      const formLabel = (cycle.formSections && cycle.formSections.length)
        ? ` | form ${cycle.formComplexity ?? 0}%`
        : "";
      footer.textContent = `Key ${cycle.keyLabel} | ${cycle.bars} bars | ${cycle.bpm} BPM | ${cycle.genreLabel} | density ${cycle.densityPercent}% | color ${cycle.colorPercent}% | mod ${cycle.modulationPercent}% | ${subdivisionLabel} | subdiv ${Math.round(cycle.subdivisionDensity * 100)}%${formLabel}`;
    }

    function clearPendingCycle() {
      pendingCycle = null;
      pendingCycleSignature = "";
      if (pendingCycleTimer) {
        clearTimeout(pendingCycleTimer);
        pendingCycleTimer = null;
      }
    }

    function scheduleChordRegenPrefetch(totalBeats, beatSec) {
      clearPendingCycle();
      if (!isPlaying || chordPlaybackMode !== "regen") return;
      const prefetchBeats = Math.min(4, Math.max(1, totalBeats));
      const prefetchMs = Math.max(0, (totalBeats - prefetchBeats) * beatSec * 1000);
      pendingCycleTimer = setTimeout(() => {
        if (!isPlaying || chordPlaybackMode !== "regen") return;
        const signature = getSettingsSignature();
        const seedLabel = createRegenSeedLabel();
        const cycle = prepareChordRegenCycle(seedLabel, currentSeed);
        pendingCycle = cycle;
        pendingCycleSignature = signature;
      }, prefetchMs);
      playTimers.push(pendingCycleTimer);
    }

    function render(seedOverride = null) {
      stopPlayback();
      if (backingStyleInput && backingStyleInput.value === "random") {
        randomBackingStyle = null;
      }
      const previousSeed = currentSeed;
      const seedLabel = seedOverride || currentSeed || createRegenSeedLabel();
      if (seedOverride || !currentSeed) {
        currentSeed = seedLabel;
      }
      updateReadouts();
      const cycle = prepareChordRegenCycle(seedLabel, previousSeed);
      applyChordRegenCycle(cycle, false);
    }

    function randomizeChordSettings() {
      if (keySelect) {
        const options = Array.from(keySelect.options).map(option => option.value);
        const pool = options.filter(value => value && value !== "random");
        const list = pool.length ? pool : options;
        keySelect.value = list[Math.floor(Math.random() * list.length)] || keySelect.value;
      }
      if (document.body.classList.contains("blend-mode") && blendSelects) {
        const selects = Array.from(blendSelects.querySelectorAll("select"));
        if (selects.length) {
          selects.forEach(select => {
            const values = Array.from(select.options).map(option => option.value);
            if (values.length) {
              select.value = values[Math.floor(Math.random() * values.length)];
            }
          });
          updateManualBlendFromSelects(true);
        }
      } else if (genreMain && genreSub) {
        const mainKeys = Object.keys(genreCatalog);
        const mainPick = mainKeys[Math.floor(Math.random() * mainKeys.length)] || genreMain.value;
        genreMain.value = mainPick;
        populateSubgenres(mainPick);
        const subKeys = Object.keys(genreCatalog[mainPick].sub);
        genreSub.value = subKeys[Math.floor(Math.random() * subKeys.length)] || genreSub.value;
      }
      if (barsInput) {
        const min = parseInt(barsInput.min, 10) || 4;
        const max = parseInt(barsInput.max, 10) || 32;
        let nextBars = min + Math.floor(Math.random() * (max - min + 1));
        if (formEnabled && nextBars < 8) {
          nextBars = 8;
        }
        barsInput.value = String(nextBars);
      }
      if (densityInput) densityInput.value = String(Math.floor(Math.random() * 101));
      if (colorInput) colorInput.value = String(Math.floor(Math.random() * 101));
      if (modulationInput) modulationInput.value = String(Math.floor(Math.random() * 101));
      if (subdivisionDensityInput) subdivisionDensityInput.value = String(Math.floor(Math.random() * 101));
      if (subdivisionInput) subdivisionInput.value = Math.random() < 0.5 ? "even" : "mixed";
      updateReadouts();
      render(createRegenSeedLabel());
      pushHistory();
    }

    function randomizeBassControls() {
      if (bassDensityInput) bassDensityInput.value = String(Math.floor(Math.random() * 101));
      if (bassMovementInput) bassMovementInput.value = String(Math.floor(Math.random() * 101));
      if (bassColorInput) bassColorInput.value = String(Math.floor(Math.random() * 101));
      if (bassFillsInput) bassFillsInput.value = String(Math.floor(Math.random() * 101));
      if (bassRestsInput) bassRestsInput.value = String(Math.floor(Math.random() * 101));
      if (bassSubdivisionDensityInput) bassSubdivisionDensityInput.value = String(Math.floor(Math.random() * 101));
      if (bassSubdivisionInput) bassSubdivisionInput.value = Math.random() < 0.5 ? "even" : "mixed";
      if (bassStyleInput) {
        const styles = Array.from(bassStyleInput.options).map(option => option.value);
        bassStyleInput.value = styles[Math.floor(Math.random() * styles.length)] || "auto";
      }
      if (bassRegisterInput) {
        const min = parseInt(bassRegisterInput.min, 10) || 28;
        const max = parseInt(bassRegisterInput.max, 10) || 52;
        bassRegisterInput.value = String(min + Math.floor(Math.random() * (max - min + 1)));
      }
      updateReadouts();
      bassAutoRegenerate = true;
      regenerateBass(true);
      pushHistory();
    }

    function randomizeMelodyControls() {
      if (melodyDensityInput) melodyDensityInput.value = String(Math.floor(Math.random() * 101));
      if (melodyMovementInput) melodyMovementInput.value = String(Math.floor(Math.random() * 101));
      if (melodyColorInput) melodyColorInput.value = String(Math.floor(Math.random() * 101));
      if (melodyFillsInput) melodyFillsInput.value = String(Math.floor(Math.random() * 101));
      if (melodyRestsInput) melodyRestsInput.value = String(Math.floor(Math.random() * 101));
      if (melodySubdivisionDensityInput) melodySubdivisionDensityInput.value = String(Math.floor(Math.random() * 101));
      if (melodySubdivisionInput) melodySubdivisionInput.value = Math.random() < 0.5 ? "even" : "mixed";
      if (melodyStyleInput) {
        const styles = Array.from(melodyStyleInput.options).map(option => option.value);
        melodyStyleInput.value = styles[Math.floor(Math.random() * styles.length)] || "auto";
      }
      if (melodyRegisterInput) {
        const min = parseInt(melodyRegisterInput.min, 10) || 60;
        const max = parseInt(melodyRegisterInput.max, 10) || 84;
        melodyRegisterInput.value = String(min + Math.floor(Math.random() * (max - min + 1)));
      }
      updateReadouts();
      melodyAutoRegenerate = true;
      regenerateMelody(true);
      pushHistory();
    }

    function randomizeDrumControls() {
      if (drumDensityInput) drumDensityInput.value = String(Math.floor(Math.random() * 101));
      if (drumComplexityInput) drumComplexityInput.value = String(Math.floor(Math.random() * 101));
      if (drumFillsInput) drumFillsInput.value = String(Math.floor(Math.random() * 101));
      if (drumGhostInput) drumGhostInput.value = String(Math.floor(Math.random() * 101));
      if (drumVelocityInput) drumVelocityInput.value = String(40 + Math.floor(Math.random() * 61));
      if (drumStyleInput) {
        const styles = Array.from(drumStyleInput.options).map(option => option.value);
        drumStyleInput.value = styles[Math.floor(Math.random() * styles.length)] || "auto";
      }
      if (drumGenreMain && drumGenreSub) {
        const mainKeys = Object.keys(genreCatalog);
        const mainPick = mainKeys[Math.floor(Math.random() * mainKeys.length)] || "core";
        drumGenreMain.value = mainPick;
        populateSubgenresFor(mainPick, drumGenreSub);
        const subKeys = Object.keys(genreCatalog[mainPick].sub);
        drumGenreSub.value = subKeys[Math.floor(Math.random() * subKeys.length)] || subKeys[0];
      }
      updateReadouts();
      drumAutoRegenerate = true;
      regenerateDrums(true);
      pushHistory();
    }

    document.getElementById("generate").addEventListener("click", () => {
      if (selectedChordIndices.size) {
        regenerateSelectedChords();
      } else {
        render(createRegenSeedLabel());
      }
      pushHistory();
    });

    if (randomSettings) {
      randomSettings.addEventListener("click", () => {
        randomizeChordSettings();
      });
    }

    document.getElementById("download").addEventListener("click", () => {
      if (!currentMidi) return;
      if (!midiBlobUrl) return;
      const url = midiBlobUrl;
      const a = document.createElement("a");
      a.href = url;
      a.download = currentFileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
    });

    copyProgression.addEventListener("click", async () => {
      const text = progressionText.value.trim();
      if (!text) return;
      try {
        await navigator.clipboard.writeText(text);
        copyProgression.textContent = "Copied";
        setTimeout(() => {
          copyProgression.textContent = "Copy progression";
        }, 1200);
      } catch (err) {
        progressionText.focus();
        progressionText.select();
        document.execCommand("copy");
      }
    });

    if (blendToggle) {
      blendToggle.addEventListener("click", () => {
        const enable = !document.body.classList.contains("blend-mode");
        document.body.classList.toggle("blend-mode", enable);
        if (enable) {
          const defaults = [`${genreMain?.value || "core"}:${genreSub?.value || "base"}`];
          syncBlendSelects(defaults);
          updateManualBlendFromSelects(true);
        } else {
          const first = manualBlendGenres[0];
          if (first && genreMain && genreSub) {
            const [mainKey, subKey] = first.split(":");
            if (mainKey && subKey) {
              genreMain.value = mainKey;
              populateSubgenres(mainKey, subKey);
            }
          }
          manualBlendGenres = [];
          manualBlendEnabled = false;
          syncBlendSelects([]);
        }
        render();
        pushHistory();
      });
    }

    if (blendAdd) {
      blendAdd.addEventListener("click", () => {
        if (!blendSelects) return;
        const current = blendSelects.querySelectorAll("select").length;
        if (current >= 4) return;
        const fallback = `${genreMain?.value || "core"}:${genreSub?.value || "base"}`;
        const select = buildBlendSelect(fallback);
        blendSelects.appendChild(select);
        updateManualBlendFromSelects();
      });
    }

    if (bassGenerate) {
      bassGenerate.addEventListener("click", () => {
        if (selectedBassIndices.size) {
          regenerateSelectedBass();
        } else {
          regenerateBass(true);
        }
        pushHistory();
      });
    }

    if (melodyGenerate) {
      melodyGenerate.addEventListener("click", () => {
        if (selectedMelodyIndices.size) {
          regenerateSelectedMelody();
        } else {
          regenerateMelody(true);
        }
        pushHistory();
      });
    }

    if (drumGenerate) {
      drumGenerate.addEventListener("click", () => {
        if (selectedDrumIndices.size) {
          regenerateSelectedDrums();
        } else {
          regenerateDrums(true);
        }
        pushHistory();
      });
    }

    const helpContent = [
      "SYSTEM: Generates chord progressions and exports MIDI blocks.",
      "",
      "CONTROLS",
      "- Key center: Choose a root or random.",
      "- Genre + Subgenre: Pick a main style and a specific variant.",
      "- Tempo: BPM for playback and MIDI (drag or type).",
      "- MIDI out: WebMIDI in Chrome, defaults to Logic Pro Virtual In/Out, follows external clock when detected.",
      "- MIDI velocity: Sets chord + bass + melody + drum velocity while MIDI Out is on.",
      "- Bars: Length of the progression.",
      "- Form: Toggle song form for longer progressions (auto bumps to 8+ bars); complexity controls the layout.",
      "- Harmonic density (%): How busy the harmony feels.",
      "- Color (%): How extended the chord voicings are (higher = more extensions).",
      "- Theme: Use the bottom slider to shift the overall palette.",
      "- Modulation amount (%): Likelihood of key shifts.",
      "- Subdivision density (%): How often bars subdivide.",
      "- Subdivision mode: Even only or even + triplet feel.",
      "- Backing: Auto, Random, blocks, raked/strum, arps, chopped, stabs, or genre comp (auto or choose a specific genre comp style).",
      "- Backing complexity (%): Controls how busy the comp pattern is and shapes arp density.",
      "- Form lane: Section labels appear under the bar ruler.",
      "- Bass controls ($ong): Genre/subgenre, density, movement, color, fills, subdivision, style, register, and channel.",
      "- Melody controls ($ong): Genre/subgenre, density, movement, color, fills, subdivision, style, register, and channel.",
      "- Drum controls ($ong): Genre/subgenre, fills, ghost notes, velocity, plus style (GM drums on MIDI ch 4).",
      "- $ong mode follows form sections with dynamics and repeated motifs.",
      "- Drum genre is independent from chord/bass/melody genre if you want.",
      "- Bass fills (%): Scale-based fill notes (0% none, 100% every chord).",
      "- Bass rests (%): 0% legato, 100% choppy spacing.",
      "- Melody fills (%): Melodic fill notes within the chord scale.",
      "- Melody rests (%): 0% legato, 100% choppy spacing.",
      "- Track VOL: Per-panel audio level (center = current loudness, can boost louder).",
      "- Select: Drag a box over clips, then hit ¢hords/฿ass/Melody/Drums to replace only the selection.",
      "- Loop/Regen (per track): Loop that track or regenerate it at the end.",
      "- Mute icons: Toggle chord/bass/melody/drums audio + MIDI.",
      "",
      "BUTTONS",
      "- ¢hords: Generate a new progression.",
      "- Play: Listen with a sine synth (loops).",
      "- Download .mid: Save the MIDI file.",
      "- MIDI Out: Enable WebMIDI output (Chrome).",
      "- Route: Select MIDI in/out ports (default Logic Pro Virtual In/Out).",
      "- Random: Randomize chord settings (key/genre/density/etc); in Blend mode it randomizes the mix.",
      "- Copy progression: Copy chord text.",
      "- ฿ass: Generate a bass line in $ong mode.",
      "- Melody: Generate a melody line in $ong mode.",
      "- Drums: Generate a drum pattern in $ong mode.",
      "- Random bass / Random melody: Randomize track controls and regenerate.",
      "- Random drums: Randomize drum controls and regenerate.",
      "- Undo/Redo: Step backward/forward through recent changes.",
      "- Reset: Restore default settings.",
      "- Click clips: Jump the playhead and audition that chord/bass/melody/drum.",
      "",
      "HOTKEYS",
      "- Space: Play/Stop (global).",
      "- Left/Right: Step through chords.",
      "- C: ¢hords (new progression).",
      "- R: Random chord settings.",
      "- B: Generate bass.",
      "- M: Generate melody.",
      "- D: Generate drums.",
      "- Shift: Reset to defaults.",
      "- Click clips: Jump to that point and audition the chord/bass/melody/drum.",
      "- $ong button: Toggle $ong mode (auto-bass + auto-melody + auto-drums).",
      ""
    ].join("\n");

    let helpTypeTimer = null;

    function typeHelpText() {
      if (!helpText) return;
      helpText.textContent = "";
      if (helpTypeTimer) clearInterval(helpTypeTimer);
      let index = 0;
      const charsPerTick = 4;
      helpTypeTimer = setInterval(() => {
        helpText.textContent = helpContent.slice(0, index);
        index += charsPerTick;
        if (index > helpContent.length) {
          clearInterval(helpTypeTimer);
          helpTypeTimer = null;
        }
      }, 1);
    }

    function openHelp() {
      helpModal.classList.add("active");
      helpModal.setAttribute("aria-hidden", "false");
      typeHelpText();
    }

    function closeHelp() {
      helpModal.classList.remove("active");
      helpModal.setAttribute("aria-hidden", "true");
      if (helpTypeTimer) {
        clearInterval(helpTypeTimer);
        helpTypeTimer = null;
      }
    }

    function openRouteModal() {
      if (!routeModal) return;
      routeModal.classList.add("active");
      routeModal.setAttribute("aria-hidden", "false");
      refreshMidiRouteOptions();
    }

    function closeRouteModal() {
      if (!routeModal) return;
      routeModal.classList.remove("active");
      routeModal.setAttribute("aria-hidden", "true");
    }

    function setPanelCollapsed(panel, button) {
      if (!panel || !button) return;
      panel.classList.toggle("collapsed");
      button.textContent = panel.classList.contains("collapsed") ? "▸" : "▾";
      schedulePanelAlignment();
    }

    function setPanelCollapsedState(panel, button, collapsed) {
      if (!panel || !button) return;
      panel.classList.toggle("collapsed", collapsed);
      button.textContent = collapsed ? "▸" : "▾";
      schedulePanelAlignment();
    }

    function alignCollapsedPanels() {
      const panels = [
        { panel: chordPanel, track: track },
        { panel: bassPanel, track: bassTrack },
        { panel: melodyPanel, track: melodyTrack },
        { panel: drumPanel, track: drumTrack }
      ];
      if (!songMode) {
        panels.forEach(({ panel }) => {
          if (!panel) return;
          panel.classList.remove("align-track");
          panel.style.removeProperty("--track-shift");
        });
        return;
      }
      const anyExpanded = panels.some(({ panel }) => panel && !panel.classList.contains("collapsed"));
      if (anyExpanded) {
        panels.forEach(({ panel }) => {
          if (!panel) return;
          panel.classList.remove("align-track");
          panel.style.removeProperty("--track-shift");
        });
        return;
      }
      panels.forEach(({ panel, track }) => {
        if (!panel || !track) return;
        if (!panel.classList.contains("collapsed")) {
          panel.classList.remove("align-track");
          panel.style.removeProperty("--track-shift");
          return;
        }
        panel.classList.remove("align-track");
        panel.style.setProperty("--track-shift", "0px");
        const panelRect = panel.getBoundingClientRect();
        const trackRect = track.getBoundingClientRect();
        if (!panelRect.height || !trackRect.height) return;
        const panelCenter = panelRect.top + panelRect.height / 2;
        const trackCenter = trackRect.top + trackRect.height / 2;
        const delta = trackCenter - panelCenter;
        panel.style.setProperty("--track-shift", `${delta}px`);
        panel.classList.add("align-track");
      });
    }

    function schedulePanelAlignment() {
      if (suppressPanelAlignment) return;
      if (alignRaf) cancelAnimationFrame(alignRaf);
      alignRaf = requestAnimationFrame(() => {
        alignRaf = null;
        alignCollapsedPanels();
      });
    }

    function updateMuteButton(button, muted) {
      if (!button) return;
      button.setAttribute("aria-pressed", muted ? "true" : "false");
      button.textContent = "M";
    }

    function setSongMode(active) {
      songMode = active;
      document.body.classList.toggle("song-mode", songMode);
      if (songToggle) {
        songToggle.textContent = songMode ? "¢hange" : "$ong";
      }
      if (titleLeft && titleRight) {
        titleLeft.textContent = songMode ? "$ong" : "¢hange";
        titleRight.textContent = songMode ? "Machine" : "machine";
      }
      if (songMode) {
        if (backingStyleInput) {
          backingStyleInput.value = "auto";
        }
        resolveBackingSettings();
        updateBackingCompVisibility(backingStyleInput?.value);
        if (themeSlider) {
          themeSlider.value = String(200);
          applyThemeMix(2);
        }
        if (!currentChords.length) {
          render();
        }
        bassAutoRegenerate = true;
        regenerateBass(true);
        melodyAutoRegenerate = true;
        regenerateMelody(true);
        drumAutoRegenerate = true;
        regenerateDrums(true);
        rebuildMidi();
        setPanelCollapsedState(chordPanel, chordCollapse, true);
        setPanelCollapsedState(bassPanel, bassCollapse, true);
        setPanelCollapsedState(melodyPanel, melodyCollapse, true);
        setPanelCollapsedState(drumPanel, drumCollapse, true);
        schedulePanelAlignment();
      } else if (themeSlider) {
        stopPlayback();
        sendAllNotesOff();
        bassAutoRegenerate = false;
        melodyAutoRegenerate = false;
        drumAutoRegenerate = false;
        currentBass = [];
        currentMelody = [];
        currentDrums = [];
        renderBassTrack();
        renderMelodyTrack();
        renderDrumTrack();
        rebuildMidi();
        themeSlider.value = "0";
        applyThemeMix(0);
        setPanelCollapsedState(chordPanel, chordCollapse, false);
        schedulePanelAlignment();
      }
    }

    helpButton.addEventListener("click", openHelp);
    helpClose.addEventListener("click", closeHelp);
    helpModal.addEventListener("click", (event) => {
      if (event.target === helpModal) {
        closeHelp();
      }
    });


    playButton.addEventListener("click", () => {
      if (isPlaying) {
        stopPlayback();
        return;
      }
      const startIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
      startPlayback(startIndex);
    });

    document.addEventListener("keydown", (event) => {
      const tag = (event.target && event.target.tagName) ? event.target.tagName.toLowerCase() : "";
      if (!currentChords.length) return;
      const isCtrl = event.ctrlKey || event.metaKey;
      if (event.key === "Escape" && helpModal.classList.contains("active")) {
        event.preventDefault();
        closeHelp();
      } else if (event.key === "Escape" && routeModal && routeModal.classList.contains("active")) {
        event.preventDefault();
        closeRouteModal();
      } else if ((event.key === "c" || event.key === "C") && !isCtrl) {
        event.preventDefault();
        render(createRegenSeedLabel());
        return;
      } else if ((event.key === "b" || event.key === "B") && !isCtrl) {
        if (!bassGenerate) return;
        event.preventDefault();
        bassGenerate.click();
        return;
      } else if ((event.key === "m" || event.key === "M") && !isCtrl) {
        if (!melodyGenerate) return;
        event.preventDefault();
        melodyGenerate.click();
        return;
      } else if ((event.key === "d" || event.key === "D") && !isCtrl) {
        if (!drumGenerate) return;
        event.preventDefault();
        drumGenerate.click();
        return;
      } else if ((event.key === "r" || event.key === "R") && !isCtrl) {
        if (!randomSettings) return;
        event.preventDefault();
        randomSettings.click();
        return;
      } else if (event.key === "Shift") {
        if (!resetAll) return;
        event.preventDefault();
        resetAll.click();
        return;
      } else if (event.key === " ") {
        event.preventDefault();
        if (isPlaying) {
          stopPlayback();
        } else {
          const startIndex = currentChordIndex >= 0 ? currentChordIndex : 0;
          startPlayback(startIndex);
        }
      } else if (event.key === "ArrowRight") {
        if (tag === "input" || tag === "textarea" || tag === "select") return;
        event.preventDefault();
        stopPlayback();
        const nextIndex = (currentChordIndex + 1) % currentChords.length;
        setActiveChord(nextIndex);
        ensureAudio();
        restoreMasterGain();
        ensureMidi();
        const bpm = getPlaybackBpm();
        const beatSec = 60 / bpm;
        if (!chordMuted) {
          playChordBacking(currentChords[nextIndex], audioContext.currentTime, beatSec);
        }
        if (midiEnabled && !chordMuted) {
          scheduleMidiChordBacking(currentChords[nextIndex], 0, beatSec, true);
        }
      } else if (event.key === "ArrowLeft") {
        if (tag === "input" || tag === "textarea" || tag === "select") return;
        event.preventDefault();
        stopPlayback();
        const prevIndex = Math.max(0, currentChordIndex === -1 ? 0 : currentChordIndex - 1);
        setActiveChord(prevIndex);
        ensureAudio();
        restoreMasterGain();
        ensureMidi();
        const bpm = getPlaybackBpm();
        const beatSec = 60 / bpm;
        if (!chordMuted) {
          playChordBacking(currentChords[prevIndex], audioContext.currentTime, beatSec);
        }
        if (midiEnabled && !chordMuted) {
          scheduleMidiChordBacking(currentChords[prevIndex], 0, beatSec, true);
        }
      }
    });

    barsInput.addEventListener("input", () => {
      if (formEnabled) {
        const nextValue = parseInt(barsInput.value, 10) || 0;
        if (nextValue < 8) {
          barsInput.value = "8";
        }
      }
      updateReadouts();
    });
    if (formToggle) {
      formToggle.addEventListener("click", () => {
        setFormEnabledState(!formEnabled);
        if (formEnabled && barsInput) {
          const nextValue = parseInt(barsInput.value, 10) || 0;
          if (nextValue < 8) {
            barsInput.value = "8";
          }
        }
        updateReadouts();
        render();
        pushHistory();
      });
    }
    if (formComplexityInput) {
      formComplexityInput.addEventListener("input", () => {
        updateReadouts();
        if (formEnabled) {
          render();
        }
      });
    }
    densityInput.addEventListener("input", () => {
      updateReadouts();
    });
    colorInput.addEventListener("input", () => {
      updateReadouts();
      render();
    });
    modulationInput.addEventListener("input", () => {
      updateReadouts();
    });
    subdivisionDensityInput.addEventListener("input", () => {
      updateReadouts();
    });
    if (bassDensityInput) {
      bassDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassMovementInput) {
      bassMovementInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassColorInput) {
      bassColorInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassFillsInput) {
      bassFillsInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassRestsInput) {
      bassRestsInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassSubdivisionDensityInput) {
      bassSubdivisionDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassSubdivisionInput) {
      bassSubdivisionInput.addEventListener("change", () => {
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassStyleInput) {
      bassStyleInput.addEventListener("change", () => {
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (bassRegisterInput) {
      bassRegisterInput.addEventListener("input", () => {
        updateReadouts();
        if (bassAutoRegenerate) {
          regenerateBass();
        }
      });
    }
    if (melodyDensityInput) {
      melodyDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodyMovementInput) {
      melodyMovementInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodyColorInput) {
      melodyColorInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodyFillsInput) {
      melodyFillsInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodyRestsInput) {
      melodyRestsInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodySubdivisionDensityInput) {
      melodySubdivisionDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodySubdivisionInput) {
      melodySubdivisionInput.addEventListener("change", () => {
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodyStyleInput) {
      melodyStyleInput.addEventListener("change", () => {
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (melodyRegisterInput) {
      melodyRegisterInput.addEventListener("input", () => {
        updateReadouts();
        if (melodyAutoRegenerate) {
          regenerateMelody();
        }
      });
    }
    if (drumDensityInput) {
      drumDensityInput.addEventListener("input", () => {
        updateReadouts();
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (drumComplexityInput) {
      drumComplexityInput.addEventListener("input", () => {
        updateReadouts();
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (drumFillsInput) {
      drumFillsInput.addEventListener("input", () => {
        updateReadouts();
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (drumGhostInput) {
      drumGhostInput.addEventListener("input", () => {
        updateReadouts();
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (drumVelocityInput) {
      drumVelocityInput.addEventListener("input", () => {
        updateReadouts();
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (drumStyleInput) {
      drumStyleInput.addEventListener("change", () => {
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (drumGenreMain && drumGenreSub) {
      drumGenreMain.addEventListener("change", () => {
        populateSubgenresFor(drumGenreMain.value, drumGenreSub);
        if (selectionMode) {
          return;
        }
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
      drumGenreSub.addEventListener("change", () => {
        if (selectionMode) {
          return;
        }
        if (drumAutoRegenerate) {
          regenerateDrums();
        }
      });
    }
    if (bassGenreMain && bassGenreSub) {
      bassGenreMain.addEventListener("change", () => {
        populateSubgenresFor(bassGenreMain.value, bassGenreSub);
        if (selectionMode) {
          return;
        }
        if (bassAutoRegenerate) {
          regenerateBass(true);
        }
      });
      bassGenreSub.addEventListener("change", () => {
        if (selectionMode) {
          return;
        }
        if (bassAutoRegenerate) {
          regenerateBass(true);
        }
      });
    }
    if (melodyGenreMain && melodyGenreSub) {
      melodyGenreMain.addEventListener("change", () => {
        populateSubgenresFor(melodyGenreMain.value, melodyGenreSub);
        if (selectionMode) {
          return;
        }
        if (melodyAutoRegenerate) {
          regenerateMelody(true);
        }
      });
      melodyGenreSub.addEventListener("change", () => {
        if (selectionMode) {
          return;
        }
        if (melodyAutoRegenerate) {
          regenerateMelody(true);
        }
      });
    }
    if (bassRandom) {
      bassRandom.addEventListener("click", () => {
        randomizeBassControls();
      });
    }
    if (melodyRandom) {
      melodyRandom.addEventListener("click", () => {
        randomizeMelodyControls();
      });
    }
    if (drumRandom) {
      drumRandom.addEventListener("click", () => {
        randomizeDrumControls();
      });
    }
    if (chordLoopButton) {
      chordLoopButton.addEventListener("click", () => {
        setTrackPlaybackMode("chord", chordPlaybackMode === "loop" ? "regen" : "loop");
      });
      setTrackPlaybackMode("chord", "loop");
    }
    if (bassLoopButton) {
      bassLoopButton.addEventListener("click", () => {
        setTrackPlaybackMode("bass", bassPlaybackMode === "loop" ? "regen" : "loop");
      });
      setTrackPlaybackMode("bass", "loop");
    }
    if (melodyLoopButton) {
      melodyLoopButton.addEventListener("click", () => {
        setTrackPlaybackMode("melody", melodyPlaybackMode === "loop" ? "regen" : "loop");
      });
      setTrackPlaybackMode("melody", "loop");
    }
    if (drumLoopButton) {
      drumLoopButton.addEventListener("click", () => {
        setTrackPlaybackMode("drum", drumPlaybackMode === "loop" ? "regen" : "loop");
      });
      setTrackPlaybackMode("drum", "loop");
    }
    if (chordVolumeInput) {
      chordVolumeInput.addEventListener("input", () => {
        updateTrackGains();
      });
    }
    if (bassVolumeInput) {
      bassVolumeInput.addEventListener("input", () => {
        updateTrackGains();
      });
    }
    if (melodyVolumeInput) {
      melodyVolumeInput.addEventListener("input", () => {
        updateTrackGains();
      });
    }
    if (drumVolumeInput) {
      drumVolumeInput.addEventListener("input", () => {
        updateTrackGains();
      });
    }
    if (chordChannelSelect) {
      chordChannelSelect.addEventListener("change", () => {
        sendAllNotesOff();
        rebuildMidi();
      });
    }
    if (bassChannelSelect) {
      bassChannelSelect.addEventListener("change", () => {
        sendAllNotesOff();
        rebuildMidi();
      });
    }
    if (melodyChannelSelect) {
      melodyChannelSelect.addEventListener("change", () => {
        sendAllNotesOff();
        rebuildMidi();
      });
    }
    tempoInput.addEventListener("input", () => {
      applyTempoValue(tempoInput.value);
    });
    if (tempoNumber) {
      tempoNumber.addEventListener("input", (event) => {
        handleTempoTyping(tempoNumber.value, event);
      });
      tempoNumber.addEventListener("change", () => {
        applyTempoValue(tempoNumber.value);
      });
      tempoNumber.addEventListener("blur", () => {
        applyTempoValue(tempoNumber.value);
      });
      tempoNumber.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          applyTempoValue(tempoNumber.value);
          tempoNumber.blur();
        }
      });
    }
    if (subdivisionInput) {
      subdivisionInput.addEventListener("change", () => {
      });
    }
    if (backingStyleInput) {
      backingStyleInput.addEventListener("change", () => {
        if (backingStyleInput.value !== "random") {
          randomBackingStyle = null;
        }
        resolveBackingSettings();
        updateBackingCompVisibility(backingStyleInput.value);
        rebuildMidi();
        pushHistory();
      });
    }
    if (backingCompInput) {
      backingCompInput.addEventListener("input", () => {
        updateReadouts();
        rebuildMidi();
      });
    }
    if (keySelect) {
      keySelect.addEventListener("change", () => {
      });
    }

    if (genreMain && genreSub) {
      genreMain.addEventListener("change", () => {
        populateSubgenres(genreMain.value);
        populateBackingStyles();
        render();
      });
      genreSub.addEventListener("change", () => {
        populateBackingStyles();
        render();
      });
    }

    timelineScroll.addEventListener("input", () => {
      timelineView.scrollLeft = parseInt(timelineScroll.value, 10) || 0;
    });

    timelineView.addEventListener("scroll", () => {
      timelineScroll.value = String(timelineView.scrollLeft);
    });

    if (timelineView) {
      selectionBox = document.createElement("div");
      selectionBox.className = "selection-box";
      selectionBox.style.display = "none";
      timelineView.appendChild(selectionBox);

      const onMouseMove = (event) => {
        if (!selectionStart || !selectionBox) return;
        const rect = timelineView.getBoundingClientRect();
        const currentX = event.clientX - rect.left + timelineView.scrollLeft;
        const currentY = event.clientY - rect.top + timelineView.scrollTop;
        const left = Math.min(selectionStart.x, currentX);
        const top = Math.min(selectionStart.y, currentY);
        const width = Math.abs(selectionStart.x - currentX);
        const height = Math.abs(selectionStart.y - currentY);
        selectionBox.style.left = `${left}px`;
        selectionBox.style.top = `${top}px`;
        selectionBox.style.width = `${width}px`;
        selectionBox.style.height = `${height}px`;
        updateSelectionFromBox();
      };

      const onMouseUp = () => {
        if (!selectionStart) return;
        if (selectionBox) {
          updateSelectionFromBox();
        }
        selectionStart = null;
        if (selectionBox) {
          selectionBox.style.display = "none";
        }
        window.removeEventListener("mousemove", onMouseMove);
        window.removeEventListener("mouseup", onMouseUp);
      };

      timelineView.addEventListener("mousedown", (event) => {
        if (!selectionMode) return;
        if (event.button !== 0) return;
        const rect = timelineView.getBoundingClientRect();
        selectionStart = {
          x: event.clientX - rect.left + timelineView.scrollLeft,
          y: event.clientY - rect.top + timelineView.scrollTop
        };
        clearSelection();
        if (selectionBox) {
          selectionBox.style.display = "block";
          selectionBox.style.left = `${selectionStart.x}px`;
          selectionBox.style.top = `${selectionStart.y}px`;
          selectionBox.style.width = "0px";
          selectionBox.style.height = "0px";
        }
        window.addEventListener("mousemove", onMouseMove);
        window.addEventListener("mouseup", onMouseUp);
        event.preventDefault();
      });
    }

    if (selectToggle) {
      selectToggle.addEventListener("click", () => {
        setSelectionMode(!selectionMode);
      });
      setSelectionMode(false);
    }

    if (midiOutSelect) {
      midiOutSelect.addEventListener("change", () => {
        if (!midiAccess) return;
        const output = midiAccess.outputs.get(midiOutSelect.value) || null;
        midiOutput = output;
        preferredOutputId = output ? output.id : null;
        refreshMidiRouteOptions();
      });
    }

    if (midiInSelect) {
      midiInSelect.addEventListener("change", () => {
        if (!midiAccess) return;
        const input = midiAccess.inputs.get(midiInSelect.value) || null;
        if (midiInput && midiInput !== input) {
          midiInput.onmidimessage = null;
        }
        midiInput = input;
        preferredInputId = input ? input.id : null;
        if (midiInput) {
          midiInput.onmidimessage = handleMidiMessage;
        }
        refreshMidiRouteOptions();
      });
    }

    window.addEventListener("resize", () => {
      resizeOscilloscope();
      schedulePanelAlignment();
    });

    if (midiToggle) {
      midiToggle.addEventListener("click", async () => {
        midiEnabled = !midiEnabled;
        if (midiEnabled) {
          tempoInput.disabled = false;
          if (tempoNumber) tempoNumber.disabled = false;
          if (midiVelocity) {
            midiVelocity.disabled = false;
          }
          document.body.classList.add("midi-on");
          await ensureMidi();
          if (!midiAccess) {
            midiEnabled = false;
            tempoInput.disabled = false;
            if (tempoNumber) tempoNumber.disabled = false;
            updateReadouts();
            midiToggle.textContent = "MIDI Out";
            document.body.classList.remove("midi-on");
            closeRouteModal();
            return;
          }
          midiToggle.textContent = midiOutput ? "MIDI Out: On" : "MIDI Out: No device";
          updateReadouts();
          restoreMasterGain();
        } else {
          sendAllNotesOff();
          midiOutput = null;
          if (midiInput) {
            midiInput.onmidimessage = null;
            midiInput = null;
          }
          externalBpm = null;
          lastClockTime = null;
          clockSmoothing = null;
          tempoInput.disabled = false;
          if (tempoNumber) tempoNumber.disabled = false;
          updateReadouts();
          midiToggle.textContent = "MIDI Out";
          restoreMasterGain();
          if (midiVelocity) {
            midiVelocity.disabled = true;
          }
          document.body.classList.remove("midi-on");
          closeRouteModal();
        }
      });
    }

    if (midiRoute) {
      midiRoute.addEventListener("click", async () => {
        if (!midiEnabled) return;
        await ensureMidi();
        openRouteModal();
      });
    }

    if (routeModal) {
      routeModal.addEventListener("click", (event) => {
        if (event.target === routeModal) {
          closeRouteModal();
        }
      });
    }

    if (routeClose) {
      routeClose.addEventListener("click", closeRouteModal);
    }

    if (undoButton) {
      updateHistoryButtons();
      undoButton.addEventListener("click", () => {
        if (historyIndex <= 0) return;
        historyIndex -= 1;
        applySnapshot(historyStack[historyIndex]);
      });
    }

    if (redoButton) {
      updateHistoryButtons();
      redoButton.addEventListener("click", () => {
        if (historyIndex >= historyStack.length - 1) return;
        historyIndex += 1;
        applySnapshot(historyStack[historyIndex]);
      });
    }

    if (songToggle) {
      songToggle.addEventListener("click", () => {
        setSongMode(!songMode);
        pushHistory();
      });
    }

    if (chordMute) {
      updateMuteButton(chordMute, chordMuted);
      chordMute.addEventListener("click", () => {
        chordMuted = !chordMuted;
        updateMuteButton(chordMute, chordMuted);
        updateTrackGains();
        if (midiEnabled) {
          if (chordMuted) {
            sendChordPanic();
          }
        }
      });
    }

    if (bassMute) {
      updateMuteButton(bassMute, bassMuted);
      bassMute.addEventListener("click", () => {
        bassMuted = !bassMuted;
        updateMuteButton(bassMute, bassMuted);
        updateTrackGains();
        if (midiEnabled && bassMuted) {
          activeBassNotes.forEach((channel, note) => {
            const resolved = channel === undefined ? getBassChannel() : channel;
            if (midiOutput) midiOutput.send([0x80 + resolved, note, 0]);
          });
          activeBassNotes.clear();
        }
      });
    }

    if (melodyMute) {
      updateMuteButton(melodyMute, melodyMuted);
      melodyMute.addEventListener("click", () => {
        melodyMuted = !melodyMuted;
        updateMuteButton(melodyMute, melodyMuted);
        updateTrackGains();
        if (midiEnabled && melodyMuted) {
          activeMelodyNotes.forEach((channel, note) => {
            const resolved = channel === undefined ? getMelodyChannel() : channel;
            if (midiOutput) midiOutput.send([0x80 + resolved, note, 0]);
          });
          activeMelodyNotes.clear();
        }
      });
    }

    if (drumMute) {
      updateMuteButton(drumMute, drumMuted);
      drumMute.addEventListener("click", () => {
        drumMuted = !drumMuted;
        updateMuteButton(drumMute, drumMuted);
        updateTrackGains();
        if (midiEnabled && drumMuted) {
          activeDrumNotes.forEach((channel, note) => {
            const resolved = channel === undefined ? getDrumChannel() : channel;
            if (midiOutput) midiOutput.send([0x80 + resolved, note, 0]);
          });
          activeDrumNotes.clear();
        }
      });
    }

    if (chordCollapse) {
      chordCollapse.addEventListener("click", () => {
        setPanelCollapsed(chordPanel, chordCollapse);
      });
    }

    if (bassCollapse) {
      bassCollapse.addEventListener("click", () => {
        setPanelCollapsed(bassPanel, bassCollapse);
      });
    }

    if (melodyCollapse) {
      melodyCollapse.addEventListener("click", () => {
        setPanelCollapsed(melodyPanel, melodyCollapse);
      });
    }

    if (drumCollapse) {
      drumCollapse.addEventListener("click", () => {
        setPanelCollapsed(drumPanel, drumCollapse);
      });
    }

    if (midiVelocity && midiVelocityValue) {
      midiVelocityValue.textContent = midiVelocity.value;
      midiVelocity.addEventListener("input", () => {
        midiVelocityValue.textContent = midiVelocity.value;
      });
      midiVelocity.disabled = true;
    }

    if (resetAll) {
      resetAll.addEventListener("click", () => {
        resetToDefaults();
        pushHistory();
      });
    }

    if (themeSlider) {
      const maxSteps = Math.max(0, (themes.length - 1) * 100);
      themeSlider.max = String(maxSteps);
      themeSlider.addEventListener("input", () => {
        const value = (parseInt(themeSlider.value, 10) || 0) / 100;
        applyThemeMix(value);
      });
      const startValue = (parseInt(themeSlider.value, 10) || 0) / 100;
      applyThemeMix(startValue);
    } else {
      updateThemeColors();
    }

    render();
    pushHistory();
  </script>
</body>
</html>

